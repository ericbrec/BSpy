window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "bspy", "modulename": "bspy", "kind": "module", "doc": "<p>BSpy is a python library for manipulating and rendering non-uniform B-splines.</p>\n\n<h6 id=\"available-subpackages\">Available subpackages</h6>\n\n<p><code>bspy.solid</code> : Provides the <code>Solid</code> and <code>Boundary</code> classes that model solids.</p>\n\n<p><code>bspy.manifold</code> : Provides the <code>Manifold</code> base class for manifolds.</p>\n\n<p><code>bspy.hyperplane</code> : Provides the <code>Hyperplane</code> subclass of <code>Manifold</code> that models hyperplanes.</p>\n\n<p><code>bspy.spline</code> : Provides the <code>Spline</code> subclass of <code>Manifold</code> that models, represents, and processes \n    piecewise polynomial tensor product functions (spline functions) as linear combinations of B-splines.</p>\n\n<p><code>bspy.spline_block</code> : Provides the <code>SplineBlock</code> class that represents and processes an array-like collection of splines.</p>\n\n<p><code>bspy.splineOpenGLFrame</code> : Provides the <code>SplineOpenGLFrame</code> class, a tkinter <code>OpenGLFrame</code> with shaders to display splines.</p>\n\n<p><code>bspy.viewer</code> : Provides the <code>Viewer</code> tkinter app (<code>tkinter.Tk</code>) that hosts a <code>SplineOpenGLFrame</code>, a listbox full of \n    splines, and a set of controls to adjust and view the selected splines. It also provides the <code>Graphics</code> engine that creates \n    an associated <code>Viewer</code>, allowing you to script splines and display them in the viewer.</p>\n"}, {"fullname": "bspy.hyperplane", "modulename": "bspy.hyperplane", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.hyperplane.Hyperplane", "modulename": "bspy.hyperplane", "qualname": "Hyperplane", "kind": "class", "doc": "<p>A hyperplane is a <code>Manifold</code> defined by a unit normal, a point on the hyperplane, and a tangent space orthogonal to the normal.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>normal</strong> (array-like):\nThe unit normal.</li>\n<li><strong>point</strong> (array-like):\nA point on the hyperplane.</li>\n<li><strong>tangentSpace</strong> (array-like):\nA array of tangents that are linearly independent and orthogonal to the normal.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The number of coordinates in the normal defines the dimension of the range of the hyperplane. The point must have the same dimension. The tangent space must be shaped: (dimension, dimension-1). \nThus the dimension of the domain is one less than that of the range.</p>\n", "bases": "bspy.manifold.Manifold"}, {"fullname": "bspy.hyperplane.Hyperplane.__init__", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">point</span>, </span><span class=\"param\"><span class=\"n\">tangentSpace</span></span>)</span>"}, {"fullname": "bspy.hyperplane.Hyperplane.maxAlignment", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.maxAlignment", "kind": "variable", "doc": "<p>If the absolute value of the dot product of two unit normals is greater than maxAlignment, the manifolds are parallel.</p>\n", "default_value": "0.9999"}, {"fullname": "bspy.hyperplane.Hyperplane.complete_slice", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.complete_slice", "kind": "function", "doc": "<p>Add any missing inherent (implicit) boundaries of this manifold's domain to the given slice of the \ngiven solid that are needed to make the slice valid and complete.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>slice</strong> (<code>Solid</code>):\nThe slice of the given solid formed by the manifold. The slice may be incomplete, missing some of the \nmanifold's inherent domain boundaries. Its dimension must match <code>self.domain_dimension()</code>.</li>\n<li><strong>solid</strong> (<code>Solid</code>):\nThe solid being sliced by the manifold. Its dimension must match <code>self.range_dimension()</code>.</li>\n</ul>\n\n<h6 id=\"parameters-2\">Parameters</h6>\n\n<ul>\n<li><strong>domain</strong> (<code>Solid</code>):\nA domain for this manifold that may be incomplete, missing some of the manifold's inherent domain boundaries. \nIts dimension must match <code>self.domain_dimension()</code>.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.slice</code>:  Slice the solid by a manifold.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Since hyperplanes have no inherent domain boundaries, this operation only tests for \npoint containment for zero-dimension hyperplanes (points).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">slice</span>, </span><span class=\"param\"><span class=\"n\">solid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.copy", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.copy", "kind": "function", "doc": "<p>Copy the hyperplane.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hyperplane</strong> (<code>Hyperplane</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.create_axis_aligned", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.create_axis_aligned", "kind": "function", "doc": "<p>Create an axis-aligned hyperplane.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):\nThe dimension of the hyperplane.</li>\n<li><strong>axis</strong> (<code>int</code>):\nThe number of the axis (0 for x, 1 for y, ...).</li>\n<li><strong>offset</strong> (<code>float</code>):\nThe offset from zero along the axis of a point on the hyperplane.</li>\n<li><strong>flipNormal</strong> (<code>bool</code>, optional):\nA Boolean indicating that the normal should point toward in the negative direction along the axis. \nDefault is False, meaning the normal points in the positive direction along the axis.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hyperplane</strong> (<code>Hyperplane</code>):\nThe axis-aligned hyperplane.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dimension</span>, </span><span class=\"param\"><span class=\"n\">axis</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">flipNormal</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.create_hypercube", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.create_hypercube", "kind": "function", "doc": "<p>Create a solid hypercube.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>bounds</strong> (array-like):\nAn array with shape (dimension, 2) of lower and upper and lower bounds for the hypercube.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hypercube</strong> (<code>Solid</code>):\nThe hypercube.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bounds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.domain_dimension", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.domain_dimension", "kind": "function", "doc": "<p>Return the domain dimension.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.evaluate", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.evaluate", "kind": "function", "doc": "<p>Return the value of the manifold (a point on the manifold).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainPoint</strong> (<code>numpy.array</code>):\nThe 1D array at which to evaluate the point.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>point</strong> (<code>numpy.array</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainPoint</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.flip_normal", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.flip_normal", "kind": "function", "doc": "<p>Flip the direction of the normal.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hyperplane</strong> (<code>Hyperplane</code>):\nThe hyperplane with flipped normal. The hyperplane retains the same tangent space.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.complement</code>:  Return the complement of the solid: whatever was inside is outside and vice-versa.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.from_dict", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.from_dict", "kind": "function", "doc": "<p>Create a <code>Hyperplane</code> from a data in a <code>dict</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dictionary</strong> (<code>dict</code>):\nThe <code>dict</code> containing <code>Hyperplane</code> data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hyperplane</strong> (<code>hyperplane</code>):</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>to_dict</code>:  Return a <code>dict</code> with <code>Hyperplane</code> data.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dictionary</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.full_domain", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.full_domain", "kind": "function", "doc": "<p>Return a solid that represents the full domain of the hyperplane.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>domain</strong> (<code>Solid</code>):\nThe full (untrimmed) domain of the hyperplane.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Boundary</code>:  A portion of the boundary of a solid.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.intersect", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.intersect", "kind": "function", "doc": "<p>Intersect two hyperplanes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Hyperplane</code>):\nThe <code>Hyperplane</code> intersecting the hyperplane.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><p><strong>intersections</strong> (<code>list</code> (or <code>NotImplemented</code> if other is not a <code>Hyperplane</code>)):\nA list of intersections between the two hyperplanes. \n(Hyperplanes will have at most one intersection, but other types of manifolds can have several.)\nEach intersection records either a crossing or a coincident region.</p>\n\n<p>For a crossing, intersection is a <code>Manifold.Crossing</code>: (left, right)</p>\n\n<ul>\n<li>left : <code>Manifold</code> in the manifold's domain where the manifold and the other cross.</li>\n<li>right : <code>Manifold</code> in the other's domain where the manifold and the other cross.</li>\n<li>Both intersection manifolds have the same domain and range (the crossing between the manifold and the other).</li>\n</ul>\n\n<p>For a coincident region, intersection is a <code>Manifold.Coincidence</code>: (left, right, alignment, transform, inverse, translation)</p>\n\n<ul>\n<li>left : <code>Solid</code> in the manifold's domain within which the manifold and the other are coincident.</li>\n<li>right : <code>Solid</code> in the other's domain within which the manifold and the other are coincident.</li>\n<li>alignment : scalar value holding the normal alignment between the manifold and the other (the dot product of their unit normals).</li>\n<li>transform : <code>numpy.array</code> holding the transform matrix from the manifold's domain to the other's domain.</li>\n<li>inverse : <code>numpy.array</code> holding the inverse transform matrix from the other's domain to the boundary's domain.</li>\n<li>translation : <code>numpy.array</code> holding the translation vector from the manifold's domain to the other's domain.</li>\n<li>Together transform, inverse, and translation form the mapping from the manifold's domain to the other's domain and vice-versa.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.slice</code>:  slice the solid by a manifold. <br />\n<code>numpy.linalg.svd</code>:  Compute the singular value decomposition of a matrix array.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Hyperplanes are parallel when their unit normals are aligned (dot product is nearly 1 or -1). Otherwise, they cross each other.</p>\n\n<p>To solve the crossing, we find the intersection by solving the underdetermined system of equations formed by assigning points \nin one hyperplane (<code>self</code>) to points in the other (<code>other</code>). That is: \n<code>self._tangentSpace * selfDomainPoint + self._point = other._tangentSpace * otherDomainPoint + other._point</code>. This system is <code>dimension</code> equations\nwith <code>2*(dimension-1)</code> unknowns (the two domain points).</p>\n\n<p>There are more unknowns than equations, so it's underdetermined. The number of free variables is <code>2*(dimension-1) - dimension = dimension-2</code>.\nTo solve the system, we rephrase it as <code>Ax = b</code>, where <code>A = (self._tangentSpace -other._tangentSpace)</code>, <code>x = (selfDomainPoint otherDomainPoint)</code>, \nand <code>b = other._point - self._point</code>. Then we take the singular value decomposition of <code>A = U * Sigma * VTranspose</code>, using <code>numpy.linalg.svd</code>.\nThe particular solution for x is given by <code>x = V * SigmaInverse * UTranspose * b</code>,\nwhere we only consider the first <code>dimension</code> number of vectors in <code>V</code> (the rest are zeroed out, i.e. the null space of <code>A</code>).\nThe null space of <code>A</code> (the last <code>dimension-2</code> vectors in <code>V</code>) spans the free variable space, so those vectors form the tangent space of the intersection.\nRemember, we're solving for <code>x = (selfDomainPoint otherDomainPoint)</code>. So, the selfDomainPoint is the first <code>dimension-1</code> coordinates of <code>x</code>,\nand the otherDomainPoint is the last <code>dimension-1</code> coordinates of <code>x</code>. Likewise for the two tangent spaces.</p>\n\n<p>For coincident regions, we need the domains, normal alignment, and mapping from the hyperplane's domain to the other's domain. (The mapping is irrelevant and excluded for dimensions less than 2.)\nWe can tell if the two hyperplanes are coincident if their normal alignment (dot product of their unit normals) is nearly 1 \nin absolute value (<code>alignment**2 &lt; Hyperplane.maxAlignment</code>) and their points are barely separated:\n<code>-2 * Manifold.minSeparation &lt; dot(hyperplane._normal, hyperplane._point - other._point) &lt; Manifold.minSeparation</code>. (We give more room \nto the outside than the inside to avoid compounding issues from minute gaps.)</p>\n\n<p>Since hyperplanes are flat, the domains of their coincident regions are the entire domain: <code>Solid(domain dimension, True)</code>.\nThe normal alignment is the dot product of the unit normals. The mapping from the hyperplane's domain to the other's domain is derived\nfrom setting the hyperplanes to each other: \n<code>hyperplane._tangentSpace * selfDomainPoint + hyperplane._point = other._tangentSpace * otherDomainPoint + other._point</code>. Then solve for\n<code>otherDomainPoint = inverse(transpose(other._tangentSpace) * other._tangentSpace)) * transpose(other._tangentSpace) * (hyperplane._tangentSpace * selfDomainPoint + hyperplane._point - other._point)</code>.\nYou get the transform is <code>inverse(transpose(other._tangentSpace) * other._tangentSpace)) * transpose(other._tangentSpace) * hyperplane._tangentSpace</code>,\nand the translation is <code>inverse(transpose(other._tangentSpace) * other._tangentSpace)) * transpose(other._tangentSpace) * (hyperplane._point - other._point)</code>.</p>\n\n<p>Note that to invert the mapping to go from the other's domain to the hyperplane's domain, you first subtract the translation and then multiply by the inverse of the transform.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.normal", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.normal", "kind": "function", "doc": "<p>Return the normal.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainPoint</strong> (<code>numpy.array</code>):\nThe 1D array at which to evaluate the normal.</li>\n<li><strong>normalize</strong> (<code>boolean</code>, optional):\nIf True the returned normal will have unit length (the default). Otherwise, the normal's length will\nbe the area of the tangent space (for two independent variables, its the length of the cross product of tangent vectors).</li>\n<li><strong>indices</strong> (<code>iterable</code>, optional):\nAn iterable of normal indices to calculate. For example, <code>indices=(0, 3)</code> will return a vector of length 2\nwith the first and fourth values of the normal. If <code>None</code>, all normal values are returned (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>normal</strong> (<code>numpy.array</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainPoint</span>, </span><span class=\"param\"><span class=\"n\">normalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.range_bounds", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.range_bounds", "kind": "function", "doc": "<p>Return the range bounds for the hyperplane.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>rangeBounds</strong> (<code>np.array</code> or <code>None</code>):\nThe range of the hyperplane given as lower and upper bounds on each dependent variable. \nIf the hyperplane has an unbounded range (domain dimension &gt; 0), <code>None</code> is returned.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.range_dimension", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.range_dimension", "kind": "function", "doc": "<p>Return the range dimension.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.tangent_space", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.tangent_space", "kind": "function", "doc": "<p>Return the tangent space.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainPoint</strong> (<code>numpy.array</code>):\nThe 1D array at which to evaluate the tangent space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tangentSpace</strong> (<code>numpy.array</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainPoint</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.to_dict", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.to_dict", "kind": "function", "doc": "<p>Return a <code>dict</code> with <code>Hyperplane</code> data.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dictionary</strong> (<code>dict</code>):</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>from_dict</code>:  Create a <code>Hyperplane</code> from a data in a <code>dict</code>.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.transform", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.transform", "kind": "function", "doc": "<p>Transform the range of the hyperplane.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>matrix</strong> (<code>numpy.array</code>):\nA square matrix transformation.</li>\n<li><strong>matrixInverseTranspose</strong> (<code>numpy.array</code>, optional):\nThe inverse transpose of matrix (computed if not provided).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hyperplane</strong> (<code>Hyperplane</code>):\nThe transformed hyperplane.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.transform</code>:  Transform the range of the solid.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">matrixInverseTranspose</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.translate", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.translate", "kind": "function", "doc": "<p>translate the range of the hyperplane.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>delta</strong> (<code>numpy.array</code>):\nA 1D array translation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hyperplane</strong> (<code>Hyperplane</code>):\nThe translated hyperplane.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.translate</code>:  translate the range of the solid.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">delta</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.hyperplane.Hyperplane.trimmed_range_bounds", "modulename": "bspy.hyperplane", "qualname": "Hyperplane.trimmed_range_bounds", "kind": "function", "doc": "<p>Return the trimmed range bounds for the hyperplane.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainBounds</strong> (array-like or <code>None</code>):\nAn array with shape (domain_dimension, 2) of lower and upper and lower bounds on each hyperplane parameter. \nIf domainBounds is <code>None</code> then the hyperplane is unbounded.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>trimmedManifold, rangeBounds</strong> (<code>Hyperplane</code>, <code>np.array</code> (or None)):\nA manifold trimmed to the given domain bounds, and the range of the trimmed hyperplane given as \nlower and upper bounds on each dependent variable. If the domain bounds are <code>None</code> (meaning unbounded) \nthen rangeBounds is <code>None</code>.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The returned trimmed manifold is the original hyperplane (no changes).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainBounds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold", "modulename": "bspy.manifold", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.manifold.Manifold", "modulename": "bspy.manifold", "qualname": "Manifold", "kind": "class", "doc": "<p>A manifold is an abstract base class for differentiable functions with\nnormals and tangent spaces whose range is one dimension higher than their domain.</p>\n"}, {"fullname": "bspy.manifold.Manifold.minSeparation", "modulename": "bspy.manifold", "qualname": "Manifold.minSeparation", "kind": "variable", "doc": "<p>If two points are within minSeparation of each each other, they are coincident.</p>\n", "default_value": "0.0001"}, {"fullname": "bspy.manifold.Manifold.Crossing", "modulename": "bspy.manifold", "qualname": "Manifold.Crossing", "kind": "class", "doc": "<p>Crossing(left, right)</p>\n", "bases": "builtins.tuple"}, {"fullname": "bspy.manifold.Manifold.Coincidence", "modulename": "bspy.manifold", "qualname": "Manifold.Coincidence", "kind": "class", "doc": "<p>Return type for intersect.</p>\n", "bases": "builtins.tuple"}, {"fullname": "bspy.manifold.Manifold.factory", "modulename": "bspy.manifold", "qualname": "Manifold.factory", "kind": "variable", "doc": "<p>Factory dictionary for creating manifolds.</p>\n", "default_value": "{&#x27;Hyperplane&#x27;: &lt;class &#x27;bspy.hyperplane.Hyperplane&#x27;&gt;, &#x27;Spline&#x27;: &lt;class &#x27;bspy.spline.Spline&#x27;&gt;}"}, {"fullname": "bspy.manifold.Manifold.cached_intersect", "modulename": "bspy.manifold", "qualname": "Manifold.cached_intersect", "kind": "function", "doc": "<p>Intersect two manifolds, caching the result for twins (same intersection but swapping self and other).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Manifold</code>):\nThe <code>Manifold</code> intersecting the manifold.</li>\n<li><strong>cache</strong> (<code>dict</code>, optional):\nA dictionary to cache <code>Manifold</code> intersections, speeding computation. The default is <code>None</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><p><strong>intersections</strong> (<code>list</code> (or <code>NotImplemented</code> if other is an unknown type of Manifold)):\nA list of intersections between the two manifolds. \nEach intersection records either a crossing or a coincident region.</p>\n\n<p>For a crossing, intersection is a Manifold.Crossing: (left, right)</p>\n\n<ul>\n<li>left : <code>Manifold</code> in the manifold's domain where the manifold and the other cross.</li>\n<li>right : <code>Manifold</code> in the other's domain where the manifold and the other cross.</li>\n<li>Both intersection manifolds have the same domain and range (the crossing between the manifold and the other).</li>\n</ul>\n\n<p>For a coincident region, intersection is Manifold.Coincidence: (left, right, alignment, transform, inverse, translation)</p>\n\n<ul>\n<li>left : <code>Solid</code> in the manifold's domain within which the manifold and the other are coincident.</li>\n<li>right : <code>Solid</code> in the other's domain within which the manifold and the other are coincident.</li>\n<li>alignment : scalar value holding the normal alignment between the manifold and the other (the dot product of their unit normals).</li>\n<li>transform : <code>numpy.array</code> holding the matrix transform from the boundary's domain to the other's domain.</li>\n<li>inverse : <code>numpy.array</code> holding the matrix inverse transform from the other's domain to the boundary's domain.</li>\n<li>translation : <code>numpy.array</code> holding the 1D translation from the manifold's domain to the other's domain.</li>\n<li>Together transform, inverse, and translation form the mapping from the manifold's domain to the other's domain and vice-versa.</li>\n</ul></li>\n<li><strong>isTwin</strong> (<code>bool</code>):\nTrue if this intersection is the twin from the cache (the intersection with self and other swapped).</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>intersect</code>:  Intersect two manifolds. <br />\n<code>Solid.slice</code>:  slice the solid by a manifold.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>To invert the mapping to go from the other's domain to the manifold's domain, you first subtract the translation and then multiply by the inverse of the transform.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.complete_slice", "modulename": "bspy.manifold", "qualname": "Manifold.complete_slice", "kind": "function", "doc": "<p>Add any missing inherent (implicit) boundaries of this manifold's domain to the given slice of the \ngiven solid that are needed to make the slice valid and complete.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>slice</strong> (<code>Solid</code>):\nThe slice of the given solid formed by the manifold. The slice may be incomplete, missing some of the \nmanifold's inherent domain boundaries. Its dimension must match <code>self.domain_dimension()</code>.</li>\n<li><strong>solid</strong> (<code>Solid</code>):\nThe solid being sliced by the manifold. Its dimension must match <code>self.range_dimension()</code>.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.slice</code>:  Slice the solid by a manifold.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>For manifolds without inherent domain boundaries (like hyperplanes), the operation does nothing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">slice</span>, </span><span class=\"param\"><span class=\"n\">solid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.copy", "modulename": "bspy.manifold", "qualname": "Manifold.copy", "kind": "function", "doc": "<p>Copy the manifold.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>manifold</strong> (<code>Manifold</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.domain_dimension", "modulename": "bspy.manifold", "qualname": "Manifold.domain_dimension", "kind": "function", "doc": "<p>Return the domain dimension.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.evaluate", "modulename": "bspy.manifold", "qualname": "Manifold.evaluate", "kind": "function", "doc": "<p>Return the value of the manifold (a point on the manifold).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainPoint</strong> (<code>numpy.array</code>):\nThe 1D array at which to evaluate the point.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>point</strong> (<code>numpy.array</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainPoint</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.flip_normal", "modulename": "bspy.manifold", "qualname": "Manifold.flip_normal", "kind": "function", "doc": "<p>Flip the direction of the normal.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>manifold</strong> (<code>Manifold</code>):\nThe manifold with flipped normal. The manifold retains the same tangent space.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.complement</code>:  Return the complement of the solid: whatever was inside is outside and vice-versa.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.from_dict", "modulename": "bspy.manifold", "qualname": "Manifold.from_dict", "kind": "function", "doc": "<p>Create a <code>Manifold</code> from a data in a <code>dict</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dictionary</strong> (<code>dict</code>):\nThe <code>dict</code> containing <code>Manifold</code> data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>manifold</strong> (<code>Manifold</code>):</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>to_dict</code>:  Return a <code>dict</code> with <code>Manifold</code> data.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dictionary</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.full_domain", "modulename": "bspy.manifold", "qualname": "Manifold.full_domain", "kind": "function", "doc": "<p>Return a solid that represents the full domain of the manifold.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>domain</strong> (<code>Solid</code>):\nThe full (untrimmed) domain of the manifold.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Boundary</code>:  A portion of the boundary of a solid.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.intersect", "modulename": "bspy.manifold", "qualname": "Manifold.intersect", "kind": "function", "doc": "<p>Intersect two manifolds (self and other).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Manifold</code>):\nThe <code>Manifold</code> intersecting self.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><p><strong>intersections</strong> (<code>list</code> (or <code>NotImplemented</code> if other is an unknown type of Manifold)):\nA list of intersections between the two manifolds. \nEach intersection records either a crossing or a coincident region.</p>\n\n<p>For a crossing, intersection is a <code>Manifold.Crossing</code>: (left, right)</p>\n\n<ul>\n<li>left : <code>Manifold</code> in the manifold's domain where the manifold and the other cross.</li>\n<li>right : <code>Manifold</code> in the other's domain where the manifold and the other cross.</li>\n<li>Both intersection manifolds have the same domain and range (the crossing between the manifold and the other).</li>\n</ul>\n\n<p>For a coincident region, intersection is a <code>Manifold.Coincidence</code>: (left, right, alignment, transform, inverse, translation)</p>\n\n<ul>\n<li>left : <code>Solid</code> in the manifold's domain within which the manifold and the other are coincident.</li>\n<li>right : <code>Solid</code> in the other's domain within which the manifold and the other are coincident.</li>\n<li>alignment : scalar value holding the normal alignment between the manifold and the other (the dot product of their unit normals).</li>\n<li>transform : <code>numpy.array</code> holding the transform matrix from the manifold's domain to the other's domain.</li>\n<li>inverse : <code>numpy.array</code> holding the inverse transform matrix from the other's domain to the boundary's domain.</li>\n<li>translation : <code>numpy.array</code> holding the translation vector from the manifold's domain to the other's domain.</li>\n<li>Together transform, inverse, and translation form the mapping from the manifold's domain to the other's domain and vice-versa.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>cached_intersect</code>:  Intersect two manifolds, caching the result for twins (same intersection but swapping self and other). <br />\n<code>Solid.slice</code>:  slice the solid by a manifold.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>To invert the mapping to go from the other's domain to the manifold's domain, you first subtract the translation and then multiply by the inverse of the transform.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.normal", "modulename": "bspy.manifold", "qualname": "Manifold.normal", "kind": "function", "doc": "<p>Return the normal.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainPoint</strong> (<code>numpy.array</code>):\nThe 1D array at which to evaluate the normal.</li>\n<li><strong>normalize</strong> (<code>boolean</code>, optional):\nIf True the returned normal will have unit length (the default). Otherwise, the normal's length will\nbe the area of the tangent space (for two independent variables, its the length of the cross product of tangent vectors).</li>\n<li><strong>indices</strong> (<code>iterable</code>, optional):\nAn iterable of normal indices to calculate. For example, <code>indices=(0, 3)</code> will return a vector of length 2\nwith the first and fourth values of the normal. If <code>None</code>, all normal values are returned (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>normal</strong> (<code>numpy.array</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainPoint</span>, </span><span class=\"param\"><span class=\"n\">normalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.range_bounds", "modulename": "bspy.manifold", "qualname": "Manifold.range_bounds", "kind": "function", "doc": "<p>Return the range bounds for the manifold.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>rangeBounds</strong> (<code>np.array</code> or <code>None</code>):\nThe range of the manifold given as lower and upper bounds on each dependent variable. \nIf the manifold has an unbounded range, <code>None</code> is returned.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.range_dimension", "modulename": "bspy.manifold", "qualname": "Manifold.range_dimension", "kind": "function", "doc": "<p>Return the range dimension.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.register", "modulename": "bspy.manifold", "qualname": "Manifold.register", "kind": "function", "doc": "<p>Class decorator for subclasses of <code>Manifold</code> that registers the subclass with the <code>Manifold</code> factory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">manifold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.tangent_space", "modulename": "bspy.manifold", "qualname": "Manifold.tangent_space", "kind": "function", "doc": "<p>Return the tangent space.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainPoint</strong> (<code>numpy.array</code>):\nThe 1D array at which to evaluate the tangent space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tangentSpace</strong> (<code>numpy.array</code>):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainPoint</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.to_dict", "modulename": "bspy.manifold", "qualname": "Manifold.to_dict", "kind": "function", "doc": "<p>Return a <code>dict</code> with <code>Manifold</code> data.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dictionary</strong> (<code>dict</code>):</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>from_dict</code>:  Create a <code>Manifold</code> from a data in a <code>dict</code>.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.transform", "modulename": "bspy.manifold", "qualname": "Manifold.transform", "kind": "function", "doc": "<p>Transform the range of the manifold.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>matrix</strong> (<code>numpy.array</code>):\nA square matrix transformation.</li>\n<li><strong>matrixInverseTranspose</strong> (<code>numpy.array</code>, optional):\nThe inverse transpose of matrix (computed if not provided).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>manifold</strong> (<code>Manifold</code>):\nThe transformed manifold.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.transform</code>:  transform the range of the solid.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">matrixInverseTranspose</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.translate", "modulename": "bspy.manifold", "qualname": "Manifold.translate", "kind": "function", "doc": "<p>Translate the range of the manifold.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>delta</strong> (<code>numpy.array</code>):\nA 1D array translation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>manifold</strong> (<code>Manifold</code>):\nThe translated manifold.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.translate</code>:  translate the range of the solid.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">delta</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.manifold.Manifold.trimmed_range_bounds", "modulename": "bspy.manifold", "qualname": "Manifold.trimmed_range_bounds", "kind": "function", "doc": "<p>Return the trimmed range bounds for the manifold.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainBounds</strong> (array-like):\nAn array with shape (domain_dimension, 2) of lower and upper and lower bounds on each manifold parameter.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>trimmedManifold, rangeBounds</strong> (<code>Manifold</code>, <code>np.array</code>):\nA manifold trimmed to the given domain bounds, and the range of the trimmed manifold given as \nlower and upper bounds on each dependent variable.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The returned trimmed manifold may be the original manifold, depending on the subclass of manifold.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainBounds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid", "modulename": "bspy.solid", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.solid.Boundary", "modulename": "bspy.solid", "qualname": "Boundary", "kind": "class", "doc": "<p>A portion of the boundary of a solid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>manifold</strong> (<code>Manifold</code>):\nThe differentiable function whose range is one dimension higher than its domain that defines the range of the boundary.</li>\n<li><strong>domain</strong> (<code>Solid</code>, optional):\nThe region of the domain of the manifold that's within the boundary. The default is the full domain of the manifold.</li>\n</ul>\n\n<h6 id=\"see-also\">See also</h6>\n\n<p><code>Solid</code> : A region that separates space into an inside and outside, defined by a collection of boundaries.\n<code>Manifold.full_domain</code> : Return a solid that represents the full domain of the manifold.</p>\n"}, {"fullname": "bspy.solid.Boundary.__init__", "modulename": "bspy.solid", "qualname": "Boundary.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">manifold</span>, </span><span class=\"param\"><span class=\"n\">domain</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "bspy.solid.Boundary.domain", "modulename": "bspy.solid", "qualname": "Boundary.domain", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.solid.Boundary.any_point", "modulename": "bspy.solid", "qualname": "Boundary.any_point", "kind": "function", "doc": "<p>Return an arbitrary point on the boundary.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>point</strong> (<code>numpy.array</code>):\nA point on the boundary.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Solid.any_point</code>:  Return an arbitrary point on the solid.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The point is computed by evaluating the boundary manifold by an arbitrary point in the domain of the boundary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid", "modulename": "bspy.solid", "qualname": "Solid", "kind": "class", "doc": "<p>A region that separates space into an inside and outside, defined by a collection of boundaries.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):\nThe dimension of the solid (non-negative).</li>\n<li><strong>containsInfinity</strong> (<code>bool</code>):\nIndicates whether or not the solid contains infinity.</li>\n</ul>\n\n<h6 id=\"see-also\">See also</h6>\n\n<p><code>Boundary</code> : A portion of the boundary of a solid.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Solids also contain a <code>list</code> of <code>boundaries</code>. That list may be empty.</p>\n\n<p>Solids can be of zero dimension, typically acting as the domain of boundary endpoints. Zero-dimension solids have no boundaries, they only contain infinity or not.</p>\n"}, {"fullname": "bspy.solid.Solid.__init__", "modulename": "bspy.solid", "qualname": "Solid.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dimension</span>, </span><span class=\"param\"><span class=\"n\">containsInfinity</span></span>)</span>"}, {"fullname": "bspy.solid.Solid.dimension", "modulename": "bspy.solid", "qualname": "Solid.dimension", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.solid.Solid.containsInfinity", "modulename": "bspy.solid", "qualname": "Solid.containsInfinity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.solid.Solid.boundaries", "modulename": "bspy.solid", "qualname": "Solid.boundaries", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.solid.Solid.bounds", "modulename": "bspy.solid", "qualname": "Solid.bounds", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.solid.Solid.add_boundary", "modulename": "bspy.solid", "qualname": "Solid.add_boundary", "kind": "function", "doc": "<p>Adds a boundary to a solid, recomputing the solid's bounds.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>boundary</strong> (<code>Boundary</code>):\nA boundary to add to the solid.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>While you could just append the boundary to the solid's collection of boundaries, \nthis method also recomputes the solid's bounds for faster intersection and containment operations. \nAdding the boundary directly to the solid's boundaries collection may result in faulty operations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">boundary</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.any_point", "modulename": "bspy.solid", "qualname": "Solid.any_point", "kind": "function", "doc": "<p>Return an arbitrary point on the solid.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>point</strong> (<code>numpy.array</code>):\nA point on the solid.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Boundary.any_point</code>:  Return an arbitrary point on the boundary.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The point is computed by calling <code>Boundary.any_point</code> on the solid's first boundary.\nIf the solid has no boundaries but contains infinity, <code>any_point</code> returns the origin.\nIf the solid has no boundaries and doesn't contain infinity, <code>any_point</code> returns <code>None</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.complement", "modulename": "bspy.solid", "qualname": "Solid.complement", "kind": "function", "doc": "<p>Return the complement of the solid: whatever was inside is outside and vice-versa.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>solid</strong> (<code>Solid</code>):\nThe complement of the solid.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>intersection</code>:  Intersect two solids. <br />\n<code>union</code>:  Union two solids. <br />\n<code>difference</code>:  Subtract one solid from another.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.contains_point", "modulename": "bspy.solid", "qualname": "Solid.contains_point", "kind": "function", "doc": "<p>Test if a point lies within the solid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>point</strong> (array-like):\nA point that may lie within the solid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>containment</strong> (<code>bool</code>):\n<code>True</code> if <code>point</code> lies within the solid. <code>False</code> otherwise.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>winding_number</code>:  Compute the winding number for a point relative to the solid.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>A point is considered contained if it's on the boundary of the solid or it's winding number is greater than 0.5.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.difference", "modulename": "bspy.solid", "qualname": "Solid.difference", "kind": "function", "doc": "<p>Subtract one solid from another.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Solid</code>):\nThe <code>Solid</code> subtracted from self.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>combinedSolid</strong> (<code>Solid</code>):\nA <code>Solid</code> that represents the subtraction of other from self.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>intersection</code>:  Intersect two solids. <br />\n<code>union</code>:  Union two solids.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.disjoint_bounds", "modulename": "bspy.solid", "qualname": "Solid.disjoint_bounds", "kind": "function", "doc": "<p>Returns whether or not bounds1 and bounds2 are disjoint.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>bounds1</strong> (array-like or <code>None</code>):\nAn array with shape (dimension, 2) of lower and upper and lower bounds on each dimension. \nIf bounds1 is <code>None</code> then then there are no bounds.</li>\n<li><strong>bounds2</strong> (array-like or <code>None</code>):\nAn array with shape (dimension, 2) of lower and upper and lower bounds on each dimension. \nIf bounds2 is <code>None</code> then then there are no bounds.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>disjoint</strong> (<code>bool</code>):\nValue is true if the bounds are disjoint. Value is false if either bounds is <code>None</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bounds1</span>, </span><span class=\"param\"><span class=\"n\">bounds2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.intersection", "modulename": "bspy.solid", "qualname": "Solid.intersection", "kind": "function", "doc": "<p>Intersect two solids.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Solid</code>):\nThe <code>Solid</code> intersecting self.</li>\n<li><strong>cache</strong> (<code>dict</code>, optional):\nA dictionary to cache <code>Manifold</code> intersections, speeding computation. If no dictionary is passed, one is created.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>combinedSolid</strong> (<code>Solid</code>):\nA <code>Solid</code> that represents the intersection between self and other.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>slice</code>:  Slice a solid by a manifold. <br />\n<code>union</code>:  Union two solids. <br />\n<code>difference</code>:  Subtract one solid from another.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>To intersect two solids, we slice each solid with the boundaries of the other solid. The slices are the region\nof the domain that intersect the solid. We then intersect the domain of each boundary with its slice of the other solid. Thus,\nthe intersection of two solids becomes a set of intersections within the domains of their boundaries. This recursion continues\nuntil we are intersecting points whose domains have no boundaries.</p>\n\n<p>The only subtlety is when two boundaries are coincident. To avoid overlapping the coincident region, we keep that region\nfor one slice and trim it away for the other. We use a manifold intersection cache to keep track of these pairs, as well as to reduce computation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.is_empty", "modulename": "bspy.solid", "qualname": "Solid.is_empty", "kind": "function", "doc": "<p>Test if the solid is empty.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>isEmpty</strong> (<code>bool</code>):\n<code>True</code> if the solid is empty, <code>False</code> otherwise.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Casting the solid to <code>bool</code> returns not <code>is_empty</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.load", "modulename": "bspy.solid", "qualname": "Solid.load", "kind": "function", "doc": "<p>Load solids and/or manifolds in json format from the specified filename (full path).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fileName</strong> (<code>string</code>):\nThe full path to the file containing the solids and/or manifolds. Can be a relative path.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>solidsAndManifolds</strong> (list of <code>Solid</code> and/or <code>Manifold</code>):\nThe loaded solids and/or manifolds.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>save</code>:  Save a solids and/or manifolds in json format to the specified filename (full path).  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fileName</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.point_outside_bounds", "modulename": "bspy.solid", "qualname": "Solid.point_outside_bounds", "kind": "function", "doc": "<p>Returns whether or not point is outside bounds.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>point</strong> (array-like):\nA point whose dimension matches the bounds.</li>\n<li><strong>bounds</strong> (array-like or <code>None</code>):\nAn array with shape (dimension, 2) of lower and upper and lower bounds on each dimension. \nIf bounds is <code>None</code> then then there are no bounds.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>within</strong> (<code>bool</code>):\nValue is true if the point is outside bounds or bounds is <code>None</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span>, </span><span class=\"param\"><span class=\"n\">bounds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.save", "modulename": "bspy.solid", "qualname": "Solid.save", "kind": "function", "doc": "<p>Save a solids and/or manifolds in json format to the specified filename (full path).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fileName</strong> (<code>string</code>):\nThe full path to the file containing the solids and/or manifolds. Can be a relative path.</li>\n<li><strong>*solids_or_manifolds</strong> (<code>Solid</code> or <code>Manifold</code>):\nSolids and/or manifolds to save in the same file.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>load</code>:  Load solids and/or manifolds in json format from the specified filename (full path).  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fileName</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">solids_or_manifolds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.slice", "modulename": "bspy.solid", "qualname": "Solid.slice", "kind": "function", "doc": "<p>Slice the solid by a manifold.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>manifold</strong> (<code>Manifold</code>):\nThe <code>Manifold</code> used to slice the solid.</li>\n<li><strong>cache</strong> (<code>dict</code>, optional):\nA dictionary to cache <code>Manifold</code> intersections, speeding computation.</li>\n<li><strong>trimTwin : <code>bool</code>, default</strong> (False):\nTrim coincident boundary twins on subsequent calls to slice (avoids duplication of overlapping regions).\nTrimming twins is typically only used in conjunction with <code>intersection</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>slice</strong> (<code>Solid</code>):\nA region in the domain of <code>manifold</code> that intersects with the solid. The region may contain infinity.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>intersection</code>:  Intersect two solids. <br />\n<code>Manifold.intersect</code>:  Intersect two manifolds. <br />\n<code>Manifold.cached_intersect</code>:  Intersect two manifolds, caching the result for twins. <br />\n<code>Manifold.complete_slice</code>:  Add any missing inherent (implicit) boundaries of this manifold's domain to the given slice.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The dimension of the slice is always one less than the dimension of the solid, since the slice is a region in the domain of the manifold slicing the solid.</p>\n\n<p>To compute the slice of a manifold intersecting the solid, we intersect the manifold with each boundary of the solid. There may be multiple intersections \nbetween the manifold and the boundary. Each is either a crossing or a coincident region.</p>\n\n<p>Crossings result in two intersection manifolds: one in the domain of the manifold and one in the domain of the boundary. By construction, both intersection manifolds have the\nsame domain and the same range of the manifold and boundary (the crossing itself). The intersection manifold in the domain of the manifold becomes a boundary of the slice,\nbut we must determine the intersection's domain. For that, we slice the boundary's intersection manifold with the boundary's domain. This recursion continues \nuntil the slice is just a point with no domain.</p>\n\n<p>Coincident regions appear in the domains of the manifold and the boundary. We intersect the boundary's coincident region with the domain of the boundary and then map\nit to the domain of the manifold. If the coincident regions have normals in opposite directions, they cancel each other out, so we subtract them from the slice by\ninverting the region and intersecting it with the slice. We use this same technique for removing overlapping coincident regions. If the coincident regions have normals\nin the same direction, we union them with the slice.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">manifold</span>, </span><span class=\"param\"><span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">trimTwin</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.surface_integral", "modulename": "bspy.solid", "qualname": "Solid.surface_integral", "kind": "function", "doc": "<p>Compute the surface integral of a vector field on the boundary of the solid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li>**f : python function <code>f(point: numpy.array, normal: numpy.array, args** (user-defined) -&gt; numpy.array</code>):\nThe vector field to be integrated on the boundary of the solid.\nIt's passed a point on the boundary and its corresponding outward-pointing unit normal, as well as any optional user-defined arguments.</li>\n<li><strong>args</strong> (tuple, optional):\nExtra arguments to pass to <code>f</code>.</li>\n<li><strong>*quadArgs</strong> (Quadrature arguments passed to <code>scipy.integrate.quad</code>.):</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>sum</strong> (scalar value):\nThe value of the surface integral.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>volume_integral</code>:  Compute the volume integral of a function within the solid. <br />\n<code>scipy.integrate.quad</code>:  Integrate func from a to b (possibly infinite interval) using a technique from the Fortran library QUADPACK.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>To compute the surface integral of a scalar function on the boundary, have <code>f</code> return the product of the <code>normal</code> times the scalar function for the <code>point</code>.</p>\n\n<p><code>surface_integral</code> sums the <code>volume_integral</code> over the domain of the solid's boundaries, using the integrand: <code>numpy.dot(f(point, normal), normal)</code>, \nwhere <code>normal</code> is the cross-product of the boundary tangents (the normal before normalization).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">epsabs</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">epsrel</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">quadArgs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.transform", "modulename": "bspy.solid", "qualname": "Solid.transform", "kind": "function", "doc": "<p>Transform the range of the solid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>matrix</strong> (<code>numpy.array</code>):\nA square matrix transformation.</li>\n<li><strong>matrixInverseTranspose</strong> (<code>numpy.array</code>, optional):\nThe inverse transpose of matrix (computed if not provided).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>solid</strong> (<code>Solid</code>):\nThe transformed solid.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">matrixInverseTranspose</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.translate", "modulename": "bspy.solid", "qualname": "Solid.translate", "kind": "function", "doc": "<p>Translate the range of the solid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>delta</strong> (<code>numpy.array</code>):\nA 1D array translation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>solid</strong> (<code>Solid</code>):\nThe translated solid.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">delta</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.union", "modulename": "bspy.solid", "qualname": "Solid.union", "kind": "function", "doc": "<p>Union two solids.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Solid</code>):\nThe <code>Solid</code> unioning self.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>combinedSolid</strong> (<code>Solid</code>):\nA <code>Solid</code> that represents the union between self and other.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>intersection</code>:  Intersect two solids. <br />\n<code>difference</code>:  Subtract one solid from another.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.volume_integral", "modulename": "bspy.solid", "qualname": "Solid.volume_integral", "kind": "function", "doc": "<p>Compute the volume integral of a function within the solid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li>**f : python function <code>f(point: numpy.array, args** (user-defined) -&gt; scalar value</code>):\nThe function to be integrated within the solid.\nIt's passed a point within the solid, as well as any optional user-defined arguments.</li>\n<li><strong>args</strong> (tuple, optional):\nExtra arguments to pass to <code>f</code>.</li>\n<li><strong>*quadArgs</strong> (Quadrature arguments passed to <code>scipy.integrate.quad</code>.):</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>sum</strong> (scalar value):\nThe value of the volume integral.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>surface_integral</code>:  Compute the surface integral of a vector field on the boundary of the solid. <br />\n<code>scipy.integrate.quad</code>:  Integrate func from a to b (possibly infinite interval) using a technique from the Fortran library QUADPACK.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The volume integral is computed by recursive application of the divergence theorem: <code>volume_integral(divergence(F)) = surface_integral(dot(F, n))</code>, \nwhere <code>F</code> is a vector field and <code>n</code> is the outward boundary unit normal.</p>\n\n<p>Let <code>F = [Integral(f) from x0 to x holding other coordinates fixed, 0..0]</code>. <code>divergence(F) = f</code> by construction, and <code>dot(F, n) = Integral(f) * n[0]</code>.\nNote that the choice of <code>x0</code> is arbitrary as long as it's in the domain of f and doesn't change across all surface integral boundaries.</p>\n\n<p>Thus, we have <code>volume_integral(f) = surface_integral(Integral(f) * n[0])</code>.\nThe outward boundary unit normal, <code>n</code>, is the cross product of the boundary manifold's tangent space divided by its length.\nThe surface differential, <code>dS</code>, is the length of cross product of the boundary manifold's tangent space times the differentials of the manifold's domain variables.\nThe length of the cross product appears in the numerator and denominator of the surface integral and cancels.\nWhat's left multiplying <code>Integral(f)</code> is the first coordinate of the cross product plus the domain differentials (volume integral).\nThe first coordinate of the cross product of the boundary manifold's tangent space is the first cofactor of the tangent space.\nAnd so, <code>surface_integral(Integral(f) * n[0]) = volume_integral(Integral(f) * first cofactor)</code> over each boundary manifold's domain.</p>\n\n<p>So, we have <code>volume_integral(f) = volume_integral(Integral(f) * first cofactor)</code> over each boundary manifold's domain.\nTo compute the volume integral we sum <code>volume_integral</code> over the domain of the solid's boundaries, using the integrand:\n<code>scipy.integrate.quad(f, x0, x [other coordinates fixed]) * first cofactor</code>.\nThis recursion continues until the boundaries are only points, where we can just sum the integrand.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">epsabs</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">epsrel</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">quadArgs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.solid.Solid.winding_number", "modulename": "bspy.solid", "qualname": "Solid.winding_number", "kind": "function", "doc": "<p>Compute the winding number for a point relative to the solid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>point</strong> (array-like):\nA point that may lie within the solid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>windingNumber</strong> (scalar value):\nThe <code>windingNumber</code> is 0 if the point is outside the solid, 1 if it's inside.\nOther values indicate issues:\n<ul>\n<li>A point on the boundary leads to an undefined (random) winding number;</li>\n<li>Boundaries with gaps or overlaps lead to fractional winding numbers;</li>\n<li>Interior-pointing normals lead to negative winding numbers;</li>\n<li>Nested shells lead to winding numbers with absolute value 2 or greater.</li>\n</ul></li>\n<li><strong>onBoundaryNormal</strong> (<code>numpy.array</code>):\nThe boundary normal if the point lies on a boundary, <code>None</code> otherwise.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>contains_point</code>:  Test if a point lies within the solid.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>If <code>onBoundaryNormal</code> is not <code>None</code>, <code>windingNumber</code> is undefined and should be ignored.</p>\n\n<p><code>winding_number</code> uses two different implementations:</p>\n\n<ul>\n<li>A simple fast implementation if the solid is a number line (dimension &lt;= 1). This is the default for dimension &lt;= 1.</li>\n<li>A surface integral with integrand: <code>(x - point) / norm(x - point)**dimension</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">point</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline", "modulename": "bspy.spline", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline", "modulename": "bspy.spline", "qualname": "Spline", "kind": "class", "doc": "<p>A class to model, represent, and process piecewise polynomial tensor product\nfunctions (splines) as linear combinations of B-splines. </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>nInd</strong> (<code>int</code>):\nThe number of independent variables of the spline.</li>\n<li><strong>nDep</strong> (<code>int</code>):\nThe number of dependent variables of the spline.</li>\n<li><strong>order</strong> (<code>tuple</code>):\nA tuple of length nInd where each integer entry represents the\npolynomial order of the spline in that variable.</li>\n<li><strong>nCoef</strong> (<code>tuple</code>):\nA tuple of length nInd where each integer entry represents the\ndimension (i.e. number of B-spline coefficients) of the spline\nin that variable.</li>\n<li><strong>knots</strong> (<code>list</code>):\nA list of the lists of the knots of the spline in each independent variable.</li>\n<li><strong>coefs</strong> (array-like):\nA list of the B-spline coefficients of the spline.</li>\n<li><strong>metadata</strong> (<code>dict</code>, optional):\nA dictionary of ancillary data to store with the spline. Default is {}.</li>\n</ul>\n", "bases": "bspy.manifold.Manifold"}, {"fullname": "bspy.spline.Spline.__init__", "modulename": "bspy.spline", "qualname": "Spline.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">nInd</span>, </span><span class=\"param\"><span class=\"n\">nDep</span>, </span><span class=\"param\"><span class=\"n\">order</span>, </span><span class=\"param\"><span class=\"n\">nCoef</span>, </span><span class=\"param\"><span class=\"n\">knots</span>, </span><span class=\"param\"><span class=\"n\">coefs</span>, </span><span class=\"param\"><span class=\"n\">metadata</span><span class=\"o\">=</span><span class=\"p\">{}</span></span>)</span>"}, {"fullname": "bspy.spline.Spline.nInd", "modulename": "bspy.spline", "qualname": "Spline.nInd", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline.nDep", "modulename": "bspy.spline", "qualname": "Spline.nDep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline.order", "modulename": "bspy.spline", "qualname": "Spline.order", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline.nCoef", "modulename": "bspy.spline", "qualname": "Spline.nCoef", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline.knots", "modulename": "bspy.spline", "qualname": "Spline.knots", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline.coefs", "modulename": "bspy.spline", "qualname": "Spline.coefs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline.metadata", "modulename": "bspy.spline", "qualname": "Spline.metadata", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline.add", "modulename": "bspy.spline", "qualname": "Spline.add", "kind": "function", "doc": "<p>Add two splines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Spline</code>):\nThe spline to add to self. The number of dependent variables must match self.</li>\n<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):\nAn iterable of indices or pairs of indices. Each index refers to an independent variable.\nWithin the iterable, a single index, <code>n</code>, maps the nth independent variable of self to the same independent variable of other.\nA pair <code>(n, m)</code> maps the nth independent variable of self to the mth independent variable of other. \nFor example, if you wanted to compute <code>self(u, v, w) + other(u, w)</code>, you'd pass <code>[0, (2, 1)]</code> for <code>indMap</code>. \nUnmapped independent variables remain independent (the default).\nThe domains of mapped independent variables must match. \nAn independent variable can map to no more than one other independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe result of adding self and other.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>subtract</code>:  Subtract two splines. <br />\n<code>multiply</code>:  Multiply two splines. <br />\n<code>common_basis</code>:  Align a collection of splines to a common basis, elevating the order and adding knots as needed.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline1 + spline2 with indMap = range(min(spline1.nInd, spline2.nInd)).</p>\n\n<p>Uses <code>common_basis</code> to ensure mapped variables share the same order and knots.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">indMap</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.bspline_values", "modulename": "bspy.spline", "qualname": "Spline.bspline_values", "kind": "function", "doc": "<p>Compute bspline values or their derivatives for a 1D bspline segment given the rightmost knot of the segment and a parameter value within that segment.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>knot</strong> (<code>int</code>):\nThe rightmost knot in the bspline segment.  If knot is None, then this value is\ndetermined by binary search</li>\n<li><strong>knots</strong> (array-like):\nThe array of knots for the bspline.</li>\n<li><strong>splineOrder</strong> (<code>int</code>):\nThe order of the bspline.</li>\n<li><strong>u</strong> (<code>float</code>):\nThe parameter value within the segment at which to evaluate it.</li>\n<li><strong>derivativeOrder</strong> (<code>int</code>, optional):\nThe order of the derivative. A zero-order derivative (default) just evaluates the bspline normally.</li>\n<li><strong>taylorCoefs</strong> (<code>boolean</code>, optional):\nA boolean flag that if true returns the derivatives divided by their degree factorial, that is \nthe taylor coefficients at the given parameter values. Default is false.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>knot</strong> (<code>int</code>):\nThe rightmost knot in the bspline segment.  If this is specified on input, then this\nvalued is returned.  Otherwise, it is computed and then returned.</li>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the bspline or its derivative at the given parameter.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>evaluate</code>:  Compute the value of the spline at given parameter values. <br />\n<code>derivative</code>:  Compute the derivative of the spline at given parameter values.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This method does not check parameter values. It is used by other evaluation methods. It uses the de Boor recurrence relations for a B-spline.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">knot</span>, </span><span class=\"param\"><span class=\"n\">knots</span>, </span><span class=\"param\"><span class=\"n\">splineOrder</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">derivativeOrder</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">taylorCoefs</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.circular_arc", "modulename": "bspy.spline", "qualname": "Spline.circular_arc", "kind": "function", "doc": "<p>Create a 2D circular arc for a given radius and angle accurate to within a given tolerance.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>radius</strong> (<code>float</code>):\nThe radius of the circular arc.</li>\n<li><strong>angle</strong> (<code>float</code>):\nThe angle of the circular arc measured in degrees starting at the x-axis rotating counterclockwise.</li>\n<li><strong>tolerance</strong> (<code>float</code>, optional):\nThe maximum allowed error in the circular arc (default is machine epsilon).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline curve for the circular arc (domain from 0 to 1).</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>section</code>:  Fit a planar section to the list of 4-tuples of data. <br />\n<code>revolve</code>:  Rotate the spline to create a surface of revolution.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">angle</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.clamp", "modulename": "bspy.spline", "qualname": "Spline.clamp", "kind": "function", "doc": "<p>Ensure the leftmost/rightmost knot has a full order multiplicity, clamping the spline's \nvalue at the first/last knot to its first/last coefficient.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>left</strong> (<code>iterable</code>):\nAn iterable of independent variables to clamp on the left side.</li>\n<li><strong>right</strong> (<code>iterable</code>):\nAn iterable of independent variables to clamp on the right side.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe clamped spline. If the spline was already clamped, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">left</span>, </span><span class=\"param\"><span class=\"n\">right</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.common_basis", "modulename": "bspy.spline", "qualname": "Spline.common_basis", "kind": "function", "doc": "<p>Align a collection of splines to a common basis, elevating the order and adding knots as needed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (<code>iterable</code>):\nThe collection of N splines to align.</li>\n<li><strong>indMap</strong> (<code>iterable</code>):\nThe collection of independent variables to align. Since each spline can have multiple \nindependent variables, <code>indMap</code> is an <code>iterable</code> of <code>iterables</code> (like a list of lists). \nEach collection of indices (i0, i1, .. iN) maps the i'th independent variable to each other. \nThe domains of mapped independent variables must match. \nAn independent variable can map to no more than one other independent variable.\nIf all the splines are curves (1 independent variable), then <code>indMap</code> is ((0, 0, .. 0),).\nIf indMap is None (the default), then it is set to [N * [i] for i in range(nInd)]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>splines</strong> (<code>tuple</code>):\nThe aligned collection of N splines.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>elevate_and_insert_knots</code>:  Elevate a spline and insert new knots.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>elevate_and_insert_knots</code> to ensure mapped variables share the same order and knots.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">splines</span>, </span><span class=\"param\"><span class=\"n\">indMap</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.complete_slice", "modulename": "bspy.spline", "qualname": "Spline.complete_slice", "kind": "function", "doc": "<p>Add any missing inherent (implicit) boundaries of this spline's domain to the given slice of the \ngiven solid that are needed to make the slice valid and complete.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>slice</strong> (<code>solid.Solid</code>):\nThe slice of the given solid formed by the spline. The slice may be incomplete, missing some of the \nspline's inherent domain boundaries. Its dimension must match <code>self.domain_dimension()</code>.</li>\n<li><strong>solid</strong> (<code>solid.Solid</code>):\nThe solid being sliced by the manifold. Its dimension must match <code>self.range_dimension()</code>.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>solid.Solid.slice</code>:  slice the solid by a manifold. <br />\n<code>domain</code>:  Return the domain of a spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>A spline's inherent domain is determined by its knot array for each dimension. This method only works for \nnInd of 1 or 2.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">slice</span>, </span><span class=\"param\"><span class=\"n\">solid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.composition", "modulename": "bspy.spline", "qualname": "Spline.composition", "kind": "function", "doc": "<p>Construct a spline approximation to a composition of splines sequence.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (<code>array-like</code>):\nAn array of splines.  The splines should have the property that the number\nof independent variables of the ith spline should be the same as the number\nof dependent variables of the (i+1)st spline.  The number of dependent\nvariables of the first spline is arbitrary, as is the number of independent\nvariables of the last one.  Moreover, the range of the ith spline should be\na subset of the domain of the (i-1)st spline.  The interpretation of the\nsequence is s_0(s_1(... s_(n-1)(u)))).</li>\n<li><strong>tolerance</strong> (<code>scalar</code>):\nThe maximum 2-norm of the difference between the given function and the\nspline fit.  Defaults to 1.0e-6.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline which approximates the given composition.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This currently defaults to a cubic spline.  Depending on user experience, this\nmay change in the future.</p>\n\n<h6 id=\"see-also\">See also</h6>\n\n<p><code>fit</code> : Fit a given function to a specified tolerance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">splines</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.cone", "modulename": "bspy.spline", "qualname": "Spline.cone", "kind": "function", "doc": "<p>Construct a cone of the two given radii and height.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>radius1</strong> (scalar):\nThe desired radius of the cone at the bottom</li>\n<li><strong>radius2</strong> (scalar):\nThe desired radius of the cone at the top</li>\n<li><strong>height</strong> (scalar):\nThe desired height of the cone</li>\n<li><strong>tolerance</strong> (scalar, optional):\nThe desired absolute tolerance to which the cylinder should be constructed.  Defaults\nto 1.0e-12 if tolerance == None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA bi-quartic spline approximation to a cone of the specified radii and height,\naccurate to the given tolerance.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The resulting mapping is defined over the unit square.  The first independent variable\ncorresponds to the radial position on the cone, while the second independent variable\nis the location along the height.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>circular_arc</code>:  Create a 2D circular arc for a given radius and angle accurate to within\na given tolerance. <br />\n<code>ruled_surface</code>:  Construct a ruled surface between two curves.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius1</span>, </span><span class=\"param\"><span class=\"n\">radius2</span>, </span><span class=\"param\"><span class=\"n\">height</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.confine", "modulename": "bspy.spline", "qualname": "Spline.confine", "kind": "function", "doc": "<p>Confine the range of a curve to the given bounds.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>range_bounds</strong> (<code>iterable</code>):\nThe collection of <code>nDep</code> tuples that specify the lower and upper bounds for the curve.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe confined spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>range_bounds</code>:  Return the range of a spline as lower and upper bounds. <br />\n<code>contour</code>:  Fit a spline to the contour defined by <code>F(x) = 0</code>.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Only works for curves (<code>nInd == 1</code>). Portions of the curve that lie outside the bounds \nbecome lines along the boundary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">range_bounds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.continuity", "modulename": "bspy.spline", "qualname": "Spline.continuity", "kind": "function", "doc": "<p>Return the smoothness of the spline in each of its independent variables.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong><code>smoothness</code></strong> (<code>iterable</code>):\nAn array of length nInd containing the number of times the function is continuously\nin each of the independent variables of the input spline.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The value -1 is returned if the spline is discontinuous in that variable.  The degree of the spline\nis returned if the spline contains no interior knots even though the spline is an analytic function\nof that variable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.contour", "modulename": "bspy.spline", "qualname": "Spline.contour", "kind": "function", "doc": "<p>Fit a spline to the contour defined by <code>F(x) = 0</code>, where <code>F</code> maps n dimensions to \nn-1 dimensions. Thus, the solution, <code>x(t)</code>, is a contour curve (one degree of freedom) \nreturned in the form of a spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>F</strong> (function, <code>Spline</code>, or <code>SplineBlock</code>):\nA function, spline, or spline block that takes an array-like argument of length <code>n</code> and returns an \narray-like result of length <code>n - 1</code>.</li>\n<li><strong>knownXValues</strong> (<code>iterable</code> of array-like):\nAn <code>iterable</code> of known x values (array-like) that lie on the desired contour. \nThe length of <code>knownXValues</code> must be at least 2 (for the two boundary conditions). \nAll x values must be length <code>n</code> and be listed in the order they appear on the contour. <br />\n<code>F(x)</code> for all known x values must be a zero vector of length <code>n-1</code>.</li>\n<li><strong>dF</strong> (function, <code>iterable</code>, or <code>None</code>, optional):\nA function that returns the Jacobian of F as an array with shape (n - 1, n). \nCan also be an <code>iterable</code> of <code>n</code> functions that return the <code>n</code> first derivatives of <code>F</code>. \nIf <code>dF</code> is <code>None</code> (the default), the first derivatives will be computed for you. \nIf <code>F</code> is not a spline or spline block, computing the first derivatives involves \nmultiple calls to <code>F</code> and can be numerically unstable.</li>\n<li><strong>epsilon</strong> (<code>float</code>, optional):\nTolerance for contour precision. Evaluating <code>F</code> with contour values will be within epsilon \nof zero. The default is square root of machine epsilon.</li>\n<li><strong>metadata</strong> (<code>dict</code>, optional):\nA dictionary of ancillary data to store with the spline. Default is {}.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline contour, <code>x(t)</code>, with nInd == 1 and nDep == n.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>least_squares</code>:  Fit a spline to an array of data points using the method of least squares. <br />\n<code>contours</code>:  Find all the contour curves of a spline. <br />\n<code>confine</code>:  Confine the range of a curve to the given bounds.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The returned spline has constant parametric speed (the length of its derivative is constant). \nIf <code>F</code> is a <code>Spline</code> or a <code>SplineBlock</code>, then the range of the returned contour is confined to the domain of <code>F</code>. \nImplements the algorithm described in section 7 of Grandine, Thomas A. \n\"Applications of contouring.\" Siam Review 42, no. 2 (2000): 297-316.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">F</span>, </span><span class=\"param\"><span class=\"n\">knownXValues</span>, </span><span class=\"param\"><span class=\"n\">dF</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">metadata</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.contours", "modulename": "bspy.spline", "qualname": "Spline.contours", "kind": "function", "doc": "<p>Find all the contour curves of a spline whose <code>nInd</code> is one larger than its <code>nDep</code>.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>curves</strong> (<code>iterable</code>):\nA collection of <code>Spline</code> curves, <code>u(t)</code>, each of whose domain is [0, 1], whose range is\nin the parameter space of the given spline, and which satisfy <code>self(u(t)) = 0</code>.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>zeros</code>:  Find the roots of a spline (nInd must match nDep). <br />\n<code>contour</code>:  Fit a spline to the contour defined by <code>F(x) = 0</code>. <br />\n<code>intersect</code>:  Intersect two splines.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>zeros</code> to find all intersection points and <code>contour</code> to find individual intersection curves. \nThe algorithm used to to find all intersection curves is from Grandine, Thomas A., and Frederick W. Klein IV. \n\"A new approach to the surface intersection problem.\" Computer Aided Geometric Design 14, no. 2 (1997): 111-134.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.contract", "modulename": "bspy.spline", "qualname": "Spline.contract", "kind": "function", "doc": "<p>Contract a spline by assigning a fixed value to one or more of its independent variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable to contract.\nA value of <code>None</code> for an independent variable indicates that variable should remain unchanged.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe contracted spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>evaluate</code>:  Compute the value of the spline at given parameter values.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.convolve", "modulename": "bspy.spline", "qualname": "Spline.convolve", "kind": "function", "doc": "<p>Convolve two splines (cross, dot, or scalar product).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Spline</code>):\nThe spline to convolve with self.</li>\n<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):\nAn iterable of indices or pairs of indices. Each index refers to an independent variable.\nWithin the iterable, a single index, <code>n</code>, maps the nth independent variable of self to the same independent variable of other.\nA pair <code>(n, m)</code> maps the nth independent variable of self to the mth independent variable of other. \nFor example, if you wanted to convolve <code>self(u, v, w)</code> with <code>other(u, w)</code>, you'd pass <code>[0, (2, 1)]</code> for <code>indMap</code>. \nUnmapped independent variables remain independent (the default).\nAn independent variable can map to no more than one other independent variable.</li>\n<li><strong>productType</strong> ({'C', 'D', 'S'}, optional):\nThe type of product to perform on the dependent variables (default is 'S').\n    'C' is for a cross product, self x other (nDep must be 2 or 3).\n    'D' is for a dot product (nDep must match).\n    'S' is for a scalar product (nDep must match or be 1 for one of the splines).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe result of convolving self with other.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>multiply</code>:  Multiply two splines (cross, dot, or scalar product). <br />\n<code>integrate</code>:  Integrate a spline with respect to one of its independent variables, returning the resulting spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Taken in part from Lee, E. T. Y. \"Computing a chain of blossoms, with application to products of splines.\" \nComputer Aided Geometric Design 11, no. 6 (1994): 597-620.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">indMap</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">productType</span><span class=\"o\">=</span><span class=\"s1\">&#39;S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.copy", "modulename": "bspy.spline", "qualname": "Spline.copy", "kind": "function", "doc": "<p>Create a copy of a spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline copy.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.cross", "modulename": "bspy.spline", "qualname": "Spline.cross", "kind": "function", "doc": "<p>Cross product a spline with <code>nDep</code> of 2 or 3 by the given vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vector</strong> (array-like or <code>Spline</code>):\nAn array of length 2 or 3 or spline with <code>nDep</code> of 2 or 3 that specifies the vector.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe crossed spline: self x vector.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>multiply</code>:  Multiply two splines (cross, dot, or scalar product).  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.curvature", "modulename": "bspy.spline", "qualname": "Spline.curvature", "kind": "function", "doc": "<p>Compute the curvature of a univariate or bivariate spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (scalar):\nThe value of the curvature at the given point on the curve or surface.  If called on a surface,\nthe value will represent the Gaussian curvature of the surface at the given point.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Computes the curvature of the graph of the function if nDep == 1.  If nDep == 1 or 2,\nthen the curvature is computed as a signed quantity.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.cylinder", "modulename": "bspy.spline", "qualname": "Spline.cylinder", "kind": "function", "doc": "<p>Construct a cylinder of the given radius and height.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>radius</strong> (scalar):\nThe desired radius of the cylinder</li>\n<li><strong>height</strong> (scalar):\nThe desired height of the cylinder</li>\n<li><strong>tolerance</strong> (scalar, optional):\nThe desired absolute tolerance to which the cylinder should be constructed.  Defaults\nto 1.0e-12 if tolerance == None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA bi-quartic spline approximation to a cylinder of the specified radius and height,\naccurate to the given tolerance.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The resulting mapping is defined over the unit square.  The first independent variable\ncorresponds to the radial position on the cylinder, while the second independent variable\nis the location along the height.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>circular_arc</code>:  Create a 2D circular arc for a given radius and angle accurate to within\na given tolerance. <br />\n<code>ruled_surface</code>:  Construct a ruled surface between two curves.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">height</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.derivative", "modulename": "bspy.spline", "qualname": "Spline.derivative", "kind": "function", "doc": "<p>Compute the derivative of the spline at given parameter values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>with_respect_to</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the integer order of derivative for each independent variable.\nA zero-order derivative just evaluates the spline normally.</li>\n<li><strong>*uvw</strong> (<code>iterable</code> or iterable of iterables):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values), or \nan iterable of iterables of length <code>nInd</code> that specifies values for each independent variable (numpy ufunc style).</li>\n<li><strong>**kwargs:</strong>: For other keyword-only arguments, see the <a href=\"https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs-kwargs\">ufunc docs </a>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the derivative of the spline at the given parameter values (array of size nDep). If multiple points are \npassed (numpy ufunc style), then multiple arrays are returned, one for each dependent variable.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>evaluate</code>:  Compute the value of the spline at a given parameter value. <br />\n<code>differentiate</code>:  Differentiate a spline with respect to one of its independent variables, returning the resulting spline. <br />\n<code>integral</code>:  Compute the integral of the spline at a given parameter value. <br />\n<code>integrate</code>:  Integrate a spline with respect to one of its independent variables, returning the resulting spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The derivative method uses the de Boor recurrence relations for a B-spline\nseries to evaluate a spline.  The non-zero B-splines are\nevaluated, then the dot product of those B-splines with the vector of\nB-spline coefficients is computed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">with_respect_to</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">uvw</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.differentiate", "modulename": "bspy.spline", "qualname": "Spline.differentiate", "kind": "function", "doc": "<p>Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>with_respect_to</strong> (integer, optional):\nThe number of the independent variable to differentiate. Default is zero.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline that results from differentiating the original spline with respect to the given independent variable.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>derivative</code>:  Compute the derivative of the spline at a given parameter value. <br />\n<code>integral</code>:  Compute the integral of the spline at a given parameter value. <br />\n<code>integrate</code>:  Integrate a spline with respect to one of its independent variables, returning the resulting spline.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">with_respect_to</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.domain", "modulename": "bspy.spline", "qualname": "Spline.domain", "kind": "function", "doc": "<p>Return the domain of a spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bounds</strong> (<code>numpy.array</code>):\nnInd x 2 array of the lower and upper bounds on each of the independent variables.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>reparametrize</code>:  Reparametrize a spline to match new domain bounds <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.domain_dimension", "modulename": "bspy.spline", "qualname": "Spline.domain_dimension", "kind": "function", "doc": "<p>Return the domain dimension of a spline (nInd).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):\nThe dimension of the spline's domain (nInd)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.dot", "modulename": "bspy.spline", "qualname": "Spline.dot", "kind": "function", "doc": "<p>Dot product a spline by the given vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vector</strong> (array-like or <code>Spline</code>):\nAn array of length <code>nDep</code> or spline with matching <code>nDep</code> that specifies the vector.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe dotted spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>multiply</code>:  Multiply two splines (cross, dot, or scalar product).  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline @ vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.elevate", "modulename": "bspy.spline", "qualname": "Spline.elevate", "kind": "function", "doc": "<p>Elevate a spline, increasing its order by <code>m</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>m</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the non-negative integer amount to increase the order \nfor each independent variable of the spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the order of the current spline plus <code>m</code>.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>elevate_and_insert_knots</code>:  Elevate a spline and insert new knots.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. \n\"Fast degree elevation and knot insertion for B-spline curves.\" Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.elevate_and_insert_knots", "modulename": "bspy.spline", "qualname": "Spline.elevate_and_insert_knots", "kind": "function", "doc": "<p>Elevate a spline and insert new knots.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>m</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the non-negative integer amount to increase the order \nfor each independent variable of the spline.</li>\n<li><strong>newKnots</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the knots to be added to each independent variable's knots. \nlen(newKnots[ind]) == 0 if no knots are to be added for the <code>ind</code> independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the order of the current spline plus <code>m</code> that includes the new knots.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>clamp</code>:  Clamp the left and/or right side of a spline. <br />\n<code>elevate</code>:  Elevate a spline, increasing its order by <code>m</code>.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. \n\"Fast degree elevation and knot insertion for B-spline curves.\" Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">newKnots</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.evaluate", "modulename": "bspy.spline", "qualname": "Spline.evaluate", "kind": "function", "doc": "<p>Compute the value of the spline at given parameter values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>*uvw</strong> (<code>iterable</code> or iterable of iterables):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values), or \nan iterable of iterables of length <code>nInd</code> that specifies values for each independent variable (numpy ufunc style).</li>\n<li><strong>**kwargs:</strong>: For other keyword-only arguments, see the <a href=\"https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs-kwargs\">ufunc docs </a>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the spline at the given parameter values (array of size nDep). If multiple points are \npassed (numpy ufunc style), then multiple arrays are returned, one for each dependent variable.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>derivative</code>:  Compute the derivative of the spline at given parameter values.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline(<em>uvw, *</em>kwargs).</p>\n\n<p>The evaluate method uses the de Boor recurrence relations for a B-spline\nseries to evaluate a spline.  The non-zero B-splines are\nevaluated, then the dot product of those B-splines with the vector of\nB-spline coefficients is computed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">uvw</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.extrapolate", "modulename": "bspy.spline", "qualname": "Spline.extrapolate", "kind": "function", "doc": "<p>Extrapolate a spline out to an extended domain maintaining a given order of continuity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new lower and upper bounds on each of the independent variables (same form as \nreturned from <code>domain</code>). If a bound is None or nan then the original bound (and knots) are left unchanged.</li>\n<li><strong>continuityOrder</strong> (<code>int</code>):\nThe order of continuity of the extrapolation (the number of derivatives that match at the endpoints). \nA continuity order of zero means the extrapolation just matches the spline value at the endpoints. \nThe continuity order is automatically limited to one less than the degree of the spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nExtrapolated spline. If all the knots are unchanged, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>domain</code>:  Return the domain of a spline. <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newDomain</span>, </span><span class=\"param\"><span class=\"n\">continuityOrder</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.fit", "modulename": "bspy.spline", "qualname": "Spline.fit", "kind": "function", "doc": "<p>Fit the function f with a spline to a given tolerance.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domain - <code>array-like</code></strong>: An nInd x 2 array which specifies the rectangular domain (in nInd dimensions)\nover which the function f is defined.  The approximating spline which is the\noutput will be defined over the same rectangular domain</li>\n<li><strong>f</strong> (Python function):\nThe function to approximate.  It is a vector-valued function of nDep\ncomponents in nInd variables.</li>\n<li><strong>order</strong> (<code>array-like</code>):\nAn optional integer array of length nInd which specifies the polynomial\norder to use in each of the independent variables.  It will default to order\n4 (degree 3) if None is specified (the default)</li>\n<li><strong>knots</strong> (<code>array-like</code>):\nThe initial knot sequence to use, if given</li>\n<li><strong>tolerance</strong> (<code>scalar</code>):\nThe maximum 2-norm of the difference between the given function and the\nspline fit.  Defaults to 1.0e-4.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline which approximates the given function to within the specified\ntolerance.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>least_squares</code>:  Fit a least squares approximation to given data.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">domain</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">knots</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"mf\">0.0001</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.flip_normal", "modulename": "bspy.spline", "qualname": "Spline.flip_normal", "kind": "function", "doc": "<p>Flip the direction of the normal.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline with flipped normal. The spline retains the same tangent space.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>solid.Solid.complement</code>:  Return the complement of the solid: whatever was inside is outside and vice-versa.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.fold", "modulename": "bspy.spline", "qualname": "Spline.fold", "kind": "function", "doc": "<p>Fold the coefficients of a spline's indicated independent variables into the coefficients of the remaining independent variables, retaining the \nindicated independent variables' knots and orders in a second spline with no coefficients.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>foldedInd</strong> (<code>iterable</code>):\nAn iterable that specifies the independent variables whose coefficients should be folded.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>foldedSpline, coefficientlessSpline</strong> (<code>Spline</code>, <code>Spline</code>):\nThe folded spline and the coefficientless spline that retains the indicated independent variables' knots and orders.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>unfold</code>:  Unfold the coefficients of an original spline's indicated independent variables back into the spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.\nThe first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, \nall of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline \nwith 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, \nreturning the original spline.</p>\n\n<p>Here's an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. \nThen spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have \nshape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn't matter \nso long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">foldedInd</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.four_sided_patch", "modulename": "bspy.spline", "qualname": "Spline.four_sided_patch", "kind": "function", "doc": "<p>Construct a surface from its four boundary curves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>bottom</strong> (<code>Spline</code>):\nA curve which represents the bottom edge of the resulting surface.</li>\n<li><strong>right</strong> (<code>Spline</code>):\nA curve which represents the right edge of the resulting surface.</li>\n<li><strong>top</strong> (<code>Spline</code>):\nA curve which represents the top edge of the resulting surface.</li>\n<li><strong>left</strong> (<code>Spline</code>):\nA curve which represents the left edge of the resulting surface.</li>\n<li><strong>surfParam</strong> (scalar, optional):\nA scalar which selects which member of a one parameter family of interpolating\nsurfaces to return.  surfParam = 0.0 will return the Coons patch.  surfParam = 1.0\nwill return the surface for which each dependent variable approximately solves the\nLaplace equation for which the four boundary curves are the Dirichlet boundary\nconditions.  Other values of surfParam will return the appropriate affine combination\nof those two surfaces.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>surface</strong> (<code>Spline</code>):\nThe spline surface requested by the input curves and surfParam.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>common_basis</code>:  Determine a common B-spline basis for two or more splines.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The variables bottom, right, top, and left are notional in the sense that the curves can\nbe given in any order.  This method does the best possible job of matching endpoints, so\nthe roles of \"right,\" \"top,\" and \"left\" may very well get reassigned.  Moreover, the\nparametrization of the curves may also get reversed in order to best match endpoints.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bottom</span>, </span><span class=\"param\"><span class=\"n\">right</span>, </span><span class=\"param\"><span class=\"n\">top</span>, </span><span class=\"param\"><span class=\"n\">left</span>, </span><span class=\"param\"><span class=\"n\">surfParam</span><span class=\"o\">=</span><span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.from_dict", "modulename": "bspy.spline", "qualname": "Spline.from_dict", "kind": "function", "doc": "<p>Create a <code>Spline</code> from data in a <code>dict</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dictionary</strong> (<code>dict</code>):\nThe <code>dict</code> containing <code>Spline</code> data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>to_dict</code>:  Return a <code>dict</code> with <code>Spline</code> data.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dictionary</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.full_domain", "modulename": "bspy.spline", "qualname": "Spline.full_domain", "kind": "function", "doc": "<p>Return a solid that represents the full domain of the spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>domain</strong> (<code>Solid</code>):\nThe full (untrimmed) domain of the spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Boundary</code>:  A portion of the boundary of a solid.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.geodesic", "modulename": "bspy.spline", "qualname": "Spline.geodesic", "kind": "function", "doc": "<p>Determine a geodesic between two points on a surface</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvStart</strong> (<code>array-like</code>):\nThe parameter values for the surface at one end of the desired geodesic.</li>\n<li><strong>uvEnd</strong> (<code>array-like</code>):\nThe parameter values for the surface at the other end of the desired geodesic.</li>\n<li><strong>tolerance</strong> (scalar):\nThe maximum error in parameter space to which the geodesic should get computed.\nDefaults to 1.0e-6.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>geodesic</strong> (<code>Spline</code>):\nA spline curve whose range is in the domain of the given surface.  The range of the\ncurve is the locus of points whose image under the surface map form the curve of\nminimum distance between the two given points.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>solve_ode</code>:  Solve an ordinary differential equation using spline collocation.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Solves the second order ODE which are the geodesic equations over the surface.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvStart</span>, </span><span class=\"param\"><span class=\"n\">uvEnd</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.graph", "modulename": "bspy.spline", "qualname": "Spline.graph", "kind": "function", "doc": "<p>Generate the spline which is the graph of the given spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with nInd independent variables and nInd + nDep dependent variables, the first nInd of\nwhich are just the independent variables themselves. For example, given a scalar\nvalued function f of two variables u and v, returns the spline of two independent variables whose\nthree dependent variables are (u, v, f(u,v)).</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>add</code>:  Add two splines together  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Makes use of matrix spline multiply and tensor product addition for splines.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.greville", "modulename": "bspy.spline", "qualname": "Spline.greville", "kind": "function", "doc": "<p>Compute and return the Greville abscissae (knot averages) for the given independent\nvariable.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ind</strong> (integer, optional):\nThe index of the independent variable (default is 0).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>knotAverages</strong> (<code>numpy.ndarray</code>):\nAn array with the knot averages for the specified independent variable.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The Greville abscissae always satisfy the interlacing conditions, so can be used as\nvalid collocation points, interpolation points, or quadrature points.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ind</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.insert_knots", "modulename": "bspy.spline", "qualname": "Spline.insert_knots", "kind": "function", "doc": "<p>Insert new knots into a spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newKnots</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the knots to be added to each independent variable's knots. \nlen(newKnots[ind]) == 0 if no knots are to be added for the <code>ind</code> independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the new knots inserted. If no knots were inserted, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>clamp</code>:  Clamp the left and/or right side of a spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements Boehm's standard knot insertion algorithm.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newKnots</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.integral", "modulename": "bspy.spline", "qualname": "Spline.integral", "kind": "function", "doc": "<p>Compute the integral of a function composed with a spline.  In particular, compute the\nnInd-dimensional integral over the specified domain of the quantity f(x_0, x_1, ..., x_{nDep - 1})dA,\nwhere x_i is the (i+1)-th dependent variable, and dA is the multivariate measure of the spline mapping.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>integrand</strong> (Python function, optional):\nA Python function which takes an array-like object of length nDep as input and returns a\nscalar.  If None is specified for integrand, then the function which returns a constant value\nof one is used.  This computes the volume measure of the spline itself (arc length, surface area,\nvolume, etc.) depending on the dimensionality of the spline itself.</li>\n<li><strong>domain</strong> (array-like):\nnInd x 2 array of the lower and upper limits of integration for the spline on each of the\nindependent variables.  If domain is None, then the actual domain of the spline is used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>integral_value</strong> (<code>float</code>):\nThe computed value of the specified integral</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>integrate</code>:  Integrate a spline with respect to one of its independent variables, returning\nthe resulting spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This function is very useful for computing mass properties of splines.  If the integrand function\nreturns one, then the volume measure of the spline itself is computed (arc length, surface area,\nvolume, etc.).  If the integrand function returns one of the dependent variable values, then the\nintegral will be the first moment of the spline with respect to that variable, making it possible\nto compute centroids and center of mass.  The integrand function should be smooth, but is otherwise\nunrestricted.</p>\n\n<p>Attempts to compute the integral to two digits less than machine precision.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">integrand</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">domain</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.integrate", "modulename": "bspy.spline", "qualname": "Spline.integrate", "kind": "function", "doc": "<p>Integrate a spline with respect to one of its independent variables, returning the resulting spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>with_respect_to</strong> (integer, optional):\nThe index of the independent variable to integrate. Default is zero.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline that results from integrating the original spline with respect to the given independent variable.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>differentiate</code>:  Differentiate a spline with respect to one of its independent variables, returning the resulting spline. <br />\n<code>derivative</code>:  Compute the derivative of the spline at a given parameter value. <br />\n<code>integral</code>:  Compute the integral of the spline at a given parameter value.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">with_respect_to</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.intersect", "modulename": "bspy.spline", "qualname": "Spline.intersect", "kind": "function", "doc": "<p>Intersect a spline or hyperplane.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Spline</code> or <code>Hyperplane</code>):\nThe <code>Manifold</code> to intersect with self (must have same range dimension as self).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><p><strong>intersections</strong> (<code>iterable</code> (or <code>NotImplemented</code> if other is an unknown type of Manifold)):\nA list of intersections between the two manifolds. \nEach intersection records either a crossing or a coincident region.</p>\n\n<p>For a crossing, intersection is a <code>Manifold.Crossing</code>: (left, right)</p>\n\n<ul>\n<li>left : <code>Manifold</code> in the manifold's domain where the manifold and the other cross.</li>\n<li>right : <code>Manifold</code> in the other's domain where the manifold and the other cross.</li>\n<li>Both intersection manifolds have the same domain and range (the crossing between the manifold and the other).</li>\n</ul>\n\n<p>For a coincident region, intersection is a <code>Manifold.Coincidence</code>: (left, right, alignment, transform, inverse, translation)</p>\n\n<ul>\n<li>left : <code>Solid</code> in the manifold's domain within which the manifold and the other are coincident.</li>\n<li>right : <code>Solid</code> in the other's domain within which the manifold and the other are coincident.</li>\n<li>alignment : scalar value holding the normal alignment between the manifold and the other (the dot product of their unit normals).</li>\n<li>transform : <code>numpy.array</code> holding the transform matrix from the manifold's domain to the other's domain.</li>\n<li>inverse : <code>numpy.array</code> holding the inverse transform matrix from the other's domain to the boundary's domain.</li>\n<li>translation : <code>numpy.array</code> holding the translation vector from the manifold's domain to the other's domain.</li>\n<li>Together transform, inverse, and translation form the mapping from the manifold's domain to the other's domain and vice-versa.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>zeros</code>:  Find the roots of a spline (nInd must match nDep). <br />\n<code>contours</code>:  Find all the contour curves of a spline. <br />\n<code>solid.Solid.slice</code>:  slice the solid by a manifold.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>zeros</code> to find all intersection points and <code>contours</code> to find all the intersection curves.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.jacobian", "modulename": "bspy.spline", "qualname": "Spline.jacobian", "kind": "function", "doc": "<p>Compute the value of the spline's Jacobian at given parameter values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the spline's Jacobian at the given parameter values. The shape of the return value is (nDep, nInd).</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>evaluate</code>:  Compute the value of the spline at given parameter values. <br />\n<code>derivative</code>:  Compute the derivative of the spline at given parameter values.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Calls <code>derivative</code> nInd times.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.join", "modulename": "bspy.spline", "qualname": "Spline.join", "kind": "function", "doc": "<p>Join a list of splines together into a single spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splineList</strong> (<code>iterable</code>):\nThe list of splines to join together.  All must have the same number of dependent variables.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>joinedSpline</strong> (<code>Spline</code>):\nA single spline whose image is the union of all the images of the input splines.  The resulting spline\nis parametrized over the unit cube.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Currently only works for univariate splines.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">splineList</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.least_squares", "modulename": "bspy.spline", "qualname": "Spline.least_squares", "kind": "function", "doc": "<p>Fit a spline to an array of data points using the method of least squares.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>uValues</strong> (<code>iterable</code> of array-like values):\nThe values of the independent variables in each of the coordinate directions for\neach of the data points.  It's either a simple array of length nU or it is an array\nof length nInd of arrays with corresponding lengths nU, nV, . . ., nW, where each\nlength indicates the number of data points in that independent variable.  For each\nindependent variable, the values must be ordered, i.e. uValue[i] &lt;= uValue[i+1].  The\ncorresponding point in dataPoints will be an array of length nDep which represents the\ndesired function values at that point.  If the values in uValues are repeated, then\nthe corresponding data in dataPoints represents a derivative value.  Examples:</p>\n\n<p>If uValues == [0.0, 1.0, 1.0, 2.0, 3.0, 3.0, 3.0], then nInd == 1 and dataPoints\ncontains\n[f(0.0), f(1.0), f'(1.0), f(2.0), f(3.0), f'(3.0), f''(3.0)]</p>\n\n<p>if uValues == [[0.0, 1.0, 1.0, 2.0], [0.0, 1.0, 2.0, 2.0, 3.0]], then nInd == 2 and\ndataPoints contains\n[[f(0,0), f(0,1), f(0,2), f_v(0,2), f(0,3)],\n[f(1,0), f(1,1), f(1,2), f_v(1,2), f(1,3)],\n[f_u(1,0), f_u(1,1), f_u(1,2), f_uv(1,2), f_u(1,3)],\n[f(2,0), f(2,1), f(2,2), f_v(2,2), f(2,3)]]</p></li>\n<li><strong>dataPoints</strong> (<code>iterable</code> of array-like values):\nA collection of data points.  The shape of this array mirrors the shape of\nSpline.coefs, i.e. it has shape (nDep, nU, nV, . . . , nW).  The indices into this\narray also index into uValues to retrieve the independent variable values.\nFor example, if nInd == 2 and nDep == 3, then the shape of dataPoints is (3, nU, nV)\nand dataPoint[:,i,j] has independent variable values given by uValues[0,i] and\nuValues[1,j].</li>\n<li><strong>order</strong> (<code>tuple</code>):\nA tuple of length nInd where each integer entry represents the\npolynomial order of the spline in that variable.  If order == None, then\norder == [4] * nInd is assumed.</li>\n<li><strong>knots</strong> (<code>list</code>, optional):\nA list of the lists of the knots of the spline in each independent variable.  The\nlength of knots should be nInd if it is specified, where each of the arrays specify\nthe knots of the spline to use in that independent variable.  All of the dataPoints\nmust lie within the domain specified by the knots.  If knots == None (the default),\nthen the knots are automatically determined.</li>\n<li><strong>compression</strong> (scalar, optional):\nThe desired compression of data used as a fraction of the number of data points, i.e\ncompression is a number between 0 and 1.  This fraction is used to determine the\ntotal number of spline coefficients when knots are chosen automatically (it's if the\nknots are specified). The actual compression will be slightly less because the number\nof coefficients is rounded up. The default value is zero (interpolation, no compression).</li>\n<li><strong>tolerance</strong> (scalar, optional):\nIf tolerance is specified, then a fit to tolerance is performed.  Using the given knots\nas the initial set of knots, additional knots are inserted until the 2-norm of the\ndifference between each of the each given dataPoints and the vector given by the\nspline is no larger than the specified tolerance.</li>\n<li><strong>fixEnds</strong> (Boolean, optional):\nif fixEnds is True, then all of the dataPoints which lie on any of the domain\nboundaries of the spline become interpolation conditions, i.e. the spline will be\nfit in such a way that those boundary points are exactly satisfied by the computed\nspline.  Otherwise, least-squares fitting will be performed on all of the dataPoints.</li>\n<li><strong>metadata</strong> (<code>dict</code>, optional):\nA dictionary of ancillary data to store with the spline. Default is {}.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline curve which approximates the data points.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>numpy.linalg.lstsq</code> to compute the least squares solution.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">uValues</span>,</span><span class=\"param\">\t<span class=\"n\">dataPoints</span>,</span><span class=\"param\">\t<span class=\"n\">order</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">knots</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">compression</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fixEnds</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">metadata</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.line", "modulename": "bspy.spline", "qualname": "Spline.line", "kind": "function", "doc": "<p>Construct a line between two points or between two lines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>startPoint</strong> (any):\nA scalar or a list or an array or an instance of a Spline.</li>\n<li><strong>endPoint</strong> (any):\nA scalar or a list or an array or an instance of a Spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline that interpolates the two inputs.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>ruled_surface</code>:  Construct a ruled surface between two splines.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Construct splines out of the two points and then call ruled_surface.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">startPoint</span>, </span><span class=\"param\"><span class=\"n\">endPoint</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.load", "modulename": "bspy.spline", "qualname": "Spline.load", "kind": "function", "doc": "<p>Load splines in json format from the specified filename (full path).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fileName</strong> (<code>string</code>):\nThe full path to the file containing the spline. Can be a relative path.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>splines</strong> (list of <code>Spline</code>):\nThe loaded splines.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>save</code>:  Save a spline in json format to the specified filename (full path).  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fileName</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.multiply", "modulename": "bspy.spline", "qualname": "Spline.multiply", "kind": "function", "doc": "<p>Multiply two splines (cross, dot, or scalar product).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Spline</code>):\nThe spline to multiply by self.</li>\n<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):\nAn iterable of indices or pairs of indices. Each index refers to an independent variable.\nWithin the iterable, a single index, <code>n</code>, maps the nth independent variable of self to the same independent variable of other.\nA pair <code>(n, m)</code> maps the nth independent variable of self to the mth independent variable of other. \nFor example, if you wanted to compute <code>self(u, v, w) * other(u, w)</code>, you'd pass <code>[0, (2, 1)]</code> for <code>indMap</code>. \nUnmapped independent variables remain independent (the default).\nThe domains of mapped independent variables must match. \nAn independent variable can map to no more than one other independent variable.</li>\n<li><strong>productType</strong> ({'C', 'D', 'S'}, optional):\nThe type of product to perform on the dependent variables (default is 'S').\n    'C' is for a cross product, self x other (nDep must be 2 or 3).\n    'D' is for a dot product (nDep must match).\n    'S' is for a scalar product (nDep must match or be 1 for one of the splines).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe result of multiplying self and other.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>add</code>:  Add two splines. <br />\n<code>subtract</code>:  Subtract two splines. <br />\n<code>convolve</code>:  Convolve two splines (cross, dot, or scalar product).  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline1 * spline2 with indMap = range(min(spline1.nInd, spline2.nInd)) and productType = 'S'.</p>\n\n<p>Taken in part from Lee, E. T. Y. \"Computing a chain of blossoms, with application to products of splines.\" \nComputer Aided Geometric Design 11, no. 6 (1994): 597-620.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">indMap</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">productType</span><span class=\"o\">=</span><span class=\"s1\">&#39;S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.normal", "modulename": "bspy.spline", "qualname": "Spline.normal", "kind": "function", "doc": "<p>Compute the normal of the spline at given parameter values. The number of independent variables must be\none different than the number of dependent variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>\n<li><strong>normalize</strong> (<code>boolean</code>, optional):\nIf True the returned normal will have unit length (the default). Otherwise, the normal's length will\nbe the area of the tangent space (for two independent variables, its the length of the cross product of tangent vectors).</li>\n<li><strong>indices</strong> (<code>iterable</code>, optional):\nAn iterable of normal indices to calculate. For example, <code>indices=(0, 3)</code> will return a vector of length 2\nwith the first and fourth values of the normal. If <code>None</code>, all normal values are returned (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>normal</strong> (<code>numpy.array</code>):\nThe normal vector of the spline at the given parameter values.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>derivative</code>:  Compute the derivative of the spline at a given parameter value. <br />\n<code>normal_spline</code>:  Compute a spline that evaluates to the normal of the given spline (not normalized).  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Attentive readers will notice that the number of independent variables could be one more than the number of \ndependent variables (instead of one less, as is typical). In that case, the normal represents the null space of \nthe matrix formed by the tangents of the spline. If the null space is greater than one dimension, the normal will be zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span>, </span><span class=\"param\"><span class=\"n\">normalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.normal_spline", "modulename": "bspy.spline", "qualname": "Spline.normal_spline", "kind": "function", "doc": "<p>Compute a spline that evaluates to the normal of the given spline. The length of the normal\nis the area of the tangent space (for two independent variables, its the length of the cross product of tangent vectors).\nThe number of independent variables must be one different than the number of dependent variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices</strong> (<code>iterable</code>, optional):\nAn iterable of normal indices to calculate. For example, <code>indices=(0, 3)</code> will make the returned spline compute a vector of length 2\nwith the first and fourth values of the normal. If <code>None</code>, all normal values are returned (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline that evaluates to the normal of the given spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>normal</code>:  Compute the normal of the spline at given parameter values. <br />\n<code>differentiate</code>:  Differentiate a spline with respect to one of its independent variables, returning the resulting spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Attentive readers will notice that the number of independent variables could be one more than the number of \ndependent variables (instead of one less, as is typical). In that case, the normal represents the null space of \nthe matrix formed by the tangents of the spline. If the null space is greater than one dimension, the normal will be zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.point", "modulename": "bspy.spline", "qualname": "Spline.point", "kind": "function", "doc": "<p>Construct a spline which represents a point.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>point</strong> (scalar, list, or array):\nA scalar or a list or an array or an instance of a Spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline that represents the input point.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>line</code>:  Construct a line between two points.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Construct a spline out of an input point.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.range_bounds", "modulename": "bspy.spline", "qualname": "Spline.range_bounds", "kind": "function", "doc": "<p>Return the range of a spline as lower and upper bounds on each of the\ndependent variables.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.range_dimension", "modulename": "bspy.spline", "qualname": "Spline.range_dimension", "kind": "function", "doc": "<p>Return the range dimension of a spline (nDep).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dimension</strong> (<code>int</code>):\nThe dimension of the spline's range (nDep)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.remove_knot", "modulename": "bspy.spline", "qualname": "Spline.remove_knot", "kind": "function", "doc": "<p>Remove a single knot from a univariate spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>iKnot</strong> (integer):\nIndex of the knot to remove from the spline</li>\n<li><strong>nLeft</strong> (integer):\nNumber of continuity conditions to enforce on the left end.  For example, if nLeft = 2,\nthen remove_knot will leave the function value and first derivative unchanged on the\nleft end of the domain.</li>\n<li><strong>nRight</strong> (integer):\nNumber of continuity conditions to enforce on the right end.  For example, if\nnRight = 3, then remove_knot will leave the function value and first and second\nderivative values unchanged on the right end of the domain.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nNew spline with the specified knot removed</li>\n<li><strong>residual</strong> (array-like):\nA vector containing the least squares residuals for each dependent variable</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>remove_knots</code>  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Solves a simple least squares problem</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">iKnot</span>, </span><span class=\"param\"><span class=\"n\">nLeft</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">nRight</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.remove_knots", "modulename": "bspy.spline", "qualname": "Spline.remove_knots", "kind": "function", "doc": "<p>Remove interior knots from a spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tolerance</strong> (<code>float</code>, optional):\nThe maximum pointwise relative error permitted after removing all the knots. Knots will be\nremoved until removal of the next knot would put the pointwise error above the threshold.\nThe default is 1.0e-14 which is relative to the size of each of the dependent variables.</li>\n<li><strong>nLeft</strong> (integer):\nNumber of continuity conditions to enforce on the left end.  For example, if nLeft = 2,\nthen remove_knot will leave the function value and first derivative unchanged on the\nleft end of the domain.</li>\n<li><strong>nRight</strong> (integer):\nNumber of continuity conditions to enforce on the right end.  For example, if\nnRight = 3, then remove_knot will leave the function value and first and second\nderivative values unchanged on the right end of the domain.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the knots removed.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>remove_knot</code>:  Remove an indicated knot from a spline. <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Calls <code>remove_knot</code> repeatedly until no longer possible.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"mf\">1e-14</span>, </span><span class=\"param\"><span class=\"n\">nLeft</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">nRight</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.reparametrize", "modulename": "bspy.spline", "qualname": "Spline.reparametrize", "kind": "function", "doc": "<p>Reparametrize a spline to match new domain bounds. The spline's number of knots and its coefficients remain unchanged.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new lower and upper bounds on each of the independent variables (same form as \nreturned from <code>domain</code>). If a bound pair is <code>None</code> then the original bound (and knots) are left unchanged. \nFor example, <code>[[0.0, 1.0], None]</code> will reparametrize the first independent variable and leave the second unchanged)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nReparametrized spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>domain</code>:  Return the domain of a spline.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newDomain</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.reverse", "modulename": "bspy.spline", "qualname": "Spline.reverse", "kind": "function", "doc": "<p>Reverse the direction of a spline along one of the independent variables</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>variable</strong> (integer):\nindex of the independent variable to reverse the direction of.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nReparametrized (i.e. reversed) spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>reparametrize</code>:  Reparametrize a spline  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">variable</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.revolve", "modulename": "bspy.spline", "qualname": "Spline.revolve", "kind": "function", "doc": "<p>Revolve the spline to create a surface of revolution (nDep must equal 2, \nfirst dimension provides the radius for x and y, second dimension provides the z).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>angle</strong> (<code>float</code>):\nThe angle of the circular arc measured in degrees starting at the x-axis rotating counterclockwise.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nSurface of revolution (first independent variable sweeps the arc from 0 to 1).</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>circular_arc</code>:  Create a 2D circular arc for a given radius and angle accurate to within a given tolerance.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.rotate", "modulename": "bspy.spline", "qualname": "Spline.rotate", "kind": "function", "doc": "<p>Rotate a spline around a vector by the specified angle.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vector</strong> (array-like):\nA vector of length three about which to rotate the spline</li>\n<li><strong>angle</strong> (scalar):\nThe number of degrees to rotate the spline around vector by</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe rotated spline</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>transform</code>:  Multiply a spline by a given matrix.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses the well-known Rodrigues' rotation formula and mathematical operations\non splines.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.ruled_surface", "modulename": "bspy.spline", "qualname": "Spline.ruled_surface", "kind": "function", "doc": "<p>Create a ruled surface between two splines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline1</strong> (<code>Spline</code>):\nThe first spline (must have the same nInd and nDep as the second spline).</li>\n<li><strong>spline2</strong> (<code>Spline</code>):\nThe second spline (must have the same nInd and nDep as the first spline).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nRuled surface between spline1 and spline2.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline1</span>, </span><span class=\"param\"><span class=\"n\">spline2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.save", "modulename": "bspy.spline", "qualname": "Spline.save", "kind": "function", "doc": "<p>Save a spline in json format to the specified filename (full path).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fileName</strong> (<code>string</code>):\nThe full path to the file containing the spline. Can be a relative path.</li>\n<li><strong>*additional_splines</strong> (<code>Spline</code>):\nMore splines to save in the same file.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>load</code>:  Load splines in json format from the specified filename (full path).  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fileName</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">additional_splines</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.scale", "modulename": "bspy.spline", "qualname": "Spline.scale", "kind": "function", "doc": "<p>Scale a spline by the given scalar or scale vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>multiplier</strong> (scalar, array-like, or <code>Spline</code>):\nA scalar, an array of length <code>nDep</code>, or spline that specifies the multiplier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe scaled spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>multiply</code>:  Multiply two splines (cross, dot, or scalar product). <br />\n<code>transform</code>:  Transform a spline by the given matrix. <br />\n<code>translate</code>:  Translate a spline by the given translation vector.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline * multiplier.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">multiplier</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.section", "modulename": "bspy.spline", "qualname": "Spline.section", "kind": "function", "doc": "<p>Fit a planar section to the list of 4-tuples of data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>xytk</strong> (array-like):\nA list of points to fit an interpolating spline to.  Each point in the list contains\nfour values.  The first two are x and y coordinates of the point.  The third value is the\nangle that the tangent makes as the desired section passes through that point (in degrees).\nThe fourth value is the desired curvature at that point</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA quartic spline which interpolates the given values.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The spline is shape-preserving.  Each consecutive pair of data points must describe a convex or\nconcave curve.  In particular, if it is impossible for a differentiable curve to interpolate two\nconsecutive data points without passing through an intermediate inflection point (i.e. a point which\nhas zero curvature and at which the sign of the curvature changes), then this method will fail\nwith an error.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>circular_arc</code>:  Create a 2D circular arc for a given radius and angle accurate to within a given tolerance.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xytk</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.solve_ode", "modulename": "bspy.spline", "qualname": "Spline.solve_ode", "kind": "function", "doc": "<p>Numerically solve an ordinary differential equation with boundary conditions.</p>\n\n<h1 id=\"parameters\">Parameters</h1>\n\n<p>self : <code>Spline</code>\n    The initial guess for the solution to the spline.  All of the spline parameters, e.g.\n    order, boundary conditions, domain, etc. are all established by the initial guess.  The\n    ODE itself must be of the form u^(nOrder)(t) = F(t, u, u', ... , u^(nOrder-1)).  self.nDep should\n    be the same as the number of state variables in the ODE.</p>\n\n<p>nLeft : integer\n    The number of boundary conditions to be imposed on the left side of the domain.  The\n    order of the differential equation is assumed to be the sum of nLeft and nRight.</p>\n\n<p>nRight : integer\n    The number of boundary conditions to be imposed on the right sie of the domain.  The\n    order of the differential equation is assumed to be the sum of nLeft and nRight.</p>\n\n<p>FAndF_u : Python function\n    FAndF_u must have exactly this calling sequence:  FAndF_u(t, uData, *args).  t is a scalar set\n    to the desired value of the independent variable of the ODE.  uData will be a numpy matrix of shape\n    (self.nDep, nOrder) whose columns are (u, ... , u^(nOrder - 1).  It must return a numpy\n    vector of length self.nDep and a numpy array whose shape is (self.nDep, self.nDep, nOrder).\n    The first output vector is the value of the forcing function F at (t, uData).  The numpy\n    array is the array of partial derivatives with respect to all the numbers in uData.  Thus, if\n    this array is called jacobian, then jacobian[:, i, j] is the gradient of the forcing function with\n    respect to uData[i, j].</p>\n\n<p>tolerance : scalar\n    The relative error to which the ODE should get solved.</p>\n\n<p>args : tuple\n    Additional arguments to pass to the user-defined function FAndF_u.  For example, if FAndF_u has the\n    FAndF_u(t, uData, a, b, c), then args must be a tuple of length 3.</p>\n\n<h1 id=\"notes\">Notes</h1>\n\n<p>This method uses B-splines as finite elements.  The ODE itself is discretized using\ncollocation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nLeft</span>, </span><span class=\"param\"><span class=\"n\">nRight</span>, </span><span class=\"param\"><span class=\"n\">FAndF_u</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span>, </span><span class=\"param\"><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.sphere", "modulename": "bspy.spline", "qualname": "Spline.sphere", "kind": "function", "doc": "<p>Construct a sphere of the given radius.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>radius</strong> (scalar):\nThe desired radius of the sphere</li>\n<li><strong>tolerance</strong> (scalar, optional):\nThe desired absolute tolerance to which the sphere should be constructed.  Defaults\nto 1.0e-12 if tolerance == None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA bi-quartic spline approximation to a sphere of the specified radius, accurate to\nthe given tolerance.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The resulting mapping is defined over the unit square.  The first independent variable\ncorresponds to the latitude of the sphere, with 0 mapping to the south pole, 1 mapping to\nthe north pole, and 0.5 mapping to the equator.  The second independent variable is the\nlongitude, with 0 mapping to the meridian which is coplanar with the positive x-axis.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>circular_arc</code>:  Create a 2D circular arc for a given radius and angle accurate to within\na given tolerance. <br />\n<code>multiply</code>:  Multiply two splines together.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.split", "modulename": "bspy.spline", "qualname": "Spline.split", "kind": "function", "doc": "<p>Split a spline into separate spline pieces.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>minContinuity</strong> (<code>int</code>, optional):\nThe minimum expected continuity of each spline piece. The default is zero, for C0 continuity.</li>\n<li><strong>breaks</strong> (<code>iterable</code> of length <code>nInd</code> or <code>None</code>, optional):\nAn iterable that specifies the breaks at which to separate the spline. \nlen(breaks[ind]) == 0 if there the spline isn't separated for the <code>ind</code> independent variable. \nIf breaks is <code>None</code> (the default), the spline will only be separated at discontinuities.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>splineArray</strong> (array of <code>Spline</code>):\nA array of splines with nInd dimensions containing the spline pieces.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>join</code>:  Join a list of splines together into a single spline.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">minContinuity</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">breaks</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.subtract", "modulename": "bspy.spline", "qualname": "Spline.subtract", "kind": "function", "doc": "<p>Subtract two splines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Spline</code>):\nThe spline to subtract from self. The number of dependent variables must match self.</li>\n<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):\nAn iterable of indices or pairs of indices. Each index refers to an independent variable.\nWithin the iterable, a single index, <code>n</code>, maps the nth independent variable of self to the same independent variable of other.\nA pair <code>(n, m)</code> maps the nth independent variable of self to the mth independent variable of other. \nFor example, if you wanted to compute <code>self(u, v, w) - other(u, w)</code>, you'd pass <code>[0, (2, 1)]</code> for <code>indMap</code>. \nUnmapped independent variables remain independent (the default).\nThe domains of mapped independent variables must match. \nAn independent variable can map to no more than one other independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe result of subtracting other from self.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>add</code>:  Add two splines. <br />\n<code>multiply</code>:  Multiply two splines. <br />\n<code>common_basis</code>:  Align a collection of splines to a common basis, elevating the order and adding knots as needed.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline1 - spline2 with indMap = range(min(spline1.nInd, spline2.nInd)).</p>\n\n<p>Uses <code>common_basis</code> to ensure mapped variables share the same order and knots.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">indMap</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.tangent_space", "modulename": "bspy.spline", "qualname": "Spline.tangent_space", "kind": "function", "doc": "<p>Return the tangent space of the spline. (Same as Jacobian.)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (array-like):\nThe value at which to evaluate the tangent space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tangentSpace</strong> (<code>numpy.array</code>):\nThe nDep x nInd matrix of tangent vectors (tangents are the columns).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.to_dict", "modulename": "bspy.spline", "qualname": "Spline.to_dict", "kind": "function", "doc": "<p>Return a <code>dict</code> with <code>Spline</code> data.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dictionary</strong> (<code>dict</code>):</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>from_dict</code>:  Create a <code>Spline</code> from a data in a <code>dict</code>.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.torus", "modulename": "bspy.spline", "qualname": "Spline.torus", "kind": "function", "doc": "<p>Construct a torus of the given radii.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>innerRadius</strong> (scalar):\nThe desired inner radius of the torus</li>\n<li><strong>outerRadius</strong> (scalar):\nThe desired outer radius of the torus</li>\n<li><strong>tolerance</strong> (scalar, optional):\nThe desired absolute tolerance to which the tolerance should be constructed.  Defaults\nto 1.0e-12 if tolerance == None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA bi-quartic spline approximation to a torus of the specified radii, accurate to\nthe given tolerance.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The resulting mapping is defined over the unit square.  The first independent variable\ncontrols the angular position of the cross sectional circles.  The second independent\nvariable specifies the point on each cross section.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>circular_arc</code>:  Create a 2D circular arc for a given radius and angle accurate to within\na given tolerance. <br />\n<code>add</code>:  Add two splines together. <br />\n<code>multiply</code>:  Multiply two splines together.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">innerRadius</span>, </span><span class=\"param\"><span class=\"n\">outerRadius</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.transform", "modulename": "bspy.spline", "qualname": "Spline.transform", "kind": "function", "doc": "<p>Transform a spline by the given matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>matrix</strong> (array-like):\nAn array of size <code>newNDep</code>x<code>nDep</code> that specifies the transform matrix.</li>\n<li><strong>matrixInverseTranspose</strong> (<code>numpy.array</code>, optional):\nThe inverse transpose of matrix (not used for splines).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe transformed spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>scale</code>:  Scale a spline by the given scalar or scale vector. <br />\n<code>translate</code>:  Translate a spline by the given translation vector.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline @ matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">matrix</span>, </span><span class=\"param\"><span class=\"n\">matrixInverseTranspose</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.translate", "modulename": "bspy.spline", "qualname": "Spline.translate", "kind": "function", "doc": "<p>Translate a spline by the given translation vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>translationVector</strong> (array-like):\nAn array of length <code>nDep</code> that specifies the translation vector.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe translated spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>scale</code>:  Scale a spline by the given scalar or scale vector. <br />\n<code>transform</code>:  Transform a spline by the given matrix.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Equivalent to spline + translationVector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">translationVector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.transpose", "modulename": "bspy.spline", "qualname": "Spline.transpose", "kind": "function", "doc": "<p>Transpose the domain of a spline, changing the order of independent variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>axes</strong> (iterable, optional):\nIf specified, it must be an iterable which contains a permutation of [0,1,\u2026,nInd-1]. \nThe i'th independent variable of the returned spline will correspond to the axes[i] variable of the input. \nIf not specified, defaults to range(nInd)[::-1], which reverses the order of the independent variables.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nTrimmed spline. If all the knots are unchanged, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>numpy.transpose</code>:  Returns an array with axes transposed.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Use spline.transpose(argsort(axes)) to invert the transposition when using the axes argument.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.trim", "modulename": "bspy.spline", "qualname": "Spline.trim", "kind": "function", "doc": "<p>Trim the domain of a spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new lower and upper bounds on each of the independent variables (same form as \nreturned from <code>domain</code>). If a bound is None or nan then the original bound (and knots) are left unchanged.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nTrimmed spline. If all the knots are unchanged, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>domain</code>:  Return the domain of a spline. <br />\n<code>extrapolate</code>:  Extrapolate a spline out to an extended domain maintaining a given order of continuity.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newDomain</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.trimmed_range_bounds", "modulename": "bspy.spline", "qualname": "Spline.trimmed_range_bounds", "kind": "function", "doc": "<p>Return the trimmed range bounds for the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>domainBounds</strong> (array-like):\nAn array with shape (nInd, 2) of lower and upper and lower bounds on each independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>trimmedSpline</strong> (<code>Spline</code>):\nA spline trimmed to the given domain bounds.</li>\n<li><strong>rangeBounds</strong> (<code>np.array</code>):\nThe range of the trimmed spline given as lower and upper bounds on each dependent variable.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>trim</code>:  Trim the domain of a spline. <br />\n<code>range_bounds</code>:  Return the range of a spline as lower and upper bounds on each of the\ndependent variables.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">domainBounds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.unfold", "modulename": "bspy.spline", "qualname": "Spline.unfold", "kind": "function", "doc": "<p>Unfold the coefficients of an original spline's indicated independent variables back into the spline, using the \nindicated independent variables' knots and orders from a second spline with no coefficients.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>foldedInd</strong> (<code>iterable</code>):\nAn iterable that specifies the independent variables whose coefficients should be unfolded.</li>\n<li><strong>coefficientlessSpline</strong> (<code>Spline</code>):\nThe coefficientless spline that retains the indicated independent variables' knots and orders.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>unfoldedSpline</strong> (<code>Spline</code>, <code>Spline</code>):\nThe unfolded spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>fold</code>:  Fold the coefficients of a spline's indicated independent variables into the coefficients of the remaining independent variables.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.\nThe first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, \nall of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline \nwith 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, \nreturning the original spline.</p>\n\n<p>Here's an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. \nThen spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have \nshape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn't matter \nso long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">foldedInd</span>, </span><span class=\"param\"><span class=\"n\">coefficientlessSpline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.zeros", "modulename": "bspy.spline", "qualname": "Spline.zeros", "kind": "function", "doc": "<p>Find the roots of a spline (nInd must match nDep).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>epsilon</strong> (<code>float</code>, optional):\nTolerance for root precision. The root will be within epsilon of the actual root. \nThe default is the machine epsilon.</li>\n<li><strong>initialScale</strong> (array-like, optional):\nThe initial scale of each dependent variable (as opposed to the current scale of \nthe spline, which may have been normalized). The default is an array of ones (size nDep).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>roots</strong> (<code>iterable</code>):\nAn iterable containing the roots of the spline. If the spline is \nzero over an interval, that root will appear as a tuple of the interval. \nFor curves (nInd == 1), the roots are ordered.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>intersect</code>:  Intersect two splines. <br />\n<code>contours</code>:  Find all the contour curves of a spline whose <code>nInd</code> is one larger than its <code>nDep</code>.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>For curves (nInd == 1), it implements interval Newton's method from Grandine, Thomas A. \"Computing zeroes of spline functions.\" \nComputer Aided Geometric Design 6, no. 2 (1989): 129-136.\nFor all higher dimensions, it implements the projected-polyhedron technique from Sherbrooke, Evan C., and Nicholas M. Patrikalakis. \n\"Computation of the solutions of nonlinear polynomial systems.\" Computer Aided Geometric Design 10, no. 5 (1993): 379-405.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">initialScale</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame", "modulename": "bspy.splineOpenGLFrame", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame", "kind": "class", "doc": "<p>A tkinter <code>OpenGLFrame</code> with shaders to display a <code>Spline</code>.</p>\n", "bases": "pyopengltk.win32.OpenGLFrame"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.__init__", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.__init__", "kind": "function", "doc": "<p>Construct a frame widget with the parent MASTER.</p>\n\n<p>Valid resource names: background, bd, bg, borderwidth, class,\ncolormap, container, cursor, height, highlightbackground,\nhighlightcolor, highlightthickness, relief, takefocus, visual, width.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"n\">eye</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">center</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">up</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">draw_func</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kw</span></span>)</span>"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.ROTATE", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.ROTATE", "kind": "variable", "doc": "<p>Default view mode in which dragging the left mouse rotates the view.</p>\n", "default_value": "1"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.PAN", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.PAN", "kind": "variable", "doc": "<p>View mode in which dragging the left mouse pans the view.</p>\n", "default_value": "2"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.FLY", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.FLY", "kind": "variable", "doc": "<p>View mode in which dragging the left mouse flies toward the mouse position.</p>\n", "default_value": "3"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MsPerFrame", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MsPerFrame", "kind": "variable", "doc": "<p>Milliseconds per frame when animating or flying.</p>\n", "default_value": "50"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.maxOrder", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.maxOrder", "kind": "variable", "doc": "<p>Maximum order for drawable splines.</p>\n", "default_value": "9"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.maxCoefficients", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.maxCoefficients", "kind": "variable", "doc": "<p>Maximum number of coefficients for drawable splines.</p>\n", "default_value": "120"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.maxKnots", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.maxKnots", "kind": "variable", "doc": "<p>Maximum number of knots for drawable splines.</p>\n", "default_value": "129"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.HULL", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.HULL", "kind": "variable", "doc": "<p>Option to draw the convex hull of the spline (the coefficients). Off by default.</p>\n", "default_value": "1"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SHADED", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SHADED", "kind": "variable", "doc": "<p>Option to draw the spline shaded (only useful for nInd &gt;= 2). On by default.</p>\n", "default_value": "2"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.BOUNDARY", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.BOUNDARY", "kind": "variable", "doc": "<p>Option to draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</p>\n", "default_value": "4"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.ISOPARMS", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.ISOPARMS", "kind": "variable", "doc": "<p>Option to draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</p>\n", "default_value": "8"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeBSplineCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeBSplineCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        void ComputeBSpline(in int offset, in int order, in int n, in int knot, in float u, \\n            out float uBSpline[{maxOrder}], out float duBSpline[{maxOrder}])\\n        {{\\n            int degree = 1;\\n\\n            for (int i = 0; i &lt; {maxOrder}; i++)\\n            {{\\n                uBSpline[i] = 0.0;\\n                duBSpline[i] = 0.0;\\n            }}\\n            uBSpline[order-1] = 1.0;\\n\\n            while (degree &lt; order - 1)\\n            {{\\n                int b = order - degree;\\n                for (int i = knot - degree; i &lt; knot; i++)\\n                {{\\n                    float knotValue = texelFetch(uSplineData, offset + i).x; // knots[i]\\n                    float alpha = (u - knotValue) / (texelFetch(uSplineData, offset + i + degree).x - knotValue); // (u - knots[i]) / (knots[i+degree] - knots[i]);\\n                    uBSpline[b-1] += (1.0 - alpha) * uBSpline[b];\\n                    uBSpline[b] *= alpha;\\n                    b++;\\n                }}\\n                degree++;\\n            }}\\n            if (degree &lt; order)\\n            {{\\n                int b = order - degree;\\n                for (int i = knot - degree; i &lt; knot; i++)\\n                {{\\n                    float knotValue = texelFetch(uSplineData, offset + i).x; // knots[i]\\n                    float gap = texelFetch(uSplineData, offset + i + degree).x - knotValue; // knots[i+degree] - knots[i]\\n                    float alpha = degree / gap;\\n                    duBSpline[b-1] += -alpha * uBSpline[b];\\n                    duBSpline[b] = alpha * uBSpline[b];\\n\\n                    alpha = (u - knotValue) / gap; // (u - knots[i]) / gap;\\n                    uBSpline[b-1] += (1.0 - alpha) * uBSpline[b];\\n                    uBSpline[b] *= alpha;\\n                    b++;\\n                }}\\n            }}\\n        }}\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeSampleRateCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeSampleRateCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        float ComputeSampleRate(in vec3 point, in vec3 dPoint, in vec3 d2Point, in float minRate)\\n        {\\n            float rate = 0.0;\\n            float scale = uScreenScale.z &gt; 0.0 ? -point.z : 1.0;\\n\\n            // Only consider points that lie within the clip bounds or whose derivative spans the clip bounds.\\n            if (point.z &lt; uClipBounds[3] &amp;&amp; point.z &gt; uClipBounds[2] &amp;&amp; \\n                ((point.y &lt; scale * uClipBounds[1] &amp;&amp; point.y &gt; -scale * uClipBounds[1]) ||\\n                (point.y &gt;= scale * uClipBounds[1] &amp;&amp; point.y + dPoint.y &lt;= -scale * uClipBounds[1]) ||\\n                (point.y &lt;= -scale * uClipBounds[1] &amp;&amp; point.y + dPoint.y &gt;= scale * uClipBounds[1])) &amp;&amp;\\n                ((point.x &lt; scale * uClipBounds[0] &amp;&amp; point.x &gt; -scale * uClipBounds[0]) ||\\n                (point.x &gt;= scale * uClipBounds[0] &amp;&amp; point.x + dPoint.x &lt;= -scale * uClipBounds[0]) ||\\n                (point.x &lt;= -scale * uClipBounds[0] &amp;&amp; point.x + dPoint.x &gt;= scale * uClipBounds[0])))\\n            {\\n                float zScale = -1.0 / point.z;\\n                float zScale2 = zScale * zScale;\\n                float zScale3 = zScale2 * zScale;\\n                vec2 projection = uScreenScale.z &gt; 0.0 ? \\n                    vec2(uScreenScale.x * (d2Point.x * zScale - 2.0 * dPoint.x * dPoint.z * zScale2 +\\n                        point.x * (2.0 * dPoint.z * dPoint.z * zScale3 - d2Point.z * zScale2)),\\n                        uScreenScale.y * (d2Point.y * zScale - 2.0 * dPoint.y * dPoint.z * zScale2 +\\n                        point.y * (2.0 * dPoint.z * dPoint.z * zScale3 - d2Point.z * zScale2)))\\n                    : vec2(uScreenScale.x * d2Point.x, uScreenScale.y * d2Point.y);\\n                rate = max(sqrt(length(projection)), minRate);\\n            }\\n            return rate;\\n        }\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveVertexShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveVertexShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n     \\n        const int header = 2;\\n\\n        attribute vec4 aParameters;\\n\\n        uniform samplerBuffer uSplineData;\\n\\n        out SplineInfo\\n        {\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        } outData;\\n\\n        void main()\\n        {\\n            outData.uOrder = int(texelFetch(uSplineData, 0).x);\\n            outData.uN = int(texelFetch(uSplineData, 1).x);\\n            outData.uKnot = min(gl_InstanceID + outData.uOrder, outData.uN);\\n            outData.u = texelFetch(uSplineData, header + outData.uKnot - 1).x; // knots[uKnot-1]\\n            outData.uInterval = texelFetch(uSplineData, header + outData.uKnot).x - outData.u; // knots[uKnot] - knots[uKnot-1]\\n            gl_Position = aParameters;\\n        }\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeCurveSamplesCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeCurveSamplesCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&quot;\\n        void ComputeCurveSamples(in int maxSamples, out float uSamples)\\n        {\\n            float sampleRate = 0.0;\\n            if (outData.uInterval &gt; 0.0)\\n            {\\n                float minRate = 1.0 / outData.uInterval;\\n                if (outData.uOrder &lt; 3)\\n                {\\n                    // It&#x27;s a line or point, so just do the minimum sample.\\n                    sampleRate = minRate;\\n                }\\n                else\\n                {\\n                    int i = outData.uKnot - outData.uOrder;\\n                    int coefficientOffset = header + outData.uOrder + outData.uN + nDep * i;\\n                    vec3 coefficient0 = vec3(\\n                        texelFetch(uSplineData, coefficientOffset+0).x, \\n                        texelFetch(uSplineData, coefficientOffset+1).x,\\n                        texelFetch(uSplineData, coefficientOffset+2).x);\\n                    coefficientOffset += nDep;\\n                    vec3 coefficient1 = vec3(\\n                        texelFetch(uSplineData, coefficientOffset+0).x, \\n                        texelFetch(uSplineData, coefficientOffset+1).x,\\n                        texelFetch(uSplineData, coefficientOffset+2).x);\\n                    float gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+1).x; // uKnots[i+uOrder] - uKnots[i+1]\\n                    vec3 dPoint0 = ((outData.uOrder - 1) / gap) * (coefficient1 - coefficient0);\\n                    while (i &lt; outData.uKnot-2)\\n                    {\\n                        coefficientOffset += nDep;\\n                        vec3 coefficient2 = vec3(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x);\\n                        gap = texelFetch(uSplineData, header + i+1+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+1+uOrder] - uKnots[i+2]\\n                        vec3 dPoint1 = ((outData.uOrder - 1) / gap) * (coefficient2 - coefficient1);\\n                        gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+uOrder] - uKnots[i+2]\\n                        vec3 d2Point = ((outData.uOrder - 2) / gap) * (dPoint1 - dPoint0);\\n\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient0, dPoint0, d2Point, minRate));\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient1, dPoint0, d2Point, minRate));\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient1, dPoint1, d2Point, minRate));\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient2, dPoint1, d2Point, minRate));\\n\\n                        coefficient0 = coefficient1;\\n                        coefficient1 = coefficient2;\\n                        dPoint0 = dPoint1;\\n                        i++;\\n                    }\\n                }\\n            }\\n            uSamples = min(floor(0.5 + outData.uInterval * sampleRate), maxSamples);\\n        }\\n    &quot;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveTCShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveTCShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n\\n        layout (vertices = 1) out;\\n\\n        const int header = 2;\\n        const int nDep = 3;\\n\\n        in SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} inData[];\\n\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform samplerBuffer uSplineData;\\n\\n        patch out SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} outData;\\n\\n        {computeSampleRateCode}\\n\\n        {computeCurveSamplesCode}\\n\\n        void main()\\n        {{\\n            outData = inData[gl_InvocationID];\\n            gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;\\n\\n            float uSamples = 0.0;\\n            ComputeCurveSamples(gl_MaxTessGenLevel, uSamples);\\n            gl_TessLevelOuter[0] = 1.0;\\n            gl_TessLevelOuter[1] = uSamples;\\n        }}\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveTEShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveTEShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n\\n        layout (isolines) in;\\n\\n        const int header = 2;\\n        const int nDep = 3;\\n\\n        patch in SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} inData;\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform samplerBuffer uSplineData;\\n\\n        {computeBSplineCode}\\n\\n        void main()\\n        {{\\n            float uBSpline[{maxOrder}];\\n            float duBSpline[{maxOrder}];\\n            ComputeBSpline(header, inData.uOrder, inData.uN, inData.uKnot,\\n                inData.u + gl_TessCoord.x * inData.uInterval, \\n                uBSpline, duBSpline);\\n            \\n            vec4 point = vec4(0.0, 0.0, 0.0, 1.0);\\n            int i = header + inData.uOrder + inData.uN + nDep * (inData.uKnot - inData.uOrder);\\n            for (int b = 0; b &lt; inData.uOrder; b++) // loop from coefficient[uKnot-order] to coefficient[uKnot]\\n            {{\\n                point.x += uBSpline[b] * texelFetch(uSplineData, i).x;\\n                point.y += uBSpline[b] * texelFetch(uSplineData, i+1).x;\\n                point.z += uBSpline[b] * texelFetch(uSplineData, i+2).x;\\n                i += nDep;\\n            }}\\n\\n            gl_Position = uProjectionMatrix * point;\\n        }}\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveGeometryShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveGeometryShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&quot;\\n        #version 330 core\\n\\n        layout( points ) in;\\n        layout( line_strip, max_vertices = 256 ) out;\\n\\n        const int header = 2;\\n        const int nDep = 3;\\n\\n        in SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} inData[];\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform samplerBuffer uSplineData;\\n\\n        struct SplineInfoStruct\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} outData; // We don&#x27;t output outData (too many components per vertex), but we do use it in ComputeCurveSamples.\\n\\n        {computeSampleRateCode}\\n\\n        {computeCurveSamplesCode}\\n\\n        {computeBSplineCode}\\n\\n        void main()\\n        {{\\n            float uSamples = 0.0;\\n\\n            outData.uOrder = inData[0].uOrder;\\n            outData.uN = inData[0].uN;\\n            outData.uKnot = inData[0].uKnot;\\n            outData.u = inData[0].u;\\n            outData.uInterval = inData[0].uInterval;\\n            ComputeCurveSamples(gl_MaxGeometryOutputVertices - 1, uSamples);\\n\\n            if (uSamples &gt; 0.0)\\n            {{\\n                float uBSpline[{maxOrder}];\\n                float duBSpline[{maxOrder}];\\n                float u = outData.u;\\n                float deltaU = outData.uInterval / uSamples;\\n                int iOffset = header + outData.uOrder + outData.uN + nDep * (outData.uKnot - outData.uOrder);\\n\\n                for (int uSample = 0; uSample &lt;= uSamples; uSample++)\\n                {{\\n                    ComputeBSpline(header, outData.uOrder, outData.uN, outData.uKnot,\\n                        u, uBSpline, duBSpline);\\n                    \\n                    vec4 point = vec4(0.0, 0.0, 0.0, 1.0);\\n                    int i = iOffset;\\n                    for (int b = 0; b &lt; outData.uOrder; b++) // loop from coefficient[uKnot-order] to coefficient[uKnot]\\n                    {{\\n                        point.x += uBSpline[b] * texelFetch(uSplineData, i).x;\\n                        point.y += uBSpline[b] * texelFetch(uSplineData, i+1).x;\\n                        point.z += uBSpline[b] * texelFetch(uSplineData, i+2).x;\\n                        i += nDep;\\n                    }}\\n\\n                    gl_Position = uProjectionMatrix * point;\\n                    EmitVertex();\\n                    u += deltaU;                    \\n                }}\\n                EndPrimitive();\\n            }}\\n        }}\\n    &quot;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveFragmentShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveFragmentShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n     \\n        uniform vec4 uLineColor;\\n\\n        out vec4 color;\\n     \\n        void main()\\n        {\\n            color = uLineColor;\\n        }\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceVertexShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceVertexShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n\\n        const int header = 4;\\n     \\n        attribute vec4 aParameters;\\n\\n        uniform samplerBuffer uSplineData;\\n\\n        out SplineInfo\\n        {\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        } outData;\\n\\n        void main()\\n        {\\n            outData.uOrder = int(texelFetch(uSplineData, 0).x);\\n            outData.vOrder = int(texelFetch(uSplineData, 1).x);\\n            outData.uN = int(texelFetch(uSplineData, 2).x);\\n            outData.vN = int(texelFetch(uSplineData, 3).x);\\n            int stride = outData.uN - outData.uOrder + 1;\\n            int strides = gl_InstanceID / stride;\\n\\n            outData.uKnot = gl_InstanceID - stride * strides + outData.uOrder;\\n            outData.vKnot = strides + outData.vOrder;\\n            outData.uFirst = texelFetch(uSplineData, header + outData.uOrder - 1).x; // uKnots[uOrder-1]\\n            outData.vFirst = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vOrder - 1).x; // vKnots[vOrder-1]\\n            outData.uSpan = texelFetch(uSplineData, header + outData.uN).x - outData.uFirst; // uKnots[uN] - uKnots[uOrder-1]\\n            outData.vSpan = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vN).x - outData.vFirst; // vKnots[vN] - vKnots[vOrder-1]\\n            outData.u = texelFetch(uSplineData, header + outData.uKnot - 1).x; // uKnots[uKnot-1]\\n            outData.v = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vKnot - 1).x; // vKnots[vKnot-1]\\n            outData.uInterval = texelFetch(uSplineData, header + outData.uKnot).x - outData.u; // uKnots[uKnot] - uKnots[uKnot-1]\\n            outData.vInterval = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vKnot).x - outData.v; // vKnots[vKnot] - vKnots[vKnot-1]\\n            gl_Position = aParameters;\\n        }\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeSurfaceSamplesCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeSurfaceSamplesCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&quot;\\n        void ComputeSurfaceSamples(in int maxSamples, out float uSamples[3], out float vSamples[3])\\n        {{\\n            // Computes sample counts for u and v for the left side ([0]), middle ([1]), and right side ([2]).\\n            // The left side sample count matches the right side sample count for the previous knot.\\n            // The middle sample count is the number of samples between knots (same as ComputeCurveSamples).\\n            float sampleRate[3] = float[3](0.0, 0.0, 0.0);\\n            if (outData.uInterval &gt; 0.0)\\n            {{\\n                float minRate = 1.0 / outData.uInterval;\\n                if (outData.uOrder &lt; 3)\\n                {{\\n                    // It&#x27;s a plane or point, so just do the minimum sample.\\n                    sampleRate = float[3](minRate, minRate, minRate);\\n                }}\\n                else\\n                {{\\n                    float sampleRateLeft[{maxOrder}];\\n                    float sampleRateRight[{maxOrder}];\\n\\n                    for (int k = 0; k &lt; outData.uOrder; k++)\\n                    {{\\n                        sampleRateLeft[k] = 0.0;\\n                        sampleRateRight[k] = 0.0;\\n                    }}\\n                    for (int j = outData.vKnot-outData.vOrder; j &lt; outData.vKnot; j++)\\n                    {{\\n                        int i = max(outData.uKnot - 1 - outData.uOrder, 0);\\n                        int iLimit = min(outData.uKnot - 1, outData.uN - 2);\\n                        int coefficientOffset = header + outData.uOrder+outData.uN + outData.vOrder+outData.vN + nDep*outData.uN*j + nDep*i;\\n                        vec3 coefficient0 = vec3(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x);\\n                        coefficientOffset += nDep;\\n                        vec3 coefficient1 = vec3(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x);\\n                        float gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+1).x; // uKnots[i+uOrder] - uKnots[i+1]\\n                        vec3 dPoint0 = ((outData.uOrder - 1) / gap) * (coefficient1 - coefficient0);\\n                        while (i &lt; iLimit)\\n                        {{\\n                            coefficientOffset += nDep;\\n                            vec3 coefficient2 = vec3(\\n                                texelFetch(uSplineData, coefficientOffset+0).x, \\n                                texelFetch(uSplineData, coefficientOffset+1).x,\\n                                texelFetch(uSplineData, coefficientOffset+2).x);\\n                            gap = texelFetch(uSplineData, header + i+1+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+1+uOrder] - uKnots[i+2]\\n                            vec3 dPoint1 = ((outData.uOrder - 1) / gap) * (coefficient2 - coefficient1);\\n                            gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+uOrder] - uKnots[i+2]\\n                            vec3 d2Point = ((outData.uOrder - 2) / gap) * (dPoint1 - dPoint0);\\n\\n                            int k = i - outData.uKnot + 1 + outData.uOrder;\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient0, dPoint0, d2Point, minRate));\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient1, dPoint0, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient1, dPoint1, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient2, dPoint1, d2Point, minRate));\\n\\n                            coefficient0 = coefficient1;\\n                            coefficient1 = coefficient2;\\n                            dPoint0 = dPoint1;\\n                            i++;\\n                        }}\\n                    }}\\n                    for (int k = 1; k &lt; outData.uOrder - 1; k++)\\n                    {{\\n                        sampleRate[0] = max(sampleRate[0], sampleRateRight[k-1]);\\n                        sampleRate[0] = max(sampleRate[0], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateLeft[k+1]);\\n                    }}\\n                }}\\n            }}\\n            uSamples[0] = min(floor(0.5 + outData.uInterval * sampleRate[0]), maxSamples);\\n            uSamples[1] = min(floor(0.5 + outData.uInterval * sampleRate[1]), maxSamples);\\n            uSamples[2] = min(floor(0.5 + outData.uInterval * sampleRate[2]), maxSamples);\\n\\n            sampleRate = float[3](0.0, 0.0, 0.0);\\n            if (outData.vInterval &gt; 0.0)\\n            {{\\n                float minRate = 1.0 / outData.vInterval;\\n                if (outData.vOrder &lt; 3)\\n                {{\\n                    // It&#x27;s a plane or point, so just do the minimum sample.\\n                    sampleRate = float[3](minRate, minRate, minRate);\\n                }}\\n                else\\n                {{\\n                    float sampleRateLeft[{maxOrder}];\\n                    float sampleRateRight[{maxOrder}];\\n\\n                    for (int k = 0; k &lt; outData.vOrder; k++)\\n                    {{\\n                        sampleRateLeft[k] = 0.0;\\n                        sampleRateRight[k] = 0.0;\\n                    }}\\n                    for (int i = outData.uKnot-outData.uOrder; i &lt; outData.uKnot; i++)\\n                    {{\\n                        int j = max(outData.vKnot - 1 - outData.vOrder, 0);\\n                        int jLimit = min(outData.vKnot - 1, outData.vN - 2);\\n                        int coefficientOffset = header + outData.uOrder+outData.uN + outData.vOrder+outData.vN + nDep*outData.uN*j + nDep*i;\\n                        vec3 coefficient0 = vec3(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x);\\n                        coefficientOffset += nDep*outData.uN;\\n                        vec3 coefficient1 = vec3(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x);\\n                        float gap = texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+outData.vOrder).x - texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+1).x; // vKnots[j+vOrder] - vKnots[j+1]\\n                        vec3 dPoint0 = ((outData.vOrder - 1) / gap) * (coefficient1 - coefficient0);\\n                        while (j &lt; jLimit)\\n                        {{\\n                            coefficientOffset += nDep*outData.uN;\\n                            vec3 coefficient2 = vec3(\\n                                texelFetch(uSplineData, coefficientOffset+0).x, \\n                                texelFetch(uSplineData, coefficientOffset+1).x,\\n                                texelFetch(uSplineData, coefficientOffset+2).x);\\n                            gap = texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+1+outData.vOrder).x - texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+2).x; // vKnots[j+1+vOrder] - vKnots[j+2]\\n                            vec3 dPoint1 = ((outData.vOrder - 1) / gap) * (coefficient2 - coefficient1);\\n                            gap = texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+outData.vOrder).x - texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+2).x; // vKnots[j+vOrder] - vKnots[j+2]\\n                            vec3 d2Point = ((outData.vOrder - 2) / gap) * (dPoint1 - dPoint0);\\n\\n                            int k = j - outData.vKnot + 1 + outData.vOrder;\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient0, dPoint0, d2Point, minRate));\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient1, dPoint0, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient1, dPoint1, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient2, dPoint1, d2Point, minRate));\\n\\n                            coefficient0 = coefficient1;\\n                            coefficient1 = coefficient2;\\n                            dPoint0 = dPoint1;\\n                            j++;\\n                        }}\\n                    }}\\n                    for (int k = 1; k &lt; outData.vOrder - 1; k++)\\n                    {{\\n                        sampleRate[0] = max(sampleRate[0], sampleRateRight[k-1]);\\n                        sampleRate[0] = max(sampleRate[0], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateLeft[k+1]);\\n                    }}\\n                }}\\n            }}\\n            vSamples[0] = min(floor(0.5 + outData.vInterval * sampleRate[0]), maxSamples);\\n            vSamples[1] = min(floor(0.5 + outData.vInterval * sampleRate[1]), maxSamples);\\n            vSamples[2] = min(floor(0.5 + outData.vInterval * sampleRate[2]), maxSamples);\\n        }}\\n    &quot;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceTCShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceTCShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n\\n        layout (vertices = 1) out;\\n\\n        const int header = 4;\\n        const int nDep = {nDep};\\n\\n        in SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} inData[];\\n\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform samplerBuffer uSplineData;\\n\\n        patch out SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} outData;\\n\\n        {computeSampleRateCode}\\n\\n        {computeSurfaceSamplesCode}\\n\\n        void main()\\n        {{\\n            outData = inData[gl_InvocationID];\\n            gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;\\n\\n            float uSamples[3];\\n            float vSamples[3];\\n            ComputeSurfaceSamples(gl_MaxTessGenLevel, uSamples, vSamples);\\n            gl_TessLevelOuter[0] = vSamples[0] &gt; 0.0 ? vSamples[0] : vSamples[1];\\n            gl_TessLevelOuter[1] = uSamples[0] &gt; 0.0 ? uSamples[0] : uSamples[1];\\n            gl_TessLevelOuter[2] = vSamples[2] &gt; 0.0 ? vSamples[2] : vSamples[1];\\n            gl_TessLevelOuter[3] = uSamples[2] &gt; 0.0 ? uSamples[2] : uSamples[1];\\n            gl_TessLevelInner[0] = uSamples[1];\\n            gl_TessLevelInner[1] = vSamples[1];\\n        }}\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceTEShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceTEShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n\\n        layout (quads) in;\\n\\n        const int header = 4;\\n        const int nDep = {nDep};\\n\\n        patch in SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} inData;\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uFillColor;\\n        uniform samplerBuffer uSplineData;\\n\\n        flat out SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} outData;\\n        out vec3 worldPosition;\\n        out vec3 splineColor;\\n        out vec3 normal;\\n        out vec2 parameters;\\n        out vec2 pixelPer;\\n\\n        {computeBSplineCode}\\n\\n        void main()\\n        {{\\n            float uBSpline[{maxOrder}];\\n            float duBSpline[{maxOrder}];\\n            parameters.x = inData.u + gl_TessCoord.x * inData.uInterval;\\n            ComputeBSpline(header, inData.uOrder, inData.uN, inData.uKnot, parameters.x, uBSpline, duBSpline);\\n\\n            float vBSpline[{maxOrder}];\\n            float dvBSpline[{maxOrder}];\\n            parameters.y = inData.v + gl_TessCoord.y * inData.vInterval;\\n            ComputeBSpline(header + inData.uOrder+inData.uN, inData.vOrder, inData.vN, inData.vKnot, parameters.y, vBSpline, dvBSpline);\\n\\n            {splineColorDeclarations}\\n\\n            vec4 point = vec4(0.0, 0.0, 0.0, 1.0);\\n            vec3 duPoint = vec3(0.0, 0.0, 0.0);\\n            vec3 dvPoint = vec3(0.0, 0.0, 0.0);\\n            {initializeSplineColor}\\n            int j = header + inData.uOrder+inData.uN + inData.vOrder+inData.vN + (inData.vKnot - inData.vOrder) * inData.uN * nDep;\\n            for (int vB = 0; vB &lt; inData.vOrder; vB++)\\n            {{\\n                int i = j + (inData.uKnot - inData.uOrder) * nDep;\\n                for (int uB = 0; uB &lt; inData.uOrder; uB++)\\n                {{\\n                    point.x += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                    point.y += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                    point.z += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                    duPoint.x += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                    duPoint.y += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                    duPoint.z += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                    dvPoint.x += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i).x;\\n                    dvPoint.y += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                    dvPoint.z += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                    {computeSplineColor}\\n                    i += nDep;\\n                }}\\n                j += inData.uN * nDep;\\n            }}\\n            {postProcessSplineColor}\\n\\n            outData = inData;\\n\\n            worldPosition = point.xyz;\\n            normal = normalize(cross(duPoint, dvPoint));\\n            float zScale = 1.0 / (point.z * point.z);\\n            pixelPer.x = zScale * max(uScreenScale.x * abs(point.x * duPoint.z - duPoint.x * point.z), uScreenScale.y * abs(point.y * duPoint.z - duPoint.y * point.z));\\n            pixelPer.y = zScale * max(uScreenScale.x * abs(point.x * dvPoint.z - dvPoint.x * point.z), uScreenScale.y * abs(point.y * dvPoint.z - dvPoint.y * point.z));\\n            gl_Position = uProjectionMatrix * point;\\n        }}\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceGeometryShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceGeometryShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&quot;\\n        #version 330 core\\n\\n        layout( points ) in;\\n        layout( triangle_strip, max_vertices = 256 ) out;\\n\\n        const int header = 4;\\n        const int nDep = {nDep};\\n\\n        in SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} inData[];\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform vec4 uFillColor;\\n        uniform vec3 uLightDirection;\\n        uniform samplerBuffer uSplineData;\\n\\n        out vec3 splineColor; // We restrict our output to color to reduce the number of components per vertex.\\n\\n        struct SplineInfoStruct\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} outData; // We don&#x27;t output outData (too many components per vertex), but we do use it in ComputeSurfaceSamples.\\n\\n        {computeSampleRateCode}\\n\\n        {computeSurfaceSamplesCode}\\n\\n        {computeBSplineCode}\\n\\n        void main() \\n        {{\\n            float uFullSamples[3];\\n            float vFullSamples[3];\\n\\n            outData.uOrder = inData[0].uOrder;\\n            outData.vOrder = inData[0].vOrder;\\n            outData.uN = inData[0].uN;\\n            outData.vN = inData[0].vN;\\n            outData.uKnot = inData[0].uKnot;\\n            outData.vKnot = inData[0].vKnot;\\n            outData.u = inData[0].u;\\n            outData.v = inData[0].v;\\n            outData.uInterval = inData[0].uInterval;\\n            outData.vInterval = inData[0].vInterval;\\n            int maxVertices = gl_MaxGeometryTotalOutputComponents / 7; // The number of output components per vertex is 7 = position.xyzw + splineColor.rgb\\n            ComputeSurfaceSamples(maxVertices, uFullSamples, vFullSamples);\\n\\n            if (uFullSamples[1] &gt; 0.0 &amp;&amp; vFullSamples[1] &gt; 0.0)\\n            {{\\n                float alpha = maxVertices / (2.0 * uFullSamples[1] * (vFullSamples[1] + 1.0));\\n                if (alpha &lt; 1.0)\\n                {{\\n                    alpha = sqrt(alpha);\\n                    uFullSamples[1] = alpha * uFullSamples[1];\\n                    vFullSamples[1] = alpha * (vFullSamples[1] + 1.0) - 1.0;\\n                }}\\n                int uSamples = int(uFullSamples[1]);\\n                int vSamples = int(vFullSamples[1]);\\n\\n                {splineColorDeclarations}\\n\\n                float uBSpline[{maxOrder}];\\n                float duBSpline[{maxOrder}];\\n                float uBSplineNext[{maxOrder}];\\n                float duBSplineNext[{maxOrder}];\\n                float vBSpline[{maxOrder}];\\n                float dvBSpline[{maxOrder}];\\n                float deltaU = outData.uInterval / uSamples;\\n                float deltaV = outData.vInterval / vSamples;\\n                float u = outData.u;\\n                ComputeBSpline(header, outData.uOrder, outData.uN, outData.uKnot, u, uBSpline, duBSpline);\\n\\n                int jOffset = header + outData.uOrder+outData.uN + outData.vOrder+outData.vN + (outData.vKnot - outData.vOrder) * outData.uN * nDep;\\n                int iOffset = (outData.uKnot - outData.uOrder) * nDep;\\n\\n                for (int uSample = 0; uSample &lt; uSamples; uSample++)\\n                {{\\n                    float uNext = u + deltaU;\\n                    ComputeBSpline(header, outData.uOrder, outData.uN, outData.uKnot, uNext, uBSplineNext, duBSplineNext);\\n                        \\n                    float v = outData.v;\\n                    for (int vSample = 0; vSample &lt;= vSamples; vSample++)\\n                    {{\\n                        ComputeBSpline(header + outData.uOrder+outData.uN, outData.vOrder, outData.vN, outData.vKnot, v, vBSpline, dvBSpline);\\n\\n                        vec4 point = vec4(0.0, 0.0, 0.0, 1.0);\\n                        vec3 duPoint = vec3(0.0, 0.0, 0.0);\\n                        vec3 dvPoint = vec3(0.0, 0.0, 0.0);\\n                        {initializeSplineColor}\\n                        int j = jOffset;\\n                        for (int vB = 0; vB &lt; outData.vOrder; vB++)\\n                        {{\\n                            int i = j + iOffset;\\n                            for (int uB = 0; uB &lt; outData.uOrder; uB++)\\n                            {{\\n                                point.x += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                point.y += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                point.z += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                duPoint.x += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                duPoint.y += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                duPoint.z += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                dvPoint.x += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                dvPoint.y += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                dvPoint.z += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                {computeSplineColor}\\n                                i += nDep;\\n                            }}\\n                            j += outData.uN * nDep;\\n                        }}\\n                        {postProcessSplineColor}\\n                        vec3 normal = normalize(cross(duPoint, dvPoint));\\n                        float specular = pow(abs(dot(normal, normalize(uLightDirection + point.xyz / length(point)))), 25.0);\\n                        splineColor = (0.3 + 0.5 * abs(dot(normal, uLightDirection)) + 0.2 * specular) * splineColor;\\n                        gl_Position = uProjectionMatrix * point;\\n                        EmitVertex();\\n\\n                        point = vec4(0.0, 0.0, 0.0, 1.0);\\n                        duPoint = vec3(0.0, 0.0, 0.0);\\n                        dvPoint = vec3(0.0, 0.0, 0.0);\\n                        {initializeSplineColor}\\n                        j = jOffset;\\n                        for (int vB = 0; vB &lt; outData.vOrder; vB++)\\n                        {{\\n                            int i = j + iOffset;\\n                            for (int uB = 0; uB &lt; outData.uOrder; uB++)\\n                            {{\\n                                point.x += uBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                point.y += uBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                point.z += uBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                duPoint.x += duBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                duPoint.y += duBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                duPoint.z += duBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                dvPoint.x += uBSplineNext[uB] * dvBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                dvPoint.y += uBSplineNext[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                dvPoint.z += uBSplineNext[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                {computeSplineColor}\\n                                i += nDep;\\n                            }}\\n                            j += outData.uN * nDep;\\n                        }}\\n                        {postProcessSplineColor}\\n                        normal = normalize(cross(duPoint, dvPoint));\\n                        specular = pow(abs(dot(normal, normalize(uLightDirection + point.xyz / length(point)))), 25.0);\\n                        splineColor = (0.3 + 0.5 * abs(dot(normal, uLightDirection)) + 0.2 * specular) * splineColor;\\n                        gl_Position = uProjectionMatrix * point;\\n                        EmitVertex();\\n\\n                        v += deltaV;                    \\n                    }}\\n                    EndPrimitive();\\n                    u = uNext;\\n                    uBSpline = uBSplineNext;\\n                    duBSpline = duBSplineNext;\\n                }}\\n            }}\\n        }}\\n    &quot;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceSimpleFragmentShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceSimpleFragmentShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 330 core\\n     \\n        in vec3 splineColor;\\n        uniform vec4 uFillColor;\\n        out vec4 color;\\n     \\n        void main() {\\n            color = vec4(splineColor, uFillColor.a);\\n        }\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceFragmentShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceFragmentShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n     \\n        flat in SplineInfo\\n        {\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        } inData;\\n        in vec3 worldPosition;\\n        in vec3 splineColor;\\n        in vec3 normal;\\n        in vec2 parameters;\\n        in vec2 pixelPer;\\n\\n        uniform vec4 uFillColor;\\n        uniform vec4 uLineColor;\\n        uniform vec3 uLightDirection;\\n        uniform int uOptions;\\n\\n        out vec4 color;\\n     \\n        void main()\\n        {\\n            float specular = pow(abs(dot(normal, normalize(uLightDirection + worldPosition / length(worldPosition)))), 25.0);\\n            bool line = (uOptions &amp; (1 &lt;&lt; 2)) &gt; 0 &amp;&amp; (pixelPer.x * (parameters.x - inData.uFirst) &lt; 1.5 || pixelPer.x * (inData.uFirst + inData.uSpan - parameters.x) &lt; 1.5);\\n            line = line || ((uOptions &amp; (1 &lt;&lt; 2)) &gt; 0 &amp;&amp; (pixelPer.y * (parameters.y - inData.vFirst) &lt; 1.5 || pixelPer.y * (inData.vFirst + inData.vSpan - parameters.y) &lt; 1.5));\\n            line = line || ((uOptions &amp; (1 &lt;&lt; 3)) &gt; 0 &amp;&amp; pixelPer.x * (parameters.x - inData.u) &lt; 1.5);\\n            line = line || ((uOptions &amp; (1 &lt;&lt; 3)) &gt; 0 &amp;&amp; pixelPer.y * (parameters.y - inData.v) &lt; 1.5);\\n            color = line ? uLineColor : ((uOptions &amp; (1 &lt;&lt; 1)) &gt; 0 ? vec4(splineColor, uFillColor.a) : vec4(0.0, 0.0, 0.0, 0.0));\\n            color.rgb = (0.3 + 0.5 * abs(dot(normal, uLightDirection)) + 0.2 * specular) * color.rgb;\\n            if (color.a == 0.0)\\n                discard;\\n        }\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.trimmedSurfaceFragmentShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.trimmedSurfaceFragmentShaderCode", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        #version 410 core\\n     \\n        flat in SplineInfo\\n        {\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        } inData;\\n        in vec3 worldPosition;\\n        in vec3 splineColor;\\n        in vec3 normal;\\n        in vec2 parameters;\\n        in vec2 pixelPer;\\n\\n        uniform vec4 uFillColor;\\n        uniform vec4 uLineColor;\\n        uniform vec3 uLightDirection;\\n        uniform int uOptions;\\n        uniform sampler2D uTrimTextureMap;\\n\\n        out vec4 color;\\n     \\n        void main()\\n        {\\n        \\tvec2 tex = vec2((parameters.x - inData.uFirst) / inData.uSpan, (parameters.y - inData.vFirst) / inData.vSpan);\\n            float specular = pow(abs(dot(normal, normalize(uLightDirection + worldPosition / length(worldPosition)))), 25.0);\\n            bool line = (uOptions &amp; (1 &lt;&lt; 2)) &gt; 0 &amp;&amp; (pixelPer.x * (parameters.x - inData.uFirst) &lt; 1.5 || pixelPer.x * (inData.uFirst + inData.uSpan - parameters.x) &lt; 1.5);\\n            line = line || ((uOptions &amp; (1 &lt;&lt; 2)) &gt; 0 &amp;&amp; (pixelPer.y * (parameters.y - inData.vFirst) &lt; 1.5 || pixelPer.y * (inData.vFirst + inData.vSpan - parameters.y) &lt; 1.5));\\n            line = line || ((uOptions &amp; (1 &lt;&lt; 3)) &gt; 0 &amp;&amp; pixelPer.x * (parameters.x - inData.u) &lt; 1.5);\\n            line = line || ((uOptions &amp; (1 &lt;&lt; 3)) &gt; 0 &amp;&amp; pixelPer.y * (parameters.y - inData.v) &lt; 1.5);\\n            color = line ? uLineColor : ((uOptions &amp; (1 &lt;&lt; 1)) &gt; 0 ? vec4(splineColor, uFillColor.a) : vec4(0.0, 0.0, 0.0, 0.0));\\n            color.rgb = (0.3 + 0.5 * abs(dot(normal, uLightDirection)) + 0.2 * specular) * color.rgb;\\n            if (color.a * texture(uTrimTextureMap, tex).r == 0.0)\\n                discard;\\n        }\\n    &#x27;"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.draw_func", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.draw_func", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.animating", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.animating", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.animate", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.animate", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.frameCount", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.frameCount", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.tessellationEnabled", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.tessellationEnabled", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.glInitialized", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.glInitialized", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.origin", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.origin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.button", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.button", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.mode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.mode", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.compute_color_vector", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.compute_color_vector", "kind": "function", "doc": "<p>Return an float32 array with the specified color.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>color</strong> (<code>numpy.array</code>):\nThe specified color as an array of 4 float32 values between 0 and 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetDefaultView", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetDefaultView", "kind": "function", "doc": "<p>Set the default view values used when resetting the view.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">eye</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">up</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetBackgroundColor", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetBackgroundColor", "kind": "function", "doc": "<p>Set the background color for the frame.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.ResetView", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.ResetView", "kind": "function", "doc": "<p>Update the view position to default values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.initgl", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.initgl", "kind": "function", "doc": "<p>Handle <code>OpenGLFrame</code> initgl action. Calls <code>CreateGLResources</code> and <code>HandleScreenSizeUpdate</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.CreateGLResources", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.CreateGLResources", "kind": "function", "doc": "<p>Create OpenGL resources upon creation of the frame and window recovery (un-minimize).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.ResetBounds", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.ResetBounds", "kind": "function", "doc": "<p>Handle window size and/or clipping plane update (typically after a window resize).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.redraw", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.redraw", "kind": "function", "doc": "<p>Handle <code>OpenGLFrame</code> redraw action. Updates view and draws spline list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.Unmap", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.Unmap", "kind": "function", "doc": "<p>Handle window unmap.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.Update", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.Update", "kind": "function", "doc": "<p>Update the frame, typically after updating the spline list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.Reset", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.Reset", "kind": "function", "doc": "<p>Reset the view and update the frame.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetMode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetMode", "kind": "function", "doc": "<p>Set the view mode for the frame.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mode</strong> (<code>int</code> with the following values:):\n<ul>\n<li><code>SplineOpenGLFrame.ROTATE</code> Dragging the left mouse rotates the view.</li>\n<li><code>SplineOpenGLFrame.PAN</code> Dragging the left mouse pans the view.</li>\n<li><code>SplineOpenGLFrame.FLY</code> Dragging the left mouse flies toward the mouse position.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mode</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetScale", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetScale", "kind": "function", "doc": "<p>Set anchor distance and/or flying speed (depending on mode).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scale</strong> (<code>float</code>):\nScale between 0 and 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">scale</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetAnimating", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetAnimating", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">animating</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseDown", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseDown", "kind": "function", "doc": "<p>Handle mouse down event.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseMove", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseMove", "kind": "function", "doc": "<p>Handle mouse move event.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseUp", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseUp", "kind": "function", "doc": "<p>Handle mouse up event.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseWheel", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseWheel", "kind": "function", "doc": "<p>Handle mouse wheel event.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.make_drawable", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.make_drawable", "kind": "function", "doc": "<p>Ensure a <code>Spline</code> can be drawn in a <code>SplineOpenGLFrame</code>. Converts 1D splines into 3D drawable curves, \n2D splines into drawable surfaces (y-axis hold amplitude), and 3D splines into drawable solids.</p>\n\n<p>Spline surfaces and solids with more than 3 dependent variables will have their added dimensions rendered \nas colors (up to 6 dependent variables are supported).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.tessellate2DSolid", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.tessellate2DSolid", "kind": "function", "doc": "<p>Returns an array of triangles that tessellate the given 2D solid</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">solid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.ConvertRGBToHSV", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.ConvertRGBToHSV", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.DrawSpline", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.DrawSpline", "kind": "function", "doc": "<p>Draw a spline within a <code>SplineOpenGLFrame</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">transform</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram", "kind": "class", "doc": "<p>Compile curve program</p>\n"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.__init__", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">frame</span></span>)</span>"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.aCurveParameters", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.aCurveParameters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.uCurveProjectionMatrix", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.uCurveProjectionMatrix", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.uCurveScreenScale", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.uCurveScreenScale", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.uCurveClipBounds", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.uCurveClipBounds", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.uCurveLineColor", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.uCurveLineColor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.uCurveSplineData", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.uCurveSplineData", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.CurveProgram.ResetBounds", "modulename": "bspy.splineOpenGLFrame", "qualname": "CurveProgram.ResetBounds", "kind": "function", "doc": "<p>Reset bounds and other frame configuration for curve program</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram", "kind": "class", "doc": "<p>Compile surface program</p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.__init__", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">frame</span>,</span><span class=\"param\">\t<span class=\"n\">trimmed</span>,</span><span class=\"param\">\t<span class=\"n\">nDep</span>,</span><span class=\"param\">\t<span class=\"n\">splineColorDeclarations</span>,</span><span class=\"param\">\t<span class=\"n\">initializeSplineColor</span>,</span><span class=\"param\">\t<span class=\"n\">computeSplineColor</span>,</span><span class=\"param\">\t<span class=\"n\">postProcessSplineColor</span></span>)</span>"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.aSurfaceParameters", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.aSurfaceParameters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.uSurfaceProjectionMatrix", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.uSurfaceProjectionMatrix", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.uSurfaceScreenScale", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.uSurfaceScreenScale", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.uSurfaceClipBounds", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.uSurfaceClipBounds", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.uSurfaceFillColor", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.uSurfaceFillColor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.uSurfaceLineColor", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.uSurfaceLineColor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.uSurfaceOptions", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.uSurfaceOptions", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.uSurfaceSplineData", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.uSurfaceSplineData", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SurfaceProgram.ResetBounds", "modulename": "bspy.splineOpenGLFrame", "qualname": "SurfaceProgram.ResetBounds", "kind": "function", "doc": "<p>Reset bounds and other frame configuration for surface program</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">frame</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block", "modulename": "bspy.spline_block", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.spline_block.SplineBlock", "modulename": "bspy.spline_block", "qualname": "SplineBlock", "kind": "class", "doc": "<p>A class to represent and process an array-like collection of splines. \nSpline blocks are useful for efficiently manipulating and solving systems of equations with splines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>block</strong> (an array-like collection of splines (may be a list of lists)):\nSplines in the same row are treated as if they are added together. \nEach row need not have the same number of splines, but all splines in a row must have the same \nnumber of dependent variables (same nDep). Corresponding independent variables must have the same domain.</p>\n\n<p>For example, if F is a spline with nInd = 3 and nDep = 2, G is a spline with nInd = 1 and nDep = 2, \nand h is a spline with nInd = 2 and nDep = 1, then [[F, G], [h]] is a valid block (total nDep is 3 \nand max nInd is 4).</p></li>\n</ul>\n"}, {"fullname": "bspy.spline_block.SplineBlock.__init__", "modulename": "bspy.spline_block", "qualname": "SplineBlock.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">block</span></span>)</span>"}, {"fullname": "bspy.spline_block.SplineBlock.nInd", "modulename": "bspy.spline_block", "qualname": "SplineBlock.nInd", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline_block.SplineBlock.nDep", "modulename": "bspy.spline_block", "qualname": "SplineBlock.nDep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline_block.SplineBlock.knotsDtype", "modulename": "bspy.spline_block", "qualname": "SplineBlock.knotsDtype", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline_block.SplineBlock.coefsDtype", "modulename": "bspy.spline_block", "qualname": "SplineBlock.coefsDtype", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline_block.SplineBlock.size", "modulename": "bspy.spline_block", "qualname": "SplineBlock.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.spline_block.SplineBlock.contours", "modulename": "bspy.spline_block", "qualname": "SplineBlock.contours", "kind": "function", "doc": "<p>Find all the contour curves of a block of splines whose <code>nInd</code> is one larger than its <code>nDep</code>.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>curves</strong> (<code>iterable</code>):\nA collection of <code>Spline</code> curves, <code>u(t)</code>, each of whose domain is [0, 1], whose range is\nin the parameter space of the given spline, and which satisfy <code>self(u(t)) = 0</code>.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>zeros</code>:  Find the roots of a block of splines (nInd must match nDep).  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>zeros</code> to find all intersection points and <code>Spline.contour</code> to find individual intersection curves. \nThe algorithm used to to find all intersection curves is from Grandine, Thomas A., and Frederick W. Klein IV. \n\"A new approach to the surface intersection problem.\" Computer Aided Geometric Design 14, no. 2 (1997): 111-134.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.contract", "modulename": "bspy.spline_block", "qualname": "SplineBlock.contract", "kind": "function", "doc": "<p>Contract a spline block by assigning a fixed value to one or more of its independent variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable to contract.\nA value of <code>None</code> for an independent variable indicates that variable should remain unchanged.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>block</strong> (<code>SplineBlock</code>):\nThe contracted spline block.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.derivative", "modulename": "bspy.spline_block", "qualname": "SplineBlock.derivative", "kind": "function", "doc": "<p>Compute the derivative of the spline block at given parameter values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>with_respect_to</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the integer order of derivative for each independent variable.\nA zero-order derivative just evaluates the spline normally.</li>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the derivative of the spline block at the given parameter values (array of size nDep).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">with_respect_to</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.domain", "modulename": "bspy.spline_block", "qualname": "SplineBlock.domain", "kind": "function", "doc": "<p>Return the domain of a spline block.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bounds</strong> (<code>numpy.array</code>):\nnInd x 2 array of the lower and upper bounds on each of the independent variables.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.evaluate", "modulename": "bspy.spline_block", "qualname": "SplineBlock.evaluate", "kind": "function", "doc": "<p>Compute the value of the spline block at given parameter values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the spline block at the given parameter values (array of size nDep).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.jacobian", "modulename": "bspy.spline_block", "qualname": "SplineBlock.jacobian", "kind": "function", "doc": "<p>Compute the value of the spline block's Jacobian at given parameter values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the spline block's Jacobian at the given parameter values. The shape of the return value is (nDep, nInd).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.normal", "modulename": "bspy.spline_block", "qualname": "SplineBlock.normal", "kind": "function", "doc": "<p>Compute the normal of the spline block at given parameter values. The number of independent variables must be\none different than the number of dependent variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>\n<li><strong>normalize</strong> (<code>boolean</code>, optional):\nIf True the returned normal will have unit length (the default). Otherwise, the normal's length will\nbe the area of the tangent space (for two independent variables, its the length of the cross product of tangent vectors).</li>\n<li><strong>indices</strong> (<code>iterable</code>, optional):\nAn iterable of normal indices to calculate. For example, <code>indices=(0, 3)</code> will return a vector of length 2\nwith the first and fourth values of the normal. If <code>None</code>, all normal values are returned (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>normal</strong> (<code>numpy.array</code>):\nThe normal vector of the spline block at the given parameter values.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>normal_spline</code>:  Compute a spline that evaluates to the normal of the given spline block (not normalized).  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Attentive readers will notice that the number of independent variables could be one more than the number of \ndependent variables (instead of one less, as is typical). In that case, the normal represents the null space of \nthe matrix formed by the tangents of the spline. If the null space is greater than one dimension, the normal will be zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span>, </span><span class=\"param\"><span class=\"n\">normalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.normal_spline", "modulename": "bspy.spline_block", "qualname": "SplineBlock.normal_spline", "kind": "function", "doc": "<p>Compute a spline that evaluates to the normal of the given spline block. The length of the normal\nis the area of the tangent space (for two independent variables, its the length of the cross product of tangent vectors).\nThe number of independent variables must be one different than the number of dependent variables.\nFind all the contour curves of a block of splines whose <code>nInd</code> is one larger than its <code>nDep</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices</strong> (<code>iterable</code>, optional):\nAn iterable of normal indices to calculate. For example, <code>indices=(0, 3)</code> will make the returned spline compute a vector of length 2\nwith the first and fourth values of the normal. If <code>None</code>, all normal values are returned (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline that evaluates to the normal of the given spline block.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>normal</code>:  Compute the normal of the spline block at given parameter values.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Attentive readers will notice that the number of independent variables could be one more than the number of \ndependent variables (instead of one less, as is typical). In that case, the normal represents the null space of \nthe matrix formed by the tangents of the spline block. If the null space is greater than one dimension, the normal will be zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.range_bounds", "modulename": "bspy.spline_block", "qualname": "SplineBlock.range_bounds", "kind": "function", "doc": "<p>Return the range of a spline block as lower and upper bounds on each of the\ndependent variables.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.reparametrize", "modulename": "bspy.spline_block", "qualname": "SplineBlock.reparametrize", "kind": "function", "doc": "<p>Reparametrize a spline block to match new domain bounds. The number of knots and coefficients remain unchanged.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new lower and upper bounds on each of the independent variables (same form as \nreturned from <code>domain</code>). If a bound pair is <code>None</code> then the original bound (and knots) are left unchanged. \nFor example, <code>[[0.0, 1.0], None]</code> will reparametrize the first independent variable and leave the second unchanged)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>block</strong> (<code>SplineBlock</code>):\nReparametrized spline block.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>domain</code>:  Return the domain of a spline block.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newDomain</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.trim", "modulename": "bspy.spline_block", "qualname": "SplineBlock.trim", "kind": "function", "doc": "<p>Trim the domain of a spline block.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new lower and upper bounds on each of the independent variables (same form as \nreturned from <code>domain</code>). If a bound is None or nan then the original bound (and knots) are left unchanged.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>block</strong> (<code>SplineBlock</code>):\nTrimmed spline block.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newDomain</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.spline_block.SplineBlock.zeros", "modulename": "bspy.spline_block", "qualname": "SplineBlock.zeros", "kind": "function", "doc": "<p>Find the roots of a block of splines (nInd must match nDep).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>epsilon</strong> (<code>float</code>, optional):\nTolerance for root precision. The root will be within epsilon of the actual root. \nThe default is the machine epsilon.</li>\n<li><strong>initialScale</strong> (array-like, optional):\nThe initial scale of each dependent variable (as opposed to the current scale of \nthe spline block, which may have been normalized). The default is an array of ones (size nDep).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>roots</strong> (<code>iterable</code>):\nAn iterable containing the roots of the block of splines. If the block is \nzero over an interval, that root will appear as a tuple of the interval. \nFor curves (nInd == 1), the roots are ordered.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>contours</code>:  Find all the contour curves of a spline block whose <code>nInd</code> is one larger than its <code>nDep</code>.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements a variation of the projected-polyhedron technique from Sherbrooke, Evan C., and Nicholas M. Patrikalakis. \n\"Computation of the solutions of nonlinear polynomial systems.\" Computer Aided Geometric Design 10, no. 5 (1993): 379-405.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">initialScale</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer", "modulename": "bspy.viewer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer", "modulename": "bspy.viewer", "qualname": "Viewer", "kind": "class", "doc": "<p>A tkinter viewer (<code>tkinter.Tk</code>) that hosts a <code>SplineOpenGLFrame</code>, a treeview full of \nsplines, and a set of controls to adjust and view the selected splines.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Graphics</code>:  A graphics engine to display splines. It launches a <code>Viewer</code> and issues commands to the viewer.  </p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Creates a Viewer, lists three splines, drawing (selecting) the third, and launches the viewer (blocks on the main loop).</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">viewer</span> <span class=\"o\">=</span> <span class=\"n\">Viewer</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">viewer</span><span class=\"o\">.</span><span class=\"n\">list</span><span class=\"p\">(</span><span class=\"n\">spline1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">viewer</span><span class=\"o\">.</span><span class=\"n\">list</span><span class=\"p\">(</span><span class=\"n\">spline2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">viewer</span><span class=\"o\">.</span><span class=\"n\">draw</span><span class=\"p\">(</span><span class=\"n\">spline3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">viewer</span><span class=\"o\">.</span><span class=\"n\">mainloop</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "bases": "tkinter.Tk"}, {"fullname": "bspy.viewer.Viewer.__init__", "modulename": "bspy.viewer", "qualname": "Viewer.__init__", "kind": "function", "doc": "<p>Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will\nbe created. BASENAME will be used for the identification of the profile file (see\nreadprofile).\nIt is constructed from sys.argv[0] without extensions if None is given. CLASSNAME\nis the name of the widget class.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\tSplineOpenGLFrame=&lt;class &#x27;bspy.splineOpenGLFrame.SplineOpenGLFrame&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">workQueue</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kw</span></span>)</span>"}, {"fullname": "bspy.viewer.Viewer.treeview", "modulename": "bspy.viewer", "qualname": "Viewer.treeview", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.frame", "modulename": "bspy.viewer", "qualname": "Viewer.frame", "kind": "function", "doc": "<p>Return identifier for decorative frame of this widget if present.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.frameMode", "modulename": "bspy.viewer", "qualname": "Viewer.frameMode", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.scale", "modulename": "bspy.viewer", "qualname": "Viewer.scale", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.splineList", "modulename": "bspy.viewer", "qualname": "Viewer.splineList", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.solidList", "modulename": "bspy.viewer", "qualname": "Viewer.solidList", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.splineDrawList", "modulename": "bspy.viewer", "qualname": "Viewer.splineDrawList", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.splineRadius", "modulename": "bspy.viewer", "qualname": "Viewer.splineRadius", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.adjust", "modulename": "bspy.viewer", "qualname": "Viewer.adjust", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.workQueue", "modulename": "bspy.viewer", "qualname": "Viewer.workQueue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Viewer.list", "modulename": "bspy.viewer", "qualname": "Viewer.list", "kind": "function", "doc": "<p>List a <code>Spline</code>, <code>Boundary</code>, or <code>Solid</code> in the treeview. Can be called before viewer is running.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spline</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fillColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lineColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">draw</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">parentIID</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.show", "modulename": "bspy.viewer", "qualname": "Viewer.show", "kind": "function", "doc": "<p>List a <code>Spline</code>, <code>Boundary</code>, or <code>Solid</code> in the treeview. Can be called before viewer is running.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spline</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fillColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lineColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">draw</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">parentIID</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.draw", "modulename": "bspy.viewer", "qualname": "Viewer.draw", "kind": "function", "doc": "<p>List a <code>Spline</code>, <code>Boundary</code>, or <code>Solid</code> in the treeview and draw it in the viewer. Can be called before viewer is running.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spline</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fillColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lineColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.save_splines", "modulename": "bspy.viewer", "qualname": "Viewer.save_splines", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.load_splines", "modulename": "bspy.viewer", "qualname": "Viewer.load_splines", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.erase_all", "modulename": "bspy.viewer", "qualname": "Viewer.erase_all", "kind": "function", "doc": "<p>Stop drawing all splines. Splines remain in the treeview.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.remove", "modulename": "bspy.viewer", "qualname": "Viewer.remove", "kind": "function", "doc": "<p>Remove splines from the treeview.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.empty", "modulename": "bspy.viewer", "qualname": "Viewer.empty", "kind": "function", "doc": "<p>Stop drawing all splines and remove them from the treeview.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.set_background_color", "modulename": "bspy.viewer", "qualname": "Viewer.set_background_color", "kind": "function", "doc": "<p>Set the background color.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.update", "modulename": "bspy.viewer", "qualname": "Viewer.update", "kind": "function", "doc": "<p>Update the spline draw list, set the default view, reset the bounds, and refresh the frame.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.get_fill_color", "modulename": "bspy.viewer", "qualname": "Viewer.get_fill_color", "kind": "function", "doc": "<p>Gets the fill color of the spline (only useful for nInd &gt;= 2).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fillColor</strong> (<code>numpy.array</code>):\nArray of four floats (r, g, b, a) in the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.set_fill_color", "modulename": "bspy.viewer", "qualname": "Viewer.set_fill_color", "kind": "function", "doc": "<p>Set the fill color of the spline (only useful for nInd &gt;= 2).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.get_line_color", "modulename": "bspy.viewer", "qualname": "Viewer.get_line_color", "kind": "function", "doc": "<p>Gets the line color of the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>lineColor</strong> (<code>numpy.array</code>):\nArray of four floats (r, g, b, a) in the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.set_line_color", "modulename": "bspy.viewer", "qualname": "Viewer.set_line_color", "kind": "function", "doc": "<p>Set the line color of the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.get_options", "modulename": "bspy.viewer", "qualname": "Viewer.get_options", "kind": "function", "doc": "<p>Gets the draw options for the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>options</strong> (<code>int</code> bitwise or (<code>|</code>) of zero or more of the following values:):\n<ul>\n<li><code>SplineOpenGLFrame.HULL</code> Draw the convex hull of the spline (the coefficients). Off by default.</li>\n<li><code>SplineOpenGLFrame.SHADED</code> Draw the spline shaded (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.BOUNDARY</code> Draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.ISOPARMS</code> Draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.set_options", "modulename": "bspy.viewer", "qualname": "Viewer.set_options", "kind": "function", "doc": "<p>Set the draw options for the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>options</strong> (<code>int</code> bitwise or (<code>|</code>) of zero or more of the following values:):\n<ul>\n<li><code>SplineOpenGLFrame.HULL</code> Draw the convex hull of the spline (the coefficients). Off by default.</li>\n<li><code>SplineOpenGLFrame.SHADED</code> Draw the spline shaded (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.BOUNDARY</code> Draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.ISOPARMS</code> Draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.get_animate", "modulename": "bspy.viewer", "qualname": "Viewer.get_animate", "kind": "function", "doc": "<p>Get the independent variable that is animated (None if there is none).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>animate</strong> (<code>int</code> or <code>None</code>):\nThe index of the independent variable that is animated (None is there is none).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Viewer.set_animate", "modulename": "bspy.viewer", "qualname": "Viewer.set_animate", "kind": "function", "doc": "<p>Set the independent variable that is animated (None if there is none).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>animate</strong> (<code>int</code> or <code>None</code>):\nThe index of the independent variable that is animated (None is there is none).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">animate</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics", "modulename": "bspy.viewer", "qualname": "Graphics", "kind": "class", "doc": "<p>A graphics engine to script and display splines. It launches a <code>Viewer</code> and issues commands to the viewer.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>variableDictionary</strong> (<code>dict</code>):\nA dictionary of variable names, typically <code>locals()</code>, used to assign names to splines.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>Viewer</code>:  A tkinter app (<code>tkinter.Tk</code>) that hosts a <code>SplineOpenGLFrame</code>, a treeview full of \nsplines, and a set of controls to adjust and view the selected splines.  </p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Launch a Viewer and tell it to draw some splines.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span> <span class=\"o\">=</span> <span class=\"n\">Graphics</span><span class=\"p\">(</span><span class=\"nb\">locals</span><span class=\"p\">())</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span><span class=\"o\">.</span><span class=\"n\">draw</span><span class=\"p\">(</span><span class=\"n\">spline1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span><span class=\"o\">.</span><span class=\"n\">draw</span><span class=\"p\">(</span><span class=\"n\">spline2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span><span class=\"o\">.</span><span class=\"n\">draw</span><span class=\"p\">(</span><span class=\"n\">spline3</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "bspy.viewer.Graphics.__init__", "modulename": "bspy.viewer", "qualname": "Graphics.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variableDictionary</span></span>)</span>"}, {"fullname": "bspy.viewer.Graphics.workQueue", "modulename": "bspy.viewer", "qualname": "Graphics.workQueue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Graphics.appThread", "modulename": "bspy.viewer", "qualname": "Graphics.appThread", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Graphics.variableDictionary", "modulename": "bspy.viewer", "qualname": "Graphics.variableDictionary", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bspy.viewer.Graphics.list", "modulename": "bspy.viewer", "qualname": "Graphics.list", "kind": "function", "doc": "<p>List a <code>Spline</code>, <code>Boundary</code>, or <code>Solid</code> in the treeview. Can be called before viewer is running.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spline</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fillColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lineColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">draw</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.show", "modulename": "bspy.viewer", "qualname": "Graphics.show", "kind": "function", "doc": "<p>List a <code>Spline</code>, <code>Boundary</code>, or <code>Solid</code> in the treeview. Can be called before viewer is running.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spline</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fillColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lineColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">draw</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.draw", "modulename": "bspy.viewer", "qualname": "Graphics.draw", "kind": "function", "doc": "<p>List a <code>Spline</code>, <code>Boundary</code>, or <code>Solid</code> in the treeview and draw it in the viewer. Can be called before viewer is running.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spline</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fillColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lineColor</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.erase_all", "modulename": "bspy.viewer", "qualname": "Graphics.erase_all", "kind": "function", "doc": "<p>Stop drawing all splines. Splines remain in the treeview.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.empty", "modulename": "bspy.viewer", "qualname": "Graphics.empty", "kind": "function", "doc": "<p>Stop drawing all splines and remove them from the treeview.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.set_background_color", "modulename": "bspy.viewer", "qualname": "Graphics.set_background_color", "kind": "function", "doc": "<p>Set the background color.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.update", "modulename": "bspy.viewer", "qualname": "Graphics.update", "kind": "function", "doc": "<p>Update the spline draw list and refresh the frame.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.get_fill_color", "modulename": "bspy.viewer", "qualname": "Graphics.get_fill_color", "kind": "function", "doc": "<p>Gets the fill color of the spline (only useful for nInd &gt;= 2).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fillColor</strong> (<code>numpy.array</code>):\nArray of four floats (r, g, b, a) in the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.set_fill_color", "modulename": "bspy.viewer", "qualname": "Graphics.set_fill_color", "kind": "function", "doc": "<p>Set the fill color of the spline (only useful for nInd &gt;= 2).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.get_line_color", "modulename": "bspy.viewer", "qualname": "Graphics.get_line_color", "kind": "function", "doc": "<p>Gets the line color of the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>lineColor</strong> (<code>numpy.array</code>):\nArray of four floats (r, g, b, a) in the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.set_line_color", "modulename": "bspy.viewer", "qualname": "Graphics.set_line_color", "kind": "function", "doc": "<p>Set the line color of the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.get_options", "modulename": "bspy.viewer", "qualname": "Graphics.get_options", "kind": "function", "doc": "<p>Gets the draw options for the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>options</strong> (<code>int</code> bitwise or (<code>|</code>) of zero or more of the following values:):\n<ul>\n<li><code>SplineOpenGLFrame.HULL</code> Draw the convex hull of the spline (the coefficients). Off by default.</li>\n<li><code>SplineOpenGLFrame.SHADED</code> Draw the spline shaded (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.BOUNDARY</code> Draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.ISOPARMS</code> Draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.set_options", "modulename": "bspy.viewer", "qualname": "Graphics.set_options", "kind": "function", "doc": "<p>Set the draw options for the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>options</strong> (<code>int</code> bitwise or (<code>|</code>) of zero or more of the following values:):\n<ul>\n<li><code>SplineOpenGLFrame.HULL</code> Draw the convex hull of the spline (the coefficients). Off by default.</li>\n<li><code>SplineOpenGLFrame.SHADED</code> Draw the spline shaded (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.BOUNDARY</code> Draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>SplineOpenGLFrame.ISOPARMS</code> Draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">options</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.get_animate", "modulename": "bspy.viewer", "qualname": "Graphics.get_animate", "kind": "function", "doc": "<p>Get the independent variable that is animated (None if there is none).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>animate</strong> (<code>int</code> or <code>None</code>):\nThe index of the independent variable that is animated (None is there is none).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bspy.viewer.Graphics.set_animate", "modulename": "bspy.viewer", "qualname": "Graphics.set_animate", "kind": "function", "doc": "<p>Set the independent variable that is animated (None if there is none).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe referenced spline.</li>\n<li><strong>animate</strong> (<code>int</code> or <code>None</code>):\nThe index of the independent variable that is animated (None is there is none).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spline</span>, </span><span class=\"param\"><span class=\"n\">animate</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();