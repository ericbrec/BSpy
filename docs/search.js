window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "bspy", "modulename": "bspy", "type": "module", "doc": "<p>bspy is a python library for manipulating and rendering non-uniform b-splines.</p>\n\n<h6 id=\"available-subpackages\">Available subpackages</h6>\n\n<p><code>bspy.spline</code> : A class to model, represent, and process piecewise polynomial tensor product\n    functions (spline functions) as linear combinations of B-splines.</p>\n\n<p><code>bspy.drawableSpline</code> : A <code>Spline</code> that can be drawn within a <code>SplineOpenGLFrame</code>.</p>\n\n<p><code>bspy.splineOpenGLFrame</code> : A tkinter <code>OpenGLFrame</code> with shaders to display a <code>DrawableSpline</code> list.</p>\n\n<p><code>bspy.bspyApp</code> : A tkinter app (<code>tkinter.Tk</code>) that hosts a <code>SplineOpenGLFrame</code>, a listbox full of \n    splines, and a set of controls to adjust and view the selected splines.</p>\n"}, {"fullname": "bspy.bspyApp", "modulename": "bspy.bspyApp", "type": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.bspyApp.bspyApp", "modulename": "bspy.bspyApp", "qualname": "bspyApp", "type": "class", "doc": "<p>A tkinter app (<code>tkinter.Tk</code>) that hosts a <code>SplineOpenGLFrame</code>, a listbox full of \nsplines, and a set of controls to adjust and view the selected splines.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>bspyGraphics</code>:  A graphics engine to display splines. It launches a <code>bspyApp</code> and issues commands to the app.  </p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Creates a bspyApp, show some splines, and launches the app (blocks on the main loop).</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">bspyApp</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">spline1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">spline2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">spline3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">mainloop</span><span class=\"p\">()</span>\n</code></pre></div>\n", "bases": "tkinter.Tk"}, {"fullname": "bspy.bspyApp.bspyApp.__init__", "modulename": "bspy.bspyApp", "qualname": "bspyApp.__init__", "type": "function", "doc": "<p>Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will\nbe created. BASENAME will be used for the identification of the profile file (see\nreadprofile).\nIt is constructed from sys.argv[0] without extensions if None is given. CLASSNAME\nis the name of the widget class.</p>\n", "signature": "(\n    self,\n    *args,\n    SplineOpenGLFrame=<class 'bspy.splineOpenGLFrame.SplineOpenGLFrame'>,\n    workQueue=None,\n    **kw\n)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyApp.show", "modulename": "bspy.bspyApp", "qualname": "bspyApp.show", "type": "function", "doc": "<p>Show a <code>Spline</code> in the listbox. Can be called before app is running.</p>\n", "signature": "(self, spline)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyApp.draw", "modulename": "bspy.bspyApp", "qualname": "bspyApp.draw", "type": "function", "doc": "<p>Add a <code>Spline</code> to the listbox and draw it. Can only be called after the app is running.</p>\n", "signature": "(self, spline)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyApp.erase_all", "modulename": "bspy.bspyApp", "qualname": "bspyApp.erase_all", "type": "function", "doc": "<p>Stop drawing all splines. Splines remain in the listbox.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyApp.empty", "modulename": "bspy.bspyApp", "qualname": "bspyApp.empty", "type": "function", "doc": "<p>Stop drawing all splines and remove them from the listbox.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyApp.set_background_color", "modulename": "bspy.bspyApp", "qualname": "bspyApp.set_background_color", "type": "function", "doc": "<p>Set the background color.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "(self, r, g=None, b=None, a=None)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyApp.update", "modulename": "bspy.bspyApp", "qualname": "bspyApp.update", "type": "function", "doc": "<p>Update the spline draw list and refresh the frame.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyGraphics", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics", "type": "class", "doc": "<p>A graphics engine to display splines. It launches a <code>bspyApp</code> and issues commands to the app.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>variableDictionary</strong> (<code>dict</code>):\nA dictionary of variable names, typically <code>locals()</code>, used to assign names to splines.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>bspyApp</code>:  A tkinter app (<code>tkinter.Tk</code>) that hosts a <code>SplineOpenGLFrame</code>, a listbox full of \nsplines, and a set of controls to adjust and view the selected splines.  </p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p>Launch a bspyApp and tell it to draw some splines.</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span> <span class=\"o\">=</span> <span class=\"n\">bspyGraphics</span><span class=\"p\">(</span><span class=\"nb\">locals</span><span class=\"p\">())</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span><span class=\"o\">.</span><span class=\"n\">draw</span><span class=\"p\">(</span><span class=\"n\">spline1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span><span class=\"o\">.</span><span class=\"n\">draw</span><span class=\"p\">(</span><span class=\"n\">spline2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">graphics</span><span class=\"o\">.</span><span class=\"n\">draw</span><span class=\"p\">(</span><span class=\"n\">spline3</span><span class=\"p\">)</span>\n</code></pre></div>\n"}, {"fullname": "bspy.bspyApp.bspyGraphics.__init__", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, variableDictionary)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyGraphics.show", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics.show", "type": "function", "doc": "<p>Show a <code>Spline</code> in the listbox.</p>\n", "signature": "(self, spline)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyGraphics.draw", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics.draw", "type": "function", "doc": "<p>Add a <code>Spline</code> to the listbox and draw it.</p>\n", "signature": "(self, spline)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyGraphics.erase_all", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics.erase_all", "type": "function", "doc": "<p>Stop drawing all splines. Splines remain in the listbox.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyGraphics.empty", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics.empty", "type": "function", "doc": "<p>Stop drawing all splines and remove them from the listbox.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyGraphics.set_background_color", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics.set_background_color", "type": "function", "doc": "<p>Set the background color.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "(self, r, g=None, b=None, a=None)", "funcdef": "def"}, {"fullname": "bspy.bspyApp.bspyGraphics.update", "modulename": "bspy.bspyApp", "qualname": "bspyGraphics.update", "type": "function", "doc": "<p>Update the spline draw list and refresh the frame.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline", "modulename": "bspy.drawableSpline", "type": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.drawableSpline.DrawableSpline", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline", "type": "class", "doc": "<p>A <code>Spline</code> that can be drawn within a <code>SplineOpenGLFrame</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spline or nInd</strong> (<code>Spline</code> or <code>int</code>):\nAn existing spline that needs to become drawable (using <code>DrawableSpline.make_drawable</code>), or the number of independent variables of the new spline. \nIf it is an existing spline, the remaining parameters are optional and ignored.</li>\n<li><strong>nDep</strong> (<code>int</code>):\nThe number of dependent variables of the spline</li>\n<li><strong>order</strong> (<code>tuple</code>):\nA tuple of length nInd where each integer entry represents the\npolynomial order of the function in that variable</li>\n<li><strong>nCoef</strong> (<code>tuple</code>):\nA tuple of length nInd where each integer entry represents the\ndimension (i.e. number of B-spline coefficients) of the function\nspace in that variable</li>\n<li><strong>knots</strong> (<code>list</code>):\nA list of the lists of the knots of the spline in each independent variable</li>\n<li><strong>coefs</strong> (array-like):\nA list of the B-spline coefficients of the spline.</li>\n<li><strong>accuracy</strong> (<code>float</code>):\nEach spline function is presumed to be an approximation of something else. \nThe <code>accuracy</code> stores the infinity norm error of the difference between \nthe given spline function and that something else.</li>\n<li><strong>metadata</strong> (<code>dict</code>):\nA dictionary of ancillary data to store with the spline</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>bspy.spline</code>:  A class to model, represent, and process piecewise polynomial tensor product\nfunctions (spline functions) as linear combinations of B-splines. <br />\n<code>make_drawable</code>:  Convert a <code>Spline</code> into a <code>DrawableSpline</code> that can be drawn in a <code>SplineOpenGLFrame</code>. Converts \n1D splines into 3D curves and 2D splines into surfaces (y-axis hold amplitude).  </p>\n", "bases": "bspy.spline.Spline"}, {"fullname": "bspy.drawableSpline.DrawableSpline.__init__", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, *args, **kwargs)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline.DrawableSpline.maxOrder", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.maxOrder", "type": "variable", "doc": "<p>Maximum order for drawable splines.</p>\n", "default_value": " = 9"}, {"fullname": "bspy.drawableSpline.DrawableSpline.maxCoefficients", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.maxCoefficients", "type": "variable", "doc": "<p>Maximum number of coefficients for drawable splines.</p>\n", "default_value": " = 120"}, {"fullname": "bspy.drawableSpline.DrawableSpline.maxKnots", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.maxKnots", "type": "variable", "doc": "<p>Maximum number of knots for drawable splines.</p>\n", "default_value": " = 129"}, {"fullname": "bspy.drawableSpline.DrawableSpline.HULL", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.HULL", "type": "variable", "doc": "<p>Option to draw the convex hull of the spline (the coefficients). Off by default.</p>\n", "default_value": " = 1"}, {"fullname": "bspy.drawableSpline.DrawableSpline.SHADED", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.SHADED", "type": "variable", "doc": "<p>Option to draw the spline shaded (only useful for nInd &gt;= 2). On by default.</p>\n", "default_value": " = 2"}, {"fullname": "bspy.drawableSpline.DrawableSpline.BOUNDARY", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.BOUNDARY", "type": "variable", "doc": "<p>Option to draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</p>\n", "default_value": " = 4"}, {"fullname": "bspy.drawableSpline.DrawableSpline.ISOPARMS", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.ISOPARMS", "type": "variable", "doc": "<p>Option to draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</p>\n", "default_value": " = 8"}, {"fullname": "bspy.drawableSpline.DrawableSpline.make_drawable", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.make_drawable", "type": "function", "doc": "<p>Convert a <code>Spline</code> into a <code>DrawableSpline</code> that can be drawn in a <code>SplineOpenGLFrame</code>. Converts \n1D splines into 3D curves and 2D splines into surfaces (y-axis hold amplitude).</p>\n\n<p>The drawable spline will share the original spline's metadata (metadata changes are shared).</p>\n", "signature": "(spline)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline.DrawableSpline.get_fill_color", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.get_fill_color", "type": "function", "doc": "<p>Gets the fill color of the spline (only useful for nInd &gt;= 2).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fillColor</strong> (<code>numpy.array</code>):\nArray of four floats (r, g, b, a) in the range [0, 1].</li>\n</ul>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline.DrawableSpline.set_fill_color", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.set_fill_color", "type": "function", "doc": "<p>Set the fill color of the spline (only useful for nInd &gt;= 2).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "(self, r, g=None, b=None, a=None)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline.DrawableSpline.get_line_color", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.get_line_color", "type": "function", "doc": "<p>Gets the line color of the spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>lineColor</strong> (<code>numpy.array</code>):\nArray of four floats (r, g, b, a) in the range [0, 1].</li>\n</ul>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline.DrawableSpline.set_line_color", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.set_line_color", "type": "function", "doc": "<p>Set the line color of the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "(self, r, g=None, b=None, a=None)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline.DrawableSpline.get_options", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.get_options", "type": "function", "doc": "<p>Gets the draw options for the spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>options</strong> (<code>int</code> bitwise or (<code>|</code>) of zero or more of the following values:):\n<ul>\n<li><code>DrawableSpline.HULL</code> Draw the convex hull of the spline (the coefficients). Off by default.</li>\n<li><code>DrawableSpline.SHADED</code> Draw the spline shaded (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>DrawableSpline.BOUNDARY</code> Draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>DrawableSpline.ISOPARMS</code> Draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</li>\n</ul></li>\n</ul>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.drawableSpline.DrawableSpline.set_options", "modulename": "bspy.drawableSpline", "qualname": "DrawableSpline.set_options", "type": "function", "doc": "<p>Set the draw options for the spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>options</strong> (<code>int</code> bitwise or (<code>|</code>) of zero or more of the following values:):\n<ul>\n<li><code>DrawableSpline.HULL</code> Draw the convex hull of the spline (the coefficients). Off by default.</li>\n<li><code>DrawableSpline.SHADED</code> Draw the spline shaded (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>DrawableSpline.BOUNDARY</code> Draw the boundary of the spline in the line color (only useful for nInd &gt;= 2). On by default.</li>\n<li><code>DrawableSpline.ISOPARMS</code> Draw the lines of constant knot values of the spline in the line color (only useful for nInd &gt;= 2). Off by default.</li>\n</ul></li>\n</ul>\n", "signature": "(self, options)", "funcdef": "def"}, {"fullname": "bspy.spline", "modulename": "bspy.spline", "type": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.spline.Spline", "modulename": "bspy.spline", "qualname": "Spline", "type": "class", "doc": "<p>A class to model, represent, and process piecewise polynomial tensor product\nfunctions (spline functions) as linear combinations of B-splines. </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>nInd</strong> (<code>int</code>):\nThe number of independent variables of the spline</li>\n<li><strong>nDep</strong> (<code>int</code>):\nThe number of dependent variables of the spline</li>\n<li><strong>order</strong> (<code>tuple</code>):\nA tuple of length nInd where each integer entry represents the\npolynomial order of the function in that variable</li>\n<li><strong>nCoef</strong> (<code>tuple</code>):\nA tuple of length nInd where each integer entry represents the\ndimension (i.e. number of B-spline coefficients) of the function\nspace in that variable</li>\n<li><strong>knots</strong> (<code>list</code>):\nA list of the lists of the knots of the spline in each independent variable</li>\n<li><strong>coefs</strong> (array-like):\nA list of the B-spline coefficients of the spline.</li>\n<li><strong>accuracy</strong> (<code>float</code>, optional):\nEach spline function is presumed to be an approximation of something else. \nThe <code>accuracy</code> stores the infinity norm error of the difference between \nthe given spline function and that something else. Default is zero.</li>\n<li><strong>metadata</strong> (<code>dict</code>, optional):\nA dictionary of ancillary data to store with the spline. Default is {}.</li>\n</ul>\n"}, {"fullname": "bspy.spline.Spline.__init__", "modulename": "bspy.spline", "qualname": "Spline.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    nInd,\n    nDep,\n    order,\n    nCoef,\n    knots,\n    coefs,\n    accuracy=0.0,\n    metadata={}\n)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.add", "modulename": "bspy.spline", "qualname": "Spline.add", "type": "function", "doc": "<p>Add two splines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Spline</code>):\nThe spline to add to self. The number of dependent variables must match self.</li>\n<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):\nAn iterable of pairs of indices. \nEach pair (n, m) maps the mth independent variable of other to the nth independent variable of self. \nThe domains of the nth and mth independent variables must match. \nAn independent variable can map to no more than one other independent variable.\nUnmapped independent variables remain independent (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe result of adding other to self.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>subtract</code>:  Subtract two splines. <br />\n`<code>common_basis</code>:  Align a collection of splines to a common basis, elevating the order and adding knots as needed.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>common_basis</code> to ensure mapped variables share the same order and knots.</p>\n", "signature": "(self, other, indMap=None)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.blossom", "modulename": "bspy.spline", "qualname": "Spline.blossom", "type": "function", "doc": "<p>Compute the blossom of the spline at a given parameter values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvwValues</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the degree-sized vectors of blossom parameters for each independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the spline's blossom at the given blossom parameters.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>evaluate</code>:  Compute the value of the spline at a given parameter value.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Evaluates the blossom based on blossoming algorithm 1 found in Goldman, Ronald N. \"Blossoming and knot insertion algorithms for B-spline curves.\" \nComputer Aided Geometric Design 7, no. 1-4 (1990): 69-81.</p>\n", "signature": "(self, uvw)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.clamp", "modulename": "bspy.spline", "qualname": "Spline.clamp", "type": "function", "doc": "<p>Ensure the leftmost/rightmost knot has a full order multiplicity, clamping the spline's \nvalue at the first/last knot to its first/last coefficient.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>left</strong> (<code>iterable</code>):\nAn iterable of independent variables to clamp on the left side.</li>\n<li><strong>right</strong> (<code>iterable</code>):\nAn iterable of independent variables to clamp on the right side.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe clamped spline. If the spline was already clamped, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n", "signature": "(self, left, right)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.common_basis", "modulename": "bspy.spline", "qualname": "Spline.common_basis", "type": "function", "doc": "<p>Align a collection of splines to a common basis, elevating the order and adding knots as needed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>splines</strong> (<code>iterable</code>):\nThe collection of N - 1 splines to align (N total splines, including self).</li>\n<li><strong>indMap</strong> (<code>iterable</code>):\nThe collection of independent variables to align. Since each spline can have multiple \nindependent variables, <code>indMap</code> is an <code>iterable</code> of <code>iterables</code> (like a list of lists). \nEach collection of indices (i0, i1, .. iN) maps the i'th independent variable to each other. \nThe domains of mapped independent variables must match. \nAn independent variable can map to no more than one other independent variable.\nIf all the splines are curves (1 independent variable), then <code>indMap</code> is ((0, 0, .. 0),).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>splines</strong> (<code>tuple</code>):\nThe aligned collection of N splines.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>elevate_and_insert_knots</code>:  Elevate a spline and insert new knots.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>elevate_and_insert_knots</code> to ensure mapped variables share the same order and knots.</p>\n", "signature": "(self, splines, indMap)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.derivative", "modulename": "bspy.spline", "qualname": "Spline.derivative", "type": "function", "doc": "<p>Compute the derivative of the spline at a given parameter value.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>with_respect_to</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the integer order of derivative for each independent variable.\nA zero-order derivative just evaluates the spline normally.</li>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter value).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the derivative of the spline at the given parameter value.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>evaluate</code>:  Compute the value of the spline at a given parameter value. <br />\n<code>differentiate</code>:  Differentiate a spline with respect to one of its independent variables, returning the resulting spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The derivative method uses the de Boor recurrence relations for a B-spline\nseries to evaluate a spline function.  The non-zero B-splines are\nevaluated, then the dot product of those B-splines with the vector of\nB-spline coefficients is computed.</p>\n", "signature": "(self, with_respect_to, uvw)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.differentiate", "modulename": "bspy.spline", "qualname": "Spline.differentiate", "type": "function", "doc": "<p>Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>with_respect_to</strong> (integer, optional):\nThe number of the independent variable to differentiate. Default is zero.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe spline that results from differentiating the original spline with respect to the given independent variable.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>derivative</code>:  Compute the derivative of the spline at a given parameter value.  </p>\n", "signature": "(self, with_respect_to=0)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.domain", "modulename": "bspy.spline", "qualname": "Spline.domain", "type": "function", "doc": "<p>Return the domain of a spline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bounds</strong> (<code>numpy.array</code>):\nnInd x 2 array of the upper and lower bounds on each of the independent variables.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>reparametrize</code>:  Reparametrize a spline to match new domain bounds <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.dot", "modulename": "bspy.spline", "qualname": "Spline.dot", "type": "function", "doc": "<p>Dot product a spline by the given vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vector</strong> (array-like):\nAn array of length <code>nDep</code> that specifies the vector.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe dotted spline.</li>\n</ul>\n", "signature": "(self, vector)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.elevate", "modulename": "bspy.spline", "qualname": "Spline.elevate", "type": "function", "doc": "<p>Elevate a spline, increasing its order by <code>m</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>m</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the non-negative integer amount to increase the order \nfor each independent variable of the spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the order of the current spline plus <code>m</code>.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>elevate_and_insert_knots</code>:  Elevate a spline and insert new knots.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. \n\"Fast degree elevation and knot insertion for B-spline curves.\" Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</p>\n", "signature": "(self, m)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.elevate_and_insert_knots", "modulename": "bspy.spline", "qualname": "Spline.elevate_and_insert_knots", "type": "function", "doc": "<p>Elevate a spline and insert new knots.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>m</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the non-negative integer amount to increase the order \nfor each independent variable of the spline.</li>\n<li><strong>newKnots</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the knots to be added to each independent variable's knots. \nlen(newKnots[ind]) == 0 if no knots are to be added for the <code>ind</code> independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the order of the current spline plus <code>m</code> that includes the new knots.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>clamp</code>:  Clamp the left and/or right side of a spline. <br />\n<code>elevate</code>:  Elevate a spline, increasing its order by <code>m</code>.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. \n\"Fast degree elevation and knot insertion for B-spline curves.\" Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</p>\n", "signature": "(self, m, newKnots)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.evaluate", "modulename": "bspy.spline", "qualname": "Spline.evaluate", "type": "function", "doc": "<p>Compute the value of the spline at a given parameter value.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (<code>iterable</code>):\nAn iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter value).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>value</strong> (<code>numpy.array</code>):\nThe value of the spline at the given parameter value.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>derivative</code>:  Compute the derivative of the spline at a given parameter value.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The evaluate method uses the de Boor recurrence relations for a B-spline\nseries to evaluate a spline function.  The non-zero B-splines are\nevaluated, then the dot product of those B-splines with the vector of\nB-spline coefficients is computed.</p>\n", "signature": "(self, uvw)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.extrapolate", "modulename": "bspy.spline", "qualname": "Spline.extrapolate", "type": "function", "doc": "<p>Extrapolate a spline out to an extended domain maintaining a given order of continuity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as \nreturned from <code>domain</code>). If a bound is None or nan then the original bound (and knots) are left unchanged.</li>\n<li><strong>continuityOrder</strong> (<code>int</code>):\nThe order of continuity of the extrapolation (the number of derivatives that match at the endpoints). \nA continuity order of zero means the extrapolation just matches the spline value at the endpoints. \nThe continuity order is automatically limited to one less than the degree of the spline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nExtrapolated spline. If all the knots are unchanged, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>domain</code>:  Return the domain of a spline. <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n", "signature": "(self, newDomain, continuityOrder)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.fold", "modulename": "bspy.spline", "qualname": "Spline.fold", "type": "function", "doc": "<p>Fold the coefficients of a spline's indicated independent variables into the coefficients of the remaining independent variables, retaining the \nindicated independent variables' knots and orders in a second spline with no coefficients.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>foldedInd</strong> (<code>iterable</code>):\nAn iterable that specifies the independent variables whose coefficients should be folded.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>foldedSpline, coefficientlessSpline</strong> (<code>Spline</code>, <code>Spline</code>):\nThe folded spline and the coefficientless spline that retains the indicated independent variables' knots and orders.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>unfold</code>:  Unfold the coefficients of an original spline's indicated independent variables back into the spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.\nThe first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, \nall of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline \nwith 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, \nreturning the original spline.</p>\n\n<p>Here's an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. \nThen spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have \nshape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn't matter \nso long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</p>\n", "signature": "(self, foldedInd)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.insert_knots", "modulename": "bspy.spline", "qualname": "Spline.insert_knots", "type": "function", "doc": "<p>Insert new knots into a spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newKnots</strong> (<code>iterable</code> of length <code>nInd</code>):\nAn iterable that specifies the knots to be added to each independent variable's knots. \nlen(newKnots[ind]) == 0 if no knots are to be added for the <code>ind</code> independent variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the new knots inserted. If no knots were inserted, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>clamp</code>:  Clamp the left and/or right side of a spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements Boehm's standard knot insertion algorithm.</p>\n", "signature": "(self, newKnots)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.least_squares", "modulename": "bspy.spline", "qualname": "Spline.least_squares", "type": "function", "doc": "<p>Fit a curve to a string of data points using the method of least squares.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataPoints</strong> (<code>iterable</code> containing the data points to fit.):\nEach of the data points is of length nDep.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline curve which approximates the data points.</li>\n</ul>\n", "signature": "(dataPoints)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.load", "modulename": "bspy.spline", "qualname": "Spline.load", "type": "function", "doc": "<p></p>\n", "signature": "(fileName, splineType=None)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.range_bounds", "modulename": "bspy.spline", "qualname": "Spline.range_bounds", "type": "function", "doc": "<p>Return the range of a spline as upper and lower bounds on each of the\ndependent variables</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.remove_knots", "modulename": "bspy.spline", "qualname": "Spline.remove_knots", "type": "function", "doc": "<p>Remove interior knots from a spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>oldKnots</strong> (<code>iterable</code> of length <code>nInd</code>, optional):\nAn iterable that specifies the knots that can be removed from each independent variable's interior knots. \nlen(newKnots[ind]) == 0 if all interior knots can be removed for the <code>ind</code> independent variable (the default). \nKnots that don't appear in the independent variable's interior knots are ignored.</li>\n<li><strong>maxRemovalsPerKnot</strong> (<code>int</code>, optional):\nA non-zero count of the largest number of times a knot can be removed. For example, one means that \nonly one instance of each knot can be removed. (Zero means each knot can be removed completely, \nwhich is the default.)</li>\n<li><strong>tolerance</strong> (<code>float</code> or <code>None</code>, optional):\nThe maximum residual error permitted after removing a knot. Knots will not be removed if the \nresulting residual error is above this threshold. Default is <code>None</code>, meaning all specified knots \nwill be removed up to <code>maxRemovalsPerKnot</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nA spline with the knots removed.</li>\n<li><strong>totalRemoved</strong> (<code>int</code>):\nThe total number of knots removed.</li>\n<li><strong>residualError</strong> (<code>float</code>):\nThe residual error relative to the old spline. (The returned spline's accuracy is also adjusted accordinly.)</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>insert_knots</code>:  Insert new knots into a spline. <br />\n<code>trim</code>:  Trim the domain of a spline.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Implements a variation of the algorithms from Tiller, Wayne. \"Knot-removal algorithms for NURBS curves and surfaces.\" Computer-Aided Design 24, no. 8 (1992): 445-453.</p>\n", "signature": "(self, oldKnots=((),), maxRemovalsPerKnot=0, tolerance=None)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.reparametrize", "modulename": "bspy.spline", "qualname": "Spline.reparametrize", "type": "function", "doc": "<p>Reparametrize a spline to match new domain bounds. The spline's number of knots and its coefficients remain unchanged.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new upper and lower bounds on each of the independent variables. \nSame form as returned from <code>domain</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nReparametrized spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>domain</code>:  Return the domain of a spline.  </p>\n", "signature": "(self, newDomain)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.save", "modulename": "bspy.spline", "qualname": "Spline.save", "type": "function", "doc": "<p></p>\n", "signature": "(self, fileName)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.scale", "modulename": "bspy.spline", "qualname": "Spline.scale", "type": "function", "doc": "<p>Scale a spline by the given scalar or scale vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>multiplier</strong> (scalar or array-like):\nA scalar or an array of length <code>nDep</code> that specifies the multiplier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe scaled spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>transform</code>:  Transform a spline by the given matrix. <br />\n<code>translate</code>:  Translate a spline by the given translation vector.  </p>\n", "signature": "(self, multiplier)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.subtract", "modulename": "bspy.spline", "qualname": "Spline.subtract", "type": "function", "doc": "<p>Subtract two splines.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong> (<code>Spline</code>):\nThe spline to subtract from self. The number of dependent variables must match self.</li>\n<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):\nAn iterable of pairs of indices. \nEach pair (n, m) maps the mth independent variable of other to the nth independent variable of self. \nThe domains of the nth and mth independent variables must match. \nAn independent variable can map to no more than one other independent variable.\nUnmapped independent variables remain independent (the default).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe result of subtracting other from self.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>add</code>:  Add two splines. <br />\n`<code>common_basis</code>:  Align a collection of splines to a common basis, elevating the order and adding knots as needed.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses <code>common_basis</code> to ensure mapped variables share the same order and knots.</p>\n", "signature": "(self, other, indMap=None)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.transform", "modulename": "bspy.spline", "qualname": "Spline.transform", "type": "function", "doc": "<p>Transform a spline by the given matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>matrix</strong> (array-like):\nAn array of size <code>newNDep</code>x<code>nDep</code> that specifies the transform matrix.</li>\n<li><strong>maxSingularValue</strong> (<code>float</code>, optional):\nThe largest singular value of <code>matrix</code>, used to update the accuracy of the spline. \nIf no value is provided (default), the largest singular value is computed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe transformed spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>scale</code>:  Scale a spline by the given scalar or scale vector. <br />\n<code>translate</code>:  Translate a spline by the given translation vector.  </p>\n", "signature": "(self, matrix, maxSingularValue=None)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.translate", "modulename": "bspy.spline", "qualname": "Spline.translate", "type": "function", "doc": "<p>Translate a spline by the given translation vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>translationVector</strong> (array-like):\nAn array of length <code>nDep</code> that specifies the translation vector.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nThe translated spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>scale</code>:  Scale a spline by the given scalar or scale vector. <br />\n<code>transform</code>:  Transform a spline by the given matrix.  </p>\n", "signature": "(self, translationVector)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.trim", "modulename": "bspy.spline", "qualname": "Spline.trim", "type": "function", "doc": "<p>Trim the domain of a spline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>newDomain</strong> (array-like):\nnInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as \nreturned from <code>domain</code>). If a bound is None or nan then the original bound (and knots) are left unchanged.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spline</strong> (<code>Spline</code>):\nTrimmed spline. If all the knots are unchanged, the original spline is returned.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>domain</code>:  Return the domain of a spline. <br />\n<code>extrapolate</code>:  Extrapolate a spline out to an extended domain maintaining a given order of continuity.  </p>\n", "signature": "(self, newDomain)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.unfold", "modulename": "bspy.spline", "qualname": "Spline.unfold", "type": "function", "doc": "<p>Unfold the coefficients of an original spline's indicated independent variables back into the spline, using the \nindicated independent variables' knots and orders from a second spline with no coefficients.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>foldedInd</strong> (<code>iterable</code>):\nAn iterable that specifies the independent variables whose coefficients should be unfolded.</li>\n<li><strong>coefficientlessSpline</strong> (<code>Spline</code>):\nThe coefficientless spline that retains the indicated independent variables' knots and orders.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>unfoldedSpline</strong> (<code>Spline</code>, <code>Spline</code>):\nThe unfolded spline.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>fold</code>:  Fold the coefficients of a spline's indicated independent variables into the coefficients of the remaining independent variables.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.\nThe first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, \nall of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline \nwith 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, \nreturning the original spline.</p>\n\n<p>Here's an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. \nThen spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have \nshape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn't matter \nso long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</p>\n", "signature": "(self, foldedInd, coefficientlessSpline)", "funcdef": "def"}, {"fullname": "bspy.spline.Spline.zeros", "modulename": "bspy.spline", "qualname": "Spline.zeros", "type": "function", "doc": "<p>Find the roots of a spline (nInd must match nDep).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>epsilon</strong> (<code>float</code>, optional):\nTolerance for root precision. The root will be within epsilon of the actual root. \nThe default is the max of spline accuracy and machine epsilon.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>roots</strong> (<code>iterable</code>):\nAn ordered iterable containing the roots of the spline. If the spline is \nzero over an interval, that root will appear as a tuple of the interval.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Currently, the algorithm only works for nInd == 1. \nImplements the algorithm from Grandine, Thomas A. \"Computing zeroes of spline functions.\" Computer Aided Geometric Design 6, no. 2 (1989): 129-136.</p>\n", "signature": "(self, epsilon=None)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame", "modulename": "bspy.splineOpenGLFrame", "type": "module", "doc": "<p></p>\n"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame", "type": "class", "doc": "<p>A tkinter <code>OpenGLFrame</code> with shaders to display a <code>DrawableSpline</code> list.</p>\n", "bases": "pyopengltk.win32.OpenGLFrame"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.__init__", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.__init__", "type": "function", "doc": "<p>Construct a frame widget with the parent MASTER.</p>\n\n<p>Valid resource names: background, bd, bg, borderwidth, class,\ncolormap, container, cursor, height, highlightbackground,\nhighlightcolor, highlightthickness, relief, takefocus, visual, width.</p>\n", "signature": "(self, *args, **kw)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.ROTATE", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.ROTATE", "type": "variable", "doc": "<p>Default view mode in which dragging the left mouse rotates the view.</p>\n", "default_value": " = 1"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.PAN", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.PAN", "type": "variable", "doc": "<p>View mode in which dragging the left mouse pans the view.</p>\n", "default_value": " = 2"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.FLY", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.FLY", "type": "variable", "doc": "<p>View mode in which dragging the left mouse flies toward the mouse position.</p>\n", "default_value": " = 3"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeBSplineCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeBSplineCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        void ComputeBSpline(in int offset, in int order, in int n, in int knot, in float u, \\n            out float uBSpline[{maxOrder}], out float duBSpline[{maxOrder}])\\n        {{\\n            int degree = 1;\\n\\n            for (int i = 0; i < {maxOrder}; i++)\\n            {{\\n                uBSpline[i] = 0.0;\\n                duBSpline[i] = 0.0;\\n            }}\\n            uBSpline[order-1] = 1.0;\\n\\n            while (degree < order - 1)\\n            {{\\n                int b = order - degree;\\n                for (int i = knot - degree; i < knot; i++)\\n                {{\\n                    float knotValue = texelFetch(uSplineData, offset + i).x; // knots[i]\\n                    float alpha = (u - knotValue) / (texelFetch(uSplineData, offset + i + degree).x - knotValue); // (u - knots[i]) / (knots[i+degree] - knots[i]);\\n                    uBSpline[b-1] += (1.0 - alpha) * uBSpline[b];\\n                    uBSpline[b] *= alpha;\\n                    b++;\\n                }}\\n                degree++;\\n            }}\\n            if (degree < order)\\n            {{\\n                int b = order - degree;\\n                for (int i = knot - degree; i < knot; i++)\\n                {{\\n                    float knotValue = texelFetch(uSplineData, offset + i).x; // knots[i]\\n                    float gap = texelFetch(uSplineData, offset + i + degree).x - knotValue; // knots[i+degree] - knots[i]\\n                    float alpha = degree / gap;\\n                    duBSpline[b-1] += -alpha * uBSpline[b];\\n                    duBSpline[b] = alpha * uBSpline[b];\\n\\n                    alpha = (u - knotValue) / gap; // (u - knots[i]) / gap;\\n                    uBSpline[b-1] += (1.0 - alpha) * uBSpline[b];\\n                    uBSpline[b] *= alpha;\\n                    b++;\\n                }}\\n            }}\\n        }}\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeSampleRateCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeSampleRateCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        float ComputeSampleRate(in vec4 point, in vec3 dPoint, in vec3 d2Point, in float minRate)\\n        {\\n            float rate = 0.0;\\n            float scale = uScreenScale.z > 0.0 ? -point.z : 1.0;\\n\\n            // Only consider points that lie within the clip bounds or whose derivative spans the clip bounds.\\n            if (point.z < uClipBounds[3] && point.z > uClipBounds[2] && \\n                ((point.y < scale * uClipBounds[1] && point.y > -scale * uClipBounds[1]) ||\\n                (point.y >= scale * uClipBounds[1] && point.y + dPoint.y <= -scale * uClipBounds[1]) ||\\n                (point.y <= -scale * uClipBounds[1] && point.y + dPoint.y >= scale * uClipBounds[1])) &&\\n                ((point.x < scale * uClipBounds[0] && point.x > -scale * uClipBounds[0]) ||\\n                (point.x >= scale * uClipBounds[0] && point.x + dPoint.x <= -scale * uClipBounds[0]) ||\\n                (point.x <= -scale * uClipBounds[0] && point.x + dPoint.x >= scale * uClipBounds[0])))\\n            {\\n                float zScale = -1.0 / point.z;\\n                float zScale2 = zScale * zScale;\\n                float zScale3 = zScale2 * zScale;\\n                vec2 projection = uScreenScale.z > 0.0 ? \\n                    vec2(uScreenScale.x * (d2Point.x * zScale - 2.0 * dPoint.x * dPoint.z * zScale2 +\\n                        point.x * (2.0 * dPoint.z * dPoint.z * zScale3 - d2Point.z * zScale2)),\\n                        uScreenScale.y * (d2Point.y * zScale - 2.0 * dPoint.y * dPoint.z * zScale2 +\\n                        point.y * (2.0 * dPoint.z * dPoint.z * zScale3 - d2Point.z * zScale2)))\\n                    : vec2(uScreenScale.x * d2Point.x, uScreenScale.y * d2Point.y);\\n                rate = max(sqrt(length(projection)), minRate);\\n            }\\n            return rate;\\n        }\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveVertexShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveVertexShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n     \\n        const int header = 2;\\n\\n        attribute vec4 aParameters;\\n\\n        uniform samplerBuffer uSplineData;\\n\\n        out SplineInfo\\n        {\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        } outData;\\n\\n        void main()\\n        {\\n            outData.uOrder = int(texelFetch(uSplineData, 0).x);\\n            outData.uN = int(texelFetch(uSplineData, 1).x);\\n            outData.uKnot = min(gl_InstanceID + outData.uOrder, outData.uN);\\n            outData.u = texelFetch(uSplineData, header + outData.uKnot - 1).x; // knots[uKnot-1]\\n            outData.uInterval = texelFetch(uSplineData, header + outData.uKnot).x - outData.u; // knots[uKnot] - knots[uKnot-1]\\n            gl_Position = aParameters;\\n        }\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeCurveSamplesCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeCurveSamplesCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = \"\\n        void ComputeCurveSamples(in int maxSamples, out float uSamples)\\n        {\\n            float sampleRate = 0.0;\\n            if (outData.uInterval > 0.0)\\n            {\\n                float minRate = 1.0 / outData.uInterval;\\n                if (outData.uOrder < 3)\\n                {\\n                    // It's a line or point, so just do the minimum sample.\\n                    sampleRate = minRate;\\n                }\\n                else\\n                {\\n                    int i = outData.uKnot - outData.uOrder;\\n                    int coefficientOffset = header + outData.uOrder + outData.uN + 4 * i;\\n                    vec4 coefficient0 = vec4(\\n                        texelFetch(uSplineData, coefficientOffset+0).x, \\n                        texelFetch(uSplineData, coefficientOffset+1).x,\\n                        texelFetch(uSplineData, coefficientOffset+2).x,\\n                        texelFetch(uSplineData, coefficientOffset+3).x);\\n                    coefficientOffset += 4;\\n                    vec4 coefficient1 = vec4(\\n                        texelFetch(uSplineData, coefficientOffset+0).x, \\n                        texelFetch(uSplineData, coefficientOffset+1).x,\\n                        texelFetch(uSplineData, coefficientOffset+2).x,\\n                        texelFetch(uSplineData, coefficientOffset+3).x);\\n                    float gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+1).x; // uKnots[i+uOrder] - uKnots[i+1]\\n                    vec3 dPoint0 = ((outData.uOrder - 1) / gap) * (coefficient1.xyz - coefficient0.xyz);\\n                    while (i < outData.uKnot-2)\\n                    {\\n                        coefficientOffset += 4;\\n                        vec4 coefficient2 = vec4(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x,\\n                            texelFetch(uSplineData, coefficientOffset+3).x);\\n                        gap = texelFetch(uSplineData, header + i+1+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+1+uOrder] - uKnots[i+2]\\n                        vec3 dPoint1 = ((outData.uOrder - 1) / gap) * (coefficient2.xyz - coefficient1.xyz);\\n                        gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+uOrder] - uKnots[i+2]\\n                        vec3 d2Point = ((outData.uOrder - 2) / gap) * (dPoint1 - dPoint0);\\n\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient0, dPoint0, d2Point, minRate));\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient1, dPoint0, d2Point, minRate));\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient1, dPoint1, d2Point, minRate));\\n                        sampleRate = max(sampleRate, ComputeSampleRate(coefficient2, dPoint1, d2Point, minRate));\\n\\n                        coefficient0 = coefficient1;\\n                        coefficient1 = coefficient2;\\n                        dPoint0 = dPoint1;\\n                        i++;\\n                    }\\n                }\\n            }\\n            uSamples = min(floor(0.5 + outData.uInterval * sampleRate), maxSamples);\\n        }\\n    \""}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveTCShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveTCShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n\\n        layout (vertices = 1) out;\\n\\n        const int header = 2;\\n\\n        in SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} inData[];\\n\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform samplerBuffer uSplineData;\\n\\n        patch out SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} outData;\\n\\n        {computeSampleRateCode}\\n\\n        {computeCurveSamplesCode}\\n\\n        void main()\\n        {{\\n            outData = inData[gl_InvocationID];\\n            gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;\\n\\n            float uSamples = 0.0;\\n            ComputeCurveSamples(gl_MaxTessGenLevel, uSamples);\\n            gl_TessLevelOuter[0] = 1.0;\\n            gl_TessLevelOuter[1] = uSamples;\\n        }}\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveTEShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveTEShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n\\n        layout (isolines) in;\\n\\n        const int header = 2;\\n\\n        patch in SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} inData;\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform samplerBuffer uSplineData;\\n\\n        {computeBSplineCode}\\n\\n        void main()\\n        {{\\n            float uBSpline[{maxOrder}];\\n            float duBSpline[{maxOrder}];\\n            ComputeBSpline(header, inData.uOrder, inData.uN, inData.uKnot,\\n                inData.u + gl_TessCoord.x * inData.uInterval, \\n                uBSpline, duBSpline);\\n            \\n            vec4 point = vec4(0.0, 0.0, 0.0, 0.0);\\n            int i = header + inData.uOrder + inData.uN + 4 * (inData.uKnot - inData.uOrder);\\n            for (int b = 0; b < inData.uOrder; b++) // loop from coefficient[uKnot-order] to coefficient[uKnot]\\n            {{\\n                point.x += uBSpline[b] * texelFetch(uSplineData, i).x;\\n                point.y += uBSpline[b] * texelFetch(uSplineData, i+1).x;\\n                point.z += uBSpline[b] * texelFetch(uSplineData, i+2).x;\\n                point.w += uBSpline[b] * texelFetch(uSplineData, i+3).x;\\n                i += 4;\\n            }}\\n\\n            gl_Position = uProjectionMatrix * point;\\n        }}\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveGeometryShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveGeometryShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = \"\\n        #version 330 core\\n\\n        layout( points ) in;\\n        layout( line_strip, max_vertices = 256 ) out;\\n\\n        const int header = 2;\\n\\n        in SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} inData[];\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform samplerBuffer uSplineData;\\n\\n        struct SplineInfo\\n        {{\\n            int uOrder;\\n            int uN;\\n            int uKnot;\\n            float u;\\n            float uInterval;\\n        }} outData; // We don't output outData (too many components per vertex), but we do use it in ComputeCurveSamples.\\n\\n        {computeSampleRateCode}\\n\\n        {computeCurveSamplesCode}\\n\\n        {computeBSplineCode}\\n\\n        void main()\\n        {{\\n            float uSamples = 0.0;\\n\\n            outData.uOrder = inData[0].uOrder;\\n            outData.uN = inData[0].uN;\\n            outData.uKnot = inData[0].uKnot;\\n            outData.u = inData[0].u;\\n            outData.uInterval = inData[0].uInterval;\\n            ComputeCurveSamples(gl_MaxGeometryOutputVertices - 1, uSamples);\\n\\n            if (uSamples > 0.0)\\n            {{\\n                float uBSpline[{maxOrder}];\\n                float duBSpline[{maxOrder}];\\n                float u = outData.u;\\n                float deltaU = outData.uInterval / uSamples;\\n                int iOffset = header + outData.uOrder + outData.uN + 4 * (outData.uKnot - outData.uOrder);\\n\\n                for (int uSample = 0; uSample <= uSamples; uSample++)\\n                {{\\n                    ComputeBSpline(header, outData.uOrder, outData.uN, outData.uKnot,\\n                        u, uBSpline, duBSpline);\\n                    \\n                    vec4 point = vec4(0.0, 0.0, 0.0, 0.0);\\n                    int i = iOffset;\\n                    for (int b = 0; b < outData.uOrder; b++) // loop from coefficient[uKnot-order] to coefficient[uKnot]\\n                    {{\\n                        point.x += uBSpline[b] * texelFetch(uSplineData, i).x;\\n                        point.y += uBSpline[b] * texelFetch(uSplineData, i+1).x;\\n                        point.z += uBSpline[b] * texelFetch(uSplineData, i+2).x;\\n                        point.w += uBSpline[b] * texelFetch(uSplineData, i+3).x;\\n                        i += 4;\\n                    }}\\n\\n                    gl_Position = uProjectionMatrix * point;\\n                    EmitVertex();\\n                    u += deltaU;                    \\n                }}\\n                EndPrimitive();\\n            }}\\n        }}\\n    \""}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.curveFragmentShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.curveFragmentShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n     \\n        uniform vec4 uLineColor;\\n\\n        out vec4 color;\\n     \\n        void main()\\n        {\\n            color = uLineColor;\\n        }\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceVertexShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceVertexShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n\\n        const int header = 4;\\n     \\n        attribute vec4 aParameters;\\n\\n        uniform samplerBuffer uSplineData;\\n\\n        out SplineInfo\\n        {\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        } outData;\\n\\n        void main()\\n        {\\n            outData.uOrder = int(texelFetch(uSplineData, 0).x);\\n            outData.vOrder = int(texelFetch(uSplineData, 1).x);\\n            outData.uN = int(texelFetch(uSplineData, 2).x);\\n            outData.vN = int(texelFetch(uSplineData, 3).x);\\n            int stride = outData.uN - outData.uOrder + 1;\\n\\n            outData.uKnot = min(int(mod(gl_InstanceID, stride)) + outData.uOrder, outData.uN);\\n            outData.vKnot = min(int(gl_InstanceID / stride) + outData.vOrder, outData.vN);\\n            outData.uFirst = texelFetch(uSplineData, header + outData.uOrder - 1).x; // uKnots[uOrder-1]\\n            outData.vFirst = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vOrder - 1).x; // vKnots[vOrder-1]\\n            outData.uSpan = texelFetch(uSplineData, header + outData.uN).x - outData.uFirst; // uKnots[uN] - uKnots[uOrder-1]\\n            outData.vSpan = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vN).x - outData.vFirst; // vKnots[vN] - vKnots[vOrder-1]\\n            outData.u = texelFetch(uSplineData, header + outData.uKnot - 1).x; // uKnots[uKnot-1]\\n            outData.v = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vKnot - 1).x; // vKnots[vKnot-1]\\n            outData.uInterval = texelFetch(uSplineData, header + outData.uKnot).x - outData.u; // uKnots[uKnot] - uKnots[uKnot-1]\\n            outData.vInterval = texelFetch(uSplineData, header + outData.uOrder + outData.uN + outData.vKnot).x - outData.v; // vKnots[vKnot] - vKnots[vKnot-1]\\n            gl_Position = aParameters;\\n        }\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.computeSurfaceSamplesCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.computeSurfaceSamplesCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = \"\\n        void ComputeSurfaceSamples(in int maxSamples, out float uSamples[3], out float vSamples[3])\\n        {{\\n            // Computes sample counts for u and v for the left side ([0]), middle ([1]), and right side ([2]).\\n            // The left side sample count matches the right side sample count for the previous knot.\\n            // The middle sample count is the number of samples between knots (same as ComputeCurveSamples).\\n            float sampleRate[3] = float[3](0.0, 0.0, 0.0);\\n            if (outData.uInterval > 0.0)\\n            {{\\n                float minRate = 1.0 / outData.uInterval;\\n                if (outData.uOrder < 3)\\n                {{\\n                    // It's a plane or point, so just do the minimum sample.\\n                    sampleRate = float[3](minRate, minRate, minRate);\\n                }}\\n                else\\n                {{\\n                    float sampleRateLeft[{maxOrder}];\\n                    float sampleRateRight[{maxOrder}];\\n\\n                    for (int k = 0; k < outData.uOrder; k++)\\n                    {{\\n                        sampleRateLeft[k] = 0.0;\\n                        sampleRateRight[k] = 0.0;\\n                    }}\\n                    for (int j = outData.vKnot-outData.vOrder; j < outData.vKnot; j++)\\n                    {{\\n                        int i = max(outData.uKnot - 1 - outData.uOrder, 0);\\n                        int iLimit = min(outData.uKnot - 1, outData.uN - 2);\\n                        int coefficientOffset = header + outData.uOrder+outData.uN + outData.vOrder+outData.vN + 4*outData.uN*j + 4*i;\\n                        vec4 coefficient0 = vec4(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x,\\n                            texelFetch(uSplineData, coefficientOffset+3).x);\\n                        coefficientOffset += 4;\\n                        vec4 coefficient1 = vec4(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x,\\n                            texelFetch(uSplineData, coefficientOffset+3).x);\\n                        float gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+1).x; // uKnots[i+uOrder] - uKnots[i+1]\\n                        vec3 dPoint0 = ((outData.uOrder - 1) / gap) * (coefficient1.xyz - coefficient0.xyz);\\n                        while (i < iLimit)\\n                        {{\\n                            coefficientOffset += 4;\\n                            vec4 coefficient2 = vec4(\\n                                texelFetch(uSplineData, coefficientOffset+0).x, \\n                                texelFetch(uSplineData, coefficientOffset+1).x,\\n                                texelFetch(uSplineData, coefficientOffset+2).x,\\n                                texelFetch(uSplineData, coefficientOffset+3).x);\\n                            gap = texelFetch(uSplineData, header + i+1+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+1+uOrder] - uKnots[i+2]\\n                            vec3 dPoint1 = ((outData.uOrder - 1) / gap) * (coefficient2.xyz - coefficient1.xyz);\\n                            gap = texelFetch(uSplineData, header + i+outData.uOrder).x - texelFetch(uSplineData, header + i+2).x; // uKnots[i+uOrder] - uKnots[i+2]\\n                            vec3 d2Point = ((outData.uOrder - 2) / gap) * (dPoint1 - dPoint0);\\n\\n                            int k = i - outData.uKnot + 1 + outData.uOrder;\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient0, dPoint0, d2Point, minRate));\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient1, dPoint0, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient1, dPoint1, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient2, dPoint1, d2Point, minRate));\\n\\n                            coefficient0 = coefficient1;\\n                            coefficient1 = coefficient2;\\n                            dPoint0 = dPoint1;\\n                            i++;\\n                        }}\\n                    }}\\n                    for (int k = 1; k < outData.uOrder - 1; k++)\\n                    {{\\n                        sampleRate[0] = max(sampleRate[0], sampleRateRight[k-1]);\\n                        sampleRate[0] = max(sampleRate[0], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateLeft[k+1]);\\n                    }}\\n                }}\\n            }}\\n            uSamples[0] = min(floor(0.5 + outData.uInterval * sampleRate[0]), maxSamples);\\n            uSamples[1] = min(floor(0.5 + outData.uInterval * sampleRate[1]), maxSamples);\\n            uSamples[2] = min(floor(0.5 + outData.uInterval * sampleRate[2]), maxSamples);\\n\\n            sampleRate = float[3](0.0, 0.0, 0.0);\\n            if (outData.vInterval > 0.0)\\n            {{\\n                float minRate = 1.0 / outData.vInterval;\\n                if (outData.vOrder < 3)\\n                {{\\n                    // It's a plane or point, so just do the minimum sample.\\n                    sampleRate = float[3](minRate, minRate, minRate);\\n                }}\\n                else\\n                {{\\n                    float sampleRateLeft[{maxOrder}];\\n                    float sampleRateRight[{maxOrder}];\\n\\n                    for (int k = 0; k < outData.vOrder; k++)\\n                    {{\\n                        sampleRateLeft[k] = 0.0;\\n                        sampleRateRight[k] = 0.0;\\n                    }}\\n                    for (int i = outData.uKnot-outData.uOrder; i < outData.uKnot; i++)\\n                    {{\\n                        int j = max(outData.vKnot - 1 - outData.vOrder, 0);\\n                        int jLimit = min(outData.vKnot - 1, outData.vN - 2);\\n                        int coefficientOffset = header + outData.uOrder+outData.uN + outData.vOrder+outData.vN + 4*outData.uN*j + 4*i;\\n                        vec4 coefficient0 = vec4(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x,\\n                            texelFetch(uSplineData, coefficientOffset+3).x);\\n                        coefficientOffset += 4*outData.uN;\\n                        vec4 coefficient1 = vec4(\\n                            texelFetch(uSplineData, coefficientOffset+0).x, \\n                            texelFetch(uSplineData, coefficientOffset+1).x,\\n                            texelFetch(uSplineData, coefficientOffset+2).x,\\n                            texelFetch(uSplineData, coefficientOffset+3).x);\\n                        float gap = texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+outData.vOrder).x - texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+1).x; // vKnots[j+vOrder] - vKnots[j+1]\\n                        vec3 dPoint0 = ((outData.vOrder - 1) / gap) * (coefficient1.xyz - coefficient0.xyz);\\n                        while (j < jLimit)\\n                        {{\\n                            coefficientOffset += 4*outData.uN;\\n                            vec4 coefficient2 = vec4(\\n                                texelFetch(uSplineData, coefficientOffset+0).x, \\n                                texelFetch(uSplineData, coefficientOffset+1).x,\\n                                texelFetch(uSplineData, coefficientOffset+2).x,\\n                                texelFetch(uSplineData, coefficientOffset+3).x);\\n                            gap = texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+1+outData.vOrder).x - texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+2).x; // vKnots[j+1+vOrder] - vKnots[j+2]\\n                            vec3 dPoint1 = ((outData.vOrder - 1) / gap) * (coefficient2.xyz - coefficient1.xyz);\\n                            gap = texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+outData.vOrder).x - texelFetch(uSplineData, header + outData.uOrder+outData.uN + j+2).x; // vKnots[j+vOrder] - vKnots[j+2]\\n                            vec3 d2Point = ((outData.vOrder - 2) / gap) * (dPoint1 - dPoint0);\\n\\n                            int k = j - outData.vKnot + 1 + outData.vOrder;\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient0, dPoint0, d2Point, minRate));\\n                            sampleRateLeft[k] = max(sampleRateLeft[k], ComputeSampleRate(coefficient1, dPoint0, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient1, dPoint1, d2Point, minRate));\\n                            sampleRateRight[k] = max(sampleRateRight[k], ComputeSampleRate(coefficient2, dPoint1, d2Point, minRate));\\n\\n                            coefficient0 = coefficient1;\\n                            coefficient1 = coefficient2;\\n                            dPoint0 = dPoint1;\\n                            j++;\\n                        }}\\n                    }}\\n                    for (int k = 1; k < outData.vOrder - 1; k++)\\n                    {{\\n                        sampleRate[0] = max(sampleRate[0], sampleRateRight[k-1]);\\n                        sampleRate[0] = max(sampleRate[0], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateLeft[k]);\\n                        sampleRate[1] = max(sampleRate[1], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateRight[k]);\\n                        sampleRate[2] = max(sampleRate[2], sampleRateLeft[k+1]);\\n                    }}\\n                }}\\n            }}\\n            vSamples[0] = min(floor(0.5 + outData.vInterval * sampleRate[0]), maxSamples);\\n            vSamples[1] = min(floor(0.5 + outData.vInterval * sampleRate[1]), maxSamples);\\n            vSamples[2] = min(floor(0.5 + outData.vInterval * sampleRate[2]), maxSamples);\\n        }}\\n    \""}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceTCShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceTCShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n\\n        layout (vertices = 1) out;\\n\\n        const int header = 4;\\n\\n        in SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} inData[];\\n\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform samplerBuffer uSplineData;\\n\\n        patch out SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} outData;\\n\\n        {computeSampleRateCode}\\n\\n        {computeSurfaceSamplesCode}\\n\\n        void main()\\n        {{\\n            outData = inData[gl_InvocationID];\\n            gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;\\n\\n            float uSamples[3];\\n            float vSamples[3];\\n            ComputeSurfaceSamples(gl_MaxTessGenLevel, uSamples, vSamples);\\n            gl_TessLevelOuter[0] = vSamples[0] > 0.0 ? vSamples[0] : vSamples[1];\\n            gl_TessLevelOuter[1] = uSamples[0] > 0.0 ? uSamples[0] : uSamples[1];\\n            gl_TessLevelOuter[2] = vSamples[2] > 0.0 ? vSamples[2] : vSamples[1];\\n            gl_TessLevelOuter[3] = uSamples[2] > 0.0 ? uSamples[2] : uSamples[1];\\n            gl_TessLevelInner[0] = uSamples[1];\\n            gl_TessLevelInner[1] = vSamples[1];\\n        }}\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceTEShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceTEShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n\\n        layout (quads) in;\\n\\n        const int header = 4;\\n\\n        patch in SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} inData;\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform vec3 uScreenScale;\\n        uniform samplerBuffer uSplineData;\\n\\n        flat out SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} outData;\\n        out vec4 worldPosition;\\n        out vec3 normal;\\n        out vec2 parameters;\\n        out vec2 pixelPer;\\n\\n        {computeBSplineCode}\\n\\n        void main()\\n        {{\\n            float uBSpline[{maxOrder}];\\n            float duBSpline[{maxOrder}];\\n            parameters.x = inData.u + gl_TessCoord.x * inData.uInterval;\\n            ComputeBSpline(header, inData.uOrder, inData.uN, inData.uKnot, parameters.x, uBSpline, duBSpline);\\n\\n            float vBSpline[{maxOrder}];\\n            float dvBSpline[{maxOrder}];\\n            parameters.y = inData.v + gl_TessCoord.y * inData.vInterval;\\n            ComputeBSpline(header + inData.uOrder+inData.uN, inData.vOrder, inData.vN, inData.vKnot, parameters.y, vBSpline, dvBSpline);\\n            \\n            vec4 point = vec4(0.0, 0.0, 0.0, 0.0);\\n            vec3 duPoint = vec3(0.0, 0.0, 0.0);\\n            vec3 dvPoint = vec3(0.0, 0.0, 0.0);\\n            int j = header + inData.uOrder+inData.uN + inData.vOrder+inData.vN + (inData.vKnot - inData.vOrder) * inData.uN * 4;\\n            for (int vB = 0; vB < inData.vOrder; vB++)\\n            {{\\n                int i = j + (inData.uKnot - inData.uOrder) * 4;\\n                for (int uB = 0; uB < inData.uOrder; uB++)\\n                {{\\n                    point.x += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                    point.y += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                    point.z += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                    point.w += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+3).x;\\n                    duPoint.x += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                    duPoint.y += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                    duPoint.z += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                    dvPoint.x += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i).x;\\n                    dvPoint.y += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                    dvPoint.z += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                    i += 4;\\n                }}\\n                j += inData.uN * 4;\\n            }}\\n\\n            outData = inData;\\n\\n            worldPosition = point;\\n            normal = normalize(cross(duPoint, dvPoint));\\n            float zScale = 1.0 / (point.z * point.z);\\n            pixelPer.x = zScale * max(uScreenScale.x * abs(point.x * duPoint.z - duPoint.x * point.z), uScreenScale.y * abs(point.y * duPoint.z - duPoint.y * point.z));\\n            pixelPer.y = zScale * max(uScreenScale.x * abs(point.x * dvPoint.z - dvPoint.x * point.z), uScreenScale.y * abs(point.y * dvPoint.z - dvPoint.y * point.z));\\n            gl_Position = uProjectionMatrix * point;\\n        }}\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceGeometryShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceGeometryShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = \"\\n        #version 330 core\\n\\n        layout( points ) in;\\n        layout( triangle_strip, max_vertices = 256 ) out;\\n\\n        const int header = 4;\\n\\n        in SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} inData[];\\n\\n        uniform mat4 uProjectionMatrix;\\n        uniform vec3 uScreenScale;\\n        uniform vec4 uClipBounds;\\n        uniform vec4 uFillColor;\\n        uniform vec3 uLightDirection;\\n        uniform samplerBuffer uSplineData;\\n\\n        out vec3 splineColor; // We only output a color to reduce the number of components per vertex.\\n\\n        struct SplineInfo\\n        {{\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        }} outData; // We don't output outData (too many components per vertex), but we do use it in ComputeSurfaceSamples.\\n\\n        {computeSampleRateCode}\\n\\n        {computeSurfaceSamplesCode}\\n\\n        {computeBSplineCode}\\n\\n        void main() \\n        {{\\n            float uFullSamples[3];\\n            float vFullSamples[3];\\n\\n            outData.uOrder = inData[0].uOrder;\\n            outData.vOrder = inData[0].vOrder;\\n            outData.uN = inData[0].uN;\\n            outData.vN = inData[0].vN;\\n            outData.uKnot = inData[0].uKnot;\\n            outData.vKnot = inData[0].vKnot;\\n            outData.u = inData[0].u;\\n            outData.v = inData[0].v;\\n            outData.uInterval = inData[0].uInterval;\\n            outData.vInterval = inData[0].vInterval;\\n            int maxVertices = gl_MaxGeometryTotalOutputComponents / 7; // The number of output components per vertex is 7 = position.xyzw + splineColor.rgb\\n            ComputeSurfaceSamples(maxVertices, uFullSamples, vFullSamples);\\n\\n            if (uFullSamples[1] > 0.0 && vFullSamples[1] > 0.0)\\n            {{\\n                float alpha = maxVertices / (2.0 * uFullSamples[1] * (vFullSamples[1] + 1.0));\\n                if (alpha < 1.0)\\n                {{\\n                    alpha = sqrt(alpha);\\n                    uFullSamples[1] = alpha * uFullSamples[1];\\n                    vFullSamples[1] = alpha * (vFullSamples[1] + 1.0) - 1.0;\\n                }}\\n                int uSamples = int(uFullSamples[1]);\\n                int vSamples = int(vFullSamples[1]);\\n\\n                float uBSpline[{maxOrder}];\\n                float duBSpline[{maxOrder}];\\n                float uBSplineNext[{maxOrder}];\\n                float duBSplineNext[{maxOrder}];\\n                float vBSpline[{maxOrder}];\\n                float dvBSpline[{maxOrder}];\\n                float deltaU = outData.uInterval / uSamples;\\n                float deltaV = outData.vInterval / vSamples;\\n                float u = outData.u;\\n                ComputeBSpline(header, outData.uOrder, outData.uN, outData.uKnot, u, uBSpline, duBSpline);\\n\\n                int jOffset = header + outData.uOrder+outData.uN + outData.vOrder+outData.vN + (outData.vKnot - outData.vOrder) * outData.uN * 4;\\n                int iOffset = (outData.uKnot - outData.uOrder) * 4;\\n\\n                for (int uSample = 0; uSample < uSamples; uSample++)\\n                {{\\n                    float uNext = u + deltaU;\\n                    ComputeBSpline(header, outData.uOrder, outData.uN, outData.uKnot, uNext, uBSplineNext, duBSplineNext);\\n                        \\n                    float v = outData.v;\\n                    for (int vSample = 0; vSample <= vSamples; vSample++)\\n                    {{\\n                        ComputeBSpline(header + outData.uOrder+outData.uN, outData.vOrder, outData.vN, outData.vKnot, v, vBSpline, dvBSpline);\\n\\n                        vec4 point = vec4(0.0, 0.0, 0.0, 0.0);\\n                        vec3 duPoint = vec3(0.0, 0.0, 0.0);\\n                        vec3 dvPoint = vec3(0.0, 0.0, 0.0);\\n                        int j = jOffset;\\n                        for (int vB = 0; vB < outData.vOrder; vB++)\\n                        {{\\n                            int i = j + iOffset;\\n                            for (int uB = 0; uB < outData.uOrder; uB++)\\n                            {{\\n                                point.x += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                point.y += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                point.z += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                point.w += uBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+3).x;\\n                                duPoint.x += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                duPoint.y += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                duPoint.z += duBSpline[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                dvPoint.x += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                dvPoint.y += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                dvPoint.z += uBSpline[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                i += 4;\\n                            }}\\n                            j += outData.uN * 4;\\n                        }}\\n                        vec3 normal = normalize(cross(duPoint, dvPoint));\\n                        float specular = pow(abs(dot(normal, normalize(uLightDirection + point.xyz / length(point)))), 25.0);\\n                        splineColor = (0.3 + 0.5 * abs(dot(normal, uLightDirection)) + 0.2 * specular) * uFillColor.rgb;\\n                        gl_Position = uProjectionMatrix * point;\\n                        EmitVertex();\\n\\n                        point = vec4(0.0, 0.0, 0.0, 0.0);\\n                        duPoint = vec3(0.0, 0.0, 0.0);\\n                        dvPoint = vec3(0.0, 0.0, 0.0);\\n                        j = jOffset;\\n                        for (int vB = 0; vB < outData.vOrder; vB++)\\n                        {{\\n                            int i = j + iOffset;\\n                            for (int uB = 0; uB < outData.uOrder; uB++)\\n                            {{\\n                                point.x += uBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                point.y += uBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                point.z += uBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                point.w += uBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+3).x;\\n                                duPoint.x += duBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                duPoint.y += duBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                duPoint.z += duBSplineNext[uB] * vBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                dvPoint.x += uBSplineNext[uB] * dvBSpline[vB] * texelFetch(uSplineData, i).x;\\n                                dvPoint.y += uBSplineNext[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+1).x;\\n                                dvPoint.z += uBSplineNext[uB] * dvBSpline[vB] * texelFetch(uSplineData, i+2).x;\\n                                i += 4;\\n                            }}\\n                            j += outData.uN * 4;\\n                        }}\\n                        normal = normalize(cross(duPoint, dvPoint));\\n                        specular = pow(abs(dot(normal, normalize(uLightDirection + point.xyz / length(point)))), 25.0);\\n                        splineColor = (0.3 + 0.5 * abs(dot(normal, uLightDirection)) + 0.2 * specular) * uFillColor.rgb;\\n                        gl_Position = uProjectionMatrix * point;\\n                        EmitVertex();\\n\\n                        v += deltaV;                    \\n                    }}\\n                    EndPrimitive();\\n                    u = uNext;\\n                    uBSpline = uBSplineNext;\\n                    duBSpline = duBSplineNext;\\n                }}\\n            }}\\n        }}\\n    \""}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceSimpleFragmentShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceSimpleFragmentShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 330 core\\n     \\n        in vec3 splineColor;\\n        out vec3 color;\\n     \\n        void main() {\\n            color = splineColor;\\n        }\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.surfaceFragmentShaderCode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.surfaceFragmentShaderCode", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\\n        #version 410 core\\n     \\n        flat in SplineInfo\\n        {\\n            int uOrder, vOrder;\\n            int uN, vN;\\n            int uKnot, vKnot;\\n            float uFirst, vFirst;\\n            float uSpan, vSpan;\\n            float u, v;\\n            float uInterval, vInterval;\\n        } inData;\\n        in vec4 worldPosition;\\n        in vec3 normal;\\n        in vec2 parameters;\\n        in vec2 pixelPer;\\n\\n        uniform vec4 uFillColor;\\n        uniform vec4 uLineColor;\\n        uniform vec3 uLightDirection;\\n        uniform int uOptions;\\n\\n        out vec4 color;\\n     \\n        void main()\\n        {\\n            float specular = pow(abs(dot(normal, normalize(uLightDirection + worldPosition.xyz / length(worldPosition)))), 25.0);\\n            bool line = (uOptions & (1 << 2)) > 0 && (pixelPer.x * (parameters.x - inData.uFirst) < 1.5 || pixelPer.x * (inData.uFirst + inData.uSpan - parameters.x) < 1.5);\\n            line = line || ((uOptions & (1 << 2)) > 0 && (pixelPer.y * (parameters.y - inData.vFirst) < 1.5 || pixelPer.y * (inData.vFirst + inData.vSpan - parameters.y) < 1.5));\\n            line = line || ((uOptions & (1 << 3)) > 0 && pixelPer.x * (parameters.x - inData.u) < 1.5);\\n            line = line || ((uOptions & (1 << 3)) > 0 && pixelPer.y * (parameters.y - inData.v) < 1.5);\\n            color = line ? uLineColor : ((uOptions & (1 << 1)) > 0 ? uFillColor : vec4(0.0, 0.0, 0.0, 0.0));\\n            color.rgb = (0.3 + 0.5 * abs(dot(normal, uLightDirection)) + 0.2 * specular) * color.rgb;\\n            if (color.a == 0.0)\\n                discard;\\n        }\\n    '"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetInitialView", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetInitialView", "type": "function", "doc": "<p>Set the initial view values used when reseting the view.</p>\n", "signature": "(self, eye, look, up)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetBackgroundColor", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetBackgroundColor", "type": "function", "doc": "<p>Set the background color for the frame.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (<code>float</code>, <code>int</code> or array-like of floats or ints):\nThe red value [0, 1] as a float, [0, 255] as an int, or the rgb or rgba value as floats or ints (default).</li>\n<li><strong>g</strong> (<code>float</code> or <code>int</code>):\nThe green value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>b</strong> (<code>float</code> or <code>int</code>):\nThe blue value [0, 1] as a float or [0, 255] as an int.</li>\n<li><strong>a</strong> (<code>float</code>, <code>int</code>, or None):\nThe alpha value [0, 1] as a float or [0, 255] as an int. If <code>None</code> then alpha is set to 1.</li>\n</ul>\n", "signature": "(self, r, g=None, b=None, a=None)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetSplineList", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetSplineList", "type": "function", "doc": "<p>Set the <code>DrawableSpline</code> list which determines the splines to display.</p>\n", "signature": "(self, list)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.ResetView", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.ResetView", "type": "function", "doc": "<p>Update the view position to initial values.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.initgl", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.initgl", "type": "function", "doc": "<p>Handle <code>OpenGLFrame</code> initgl action. Calls <code>CreateGLResources</code> and <code>HandleScreenSizeUpdate</code>.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.CreateGLResources", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.CreateGLResources", "type": "function", "doc": "<p>Create OpenGL resources upon creation of the frame and window recovery (un-minimize).</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.HandleScreenSizeUpdate", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.HandleScreenSizeUpdate", "type": "function", "doc": "<p>Handle window size update (typically after a window resize).</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.redraw", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.redraw", "type": "function", "doc": "<p>Handle <code>OpenGLFrame</code> redraw action. Updates view and draws spline list.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.Unmap", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.Unmap", "type": "function", "doc": "<p>Handle window unmap.</p>\n", "signature": "(self, event)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.Update", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.Update", "type": "function", "doc": "<p>Update the frame, typically after updating the spline list.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.Reset", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.Reset", "type": "function", "doc": "<p>Reset the view and update the frame.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetMode", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetMode", "type": "function", "doc": "<p>Set the view mode for the frame.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mode</strong> (<code>int</code> with the following values:):\n<ul>\n<li><code>SplineOpenGLFrame.ROTATE</code> Dragging the left mouse rotates the view.</li>\n<li><code>SplineOpenGLFrame.PAN</code> Dragging the left mouse pans the view.</li>\n<li><code>SplineOpenGLFrame.FLY</code> Dragging the left mouse flies toward the mouse position.</li>\n</ul></li>\n</ul>\n", "signature": "(self, mode)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.SetScale", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.SetScale", "type": "function", "doc": "<p>Set the flying speed scale.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scale</strong> (<code>float</code>):\nSpeed scale betwen 0 and 1.</li>\n</ul>\n", "signature": "(self, scale)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseDown", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseDown", "type": "function", "doc": "<p>Handle mouse down event.</p>\n", "signature": "(self, event)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseMove", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseMove", "type": "function", "doc": "<p>Handle mouse move event.</p>\n", "signature": "(self, event)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseUp", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseUp", "type": "function", "doc": "<p>Handle mouse up event.</p>\n", "signature": "(self, event)", "funcdef": "def"}, {"fullname": "bspy.splineOpenGLFrame.SplineOpenGLFrame.MouseWheel", "modulename": "bspy.splineOpenGLFrame", "qualname": "SplineOpenGLFrame.MouseWheel", "type": "function", "doc": "<p>Handle mouse wheel event.</p>\n", "signature": "(self, event)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();