<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 10.0.1"/>
    <title>bspy.spline API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../bspy.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;bspy</a>


            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>



        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="class" href="#Spline">Spline</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Spline.__init__">Spline</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.add">add</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.blossom">blossom</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.bsplineValues">bsplineValues</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.clamp">clamp</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.common_basis">common_basis</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.cross">cross</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.derivative">derivative</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.differentiate">differentiate</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.domain">domain</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.dot">dot</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.elevate">elevate</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.elevate_and_insert_knots">elevate_and_insert_knots</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.evaluate">evaluate</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.extrapolate">extrapolate</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.fold">fold</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.insert_knots">insert_knots</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.least_squares">least_squares</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.load">load</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.multiply">multiply</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.range_bounds">range_bounds</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.remove_knots">remove_knots</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.reparametrize">reparametrize</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.save">save</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.scale">scale</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.subtract">subtract</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.transform">transform</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.translate">translate</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.trim">trim</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.unfold">unfold</a>
                        </li>
                        <li>
                                <a class="function" href="#Spline.zeros">zeros</a>
                        </li>
                </ul>

            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../bspy.html">bspy</a><wbr>.spline    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">bspy._spline_domain</span>
<span class="kn">import</span> <span class="nn">bspy._spline_evaluation</span>
<span class="kn">import</span> <span class="nn">bspy._spline_intersection</span>
<span class="kn">import</span> <span class="nn">bspy._spline_fitting</span>
<span class="kn">import</span> <span class="nn">bspy._spline_operations</span>

<span class="k">def</span> <span class="nf">_isIterable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">Spline</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to model, represent, and process piecewise polynomial tensor product</span>
<span class="sd">    functions (spline functions) as linear combinations of B-splines. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nInd : `int`</span>
<span class="sd">        The number of independent variables of the spline</span>

<span class="sd">    nDep : `int`</span>
<span class="sd">        The number of dependent variables of the spline</span>
<span class="sd">    </span>
<span class="sd">    order : `tuple`</span>
<span class="sd">        A tuple of length nInd where each integer entry represents the</span>
<span class="sd">        polynomial order of the function in that variable</span>

<span class="sd">    nCoef : `tuple`</span>
<span class="sd">        A tuple of length nInd where each integer entry represents the</span>
<span class="sd">        dimension (i.e. number of B-spline coefficients) of the function</span>
<span class="sd">        space in that variable</span>

<span class="sd">    knots : `list`</span>
<span class="sd">        A list of the lists of the knots of the spline in each independent variable</span>

<span class="sd">    coefs : array-like</span>
<span class="sd">        A list of the B-spline coefficients of the spline.</span>
<span class="sd">    </span>
<span class="sd">    accuracy : `float`, optional</span>
<span class="sd">        Each spline function is presumed to be an approximation of something else. </span>
<span class="sd">        The `accuracy` stores the infinity norm error of the difference between </span>
<span class="sd">        the given spline function and that something else. Default is zero.</span>

<span class="sd">    metadata : `dict`, optional</span>
<span class="sd">        A dictionary of ancillary data to store with the spline. Default is {}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nInd</span><span class="p">,</span> <span class="n">nDep</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">nCoef</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="k">assert</span> <span class="n">nInd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nInd &lt; 0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nInd</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nDep</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nDep &lt; 0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nDep</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(order) != nInd&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nCoef</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(nCoef) != nInd&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nCoef</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">)</span> <span class="o">==</span> <span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(knots) != nInd&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">)):</span>
            <span class="n">nKnots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">nKnots</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;Knots array for variable </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> should have length </span><span class="si">{</span><span class="n">nKnots</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">knots</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">knots</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">nCoef</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCoef</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">order</span><span class="p">],</span>\
                       <span class="s2">&quot;Improperly ordered knot sequence&quot;</span>
        <span class="n">totalCoefs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">nCoef</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">:</span>
            <span class="n">totalCoefs</span> <span class="o">*=</span> <span class="n">nCoef</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="n">totalCoefs</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Length of coefs should be </span><span class="si">{</span><span class="n">totalCoefs</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="n">totalCoefs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">uvw</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Spline(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span> \
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span> \
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rmatmul__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">spline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">spline</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two splines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to add to self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of adding other to self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `subtract` : Subtract two splines.</span>
<span class="sd">        `multiply` : Multiply two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `common_basis` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">blossom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the blossom of the spline at a given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvwValues : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the degree-sized vectors of blossom parameters for each independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the spline&#39;s blossom at the given blossom parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at a given parameter value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Evaluates the blossom based on blossoming algorithm 1 found in Goldman, Ronald N. &quot;Blossoming and knot insertion algorithms for B-spline curves.&quot; </span>
<span class="sd">        Computer Aided Geometric Design 7, no. 1-4 (1990): 69-81.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">blossom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bsplineValues</span><span class="p">(</span><span class="n">knot</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">splineOrder</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivativeOrder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">taylorCoefs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute bspline values or their derivatives for a 1D bspline segment given the rightmost knot of the segment and a parameter value within that segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        knot : `int`</span>
<span class="sd">            The rightmost knot in the bspline segment.</span>

<span class="sd">        knots : array-like</span>
<span class="sd">            The array of knots for the bspline.</span>
<span class="sd">        </span>
<span class="sd">        splineOrder : `int`</span>
<span class="sd">            The order of the bspline.</span>

<span class="sd">        u : `float`</span>
<span class="sd">            The parameter value within the segment at which to evaluate it.</span>
<span class="sd">        </span>
<span class="sd">        derivativeOrder : `int`, optional</span>
<span class="sd">            The order of the derivative. A zero-order derivative (default) just evaluates the bspline normally.</span>
<span class="sd">        </span>
<span class="sd">        taylorCoefs : `boolean`, optional</span>
<span class="sd">            A boolean flag that if true returns the derivatives divided by their degree factorial, that is </span>
<span class="sd">            the taylor coefficients at the given parameter values. Default is false.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the bspline or its derivative at the given parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at given parameter values.</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method does not check parameter values. It is used by other evaluation methods. It uses the de Boor recurrence relations for a B-spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">bsplineValues</span><span class="p">(</span><span class="n">knot</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">splineOrder</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivativeOrder</span><span class="p">,</span> <span class="n">taylorCoefs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure the leftmost/rightmost knot has a full order multiplicity, clamping the spline&#39;s </span>
<span class="sd">        value at the first/last knot to its first/last coefficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : `iterable`</span>
<span class="sd">            An iterable of independent variables to clamp on the left side.</span>

<span class="sd">        right : `iterable`</span>
<span class="sd">            An iterable of independent variables to clamp on the right side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The clamped spline. If the spline was already clamped, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">common_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">indMap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        splines : `iterable`</span>
<span class="sd">            The collection of N - 1 splines to align (N total splines, including self).</span>

<span class="sd">        indMap : `iterable`</span>
<span class="sd">            The collection of independent variables to align. Since each spline can have multiple </span>
<span class="sd">            independent variables, `indMap` is an `iterable` of `iterables` (like a list of lists). </span>
<span class="sd">            Each collection of indices (i0, i1, .. iN) maps the i&#39;th independent variable to each other. </span>
<span class="sd">            The domains of mapped independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            If all the splines are curves (1 independent variable), then `indMap` is ((0, 0, .. 0),).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        splines : `tuple`</span>
<span class="sd">            The aligned collection of N splines.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `elevate_and_insert_knots` : Elevate a spline and insert new knots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `elevate_and_insert_knots` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">common_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">indMap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cross product a spline with `nDep` of 3 by the given vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like or `Spline`</span>
<span class="sd">            An array of length 3 or spline with `nDep` of 3 that specifies the vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The crossed spline, self x vector.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_respect_to : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the integer order of derivative for each independent variable.</span>
<span class="sd">            A zero-order derivative just evaluates the spline normally.</span>
<span class="sd">        </span>
<span class="sd">        uvw : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the values of each independent variable (the parameter values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the derivative of the spline at the given parameter values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at a given parameter value.</span>
<span class="sd">        `differentiate` : Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The derivative method uses the de Boor recurrence relations for a B-spline</span>
<span class="sd">        series to evaluate a spline function.  The non-zero B-splines are</span>
<span class="sd">        evaluated, then the dot product of those B-splines with the vector of</span>
<span class="sd">        B-spline coefficients is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_respect_to : integer, optional</span>
<span class="sd">            The number of the independent variable to differentiate. Default is zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The spline that results from differentiating the original spline with respect to the given independent variable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at a given parameter value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the domain of a spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bounds : `numpy.array`</span>
<span class="sd">            nInd x 2 array of the upper and lower bounds on each of the independent variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `reparametrize` : Reparametrize a spline to match new domain bounds</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dot product a spline by the given vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like or `Spline`</span>
<span class="sd">            An array of length `nDep` or spline with matching `nDep` that specifies the vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The dotted spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">elevate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elevate a spline, increasing its order by `m`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the non-negative integer amount to increase the order </span>
<span class="sd">            for each independent variable of the spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the order of the current spline plus `m`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `elevate_and_insert_knots` : Elevate a spline and insert new knots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. </span>
<span class="sd">        &quot;Fast degree elevation and knot insertion for B-spline curves.&quot; Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elevate_and_insert_knots</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span> <span class="o">*</span> <span class="p">[[]])</span>

    <span class="k">def</span> <span class="nf">elevate_and_insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elevate a spline and insert new knots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the non-negative integer amount to increase the order </span>
<span class="sd">            for each independent variable of the spline.</span>

<span class="sd">        newKnots : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the knots to be added to each independent variable&#39;s knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if no knots are to be added for the `ind` independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the order of the current spline plus `m` that includes the new knots.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `clamp` : Clamp the left and/or right side of a spline.</span>
<span class="sd">        `elevate` : Elevate a spline, increasing its order by `m`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. </span>
<span class="sd">        &quot;Fast degree elevation and knot insertion for B-spline curves.&quot; Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">elevate_and_insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the value of the spline at given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvw : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the values of each independent variable (the parameter values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the spline at the given parameter values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The evaluate method uses the de Boor recurrence relations for a B-spline</span>
<span class="sd">        series to evaluate a spline function.  The non-zero B-splines are</span>
<span class="sd">        evaluated, then the dot product of those B-splines with the vector of</span>
<span class="sd">        B-spline coefficients is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">,</span> <span class="n">continuityOrder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extrapolate a spline out to an extended domain maintaining a given order of continuity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as </span>
<span class="sd">            returned from `domain`). If a bound is None or nan then the original bound (and knots) are left unchanged.</span>

<span class="sd">        continuityOrder : `int`</span>
<span class="sd">            The order of continuity of the extrapolation (the number of derivatives that match at the endpoints). </span>
<span class="sd">            A continuity order of zero means the extrapolation just matches the spline value at the endpoints. </span>
<span class="sd">            The continuity order is automatically limited to one less than the degree of the spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Extrapolated spline. If all the knots are unchanged, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">,</span> <span class="n">continuityOrder</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fold the coefficients of a spline&#39;s indicated independent variables into the coefficients of the remaining independent variables, retaining the </span>
<span class="sd">        indicated independent variables&#39; knots and orders in a second spline with no coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        foldedInd : `iterable`</span>
<span class="sd">            An iterable that specifies the independent variables whose coefficients should be folded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        foldedSpline, coefficientlessSpline : `Spline`, `Spline`</span>
<span class="sd">            The folded spline and the coefficientless spline that retains the indicated independent variables&#39; knots and orders.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `unfold` : Unfold the coefficients of an original spline&#39;s indicated independent variables back into the spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.</span>
<span class="sd">        The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, </span>
<span class="sd">        all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline </span>
<span class="sd">        with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, </span>
<span class="sd">        returning the original spline.</span>

<span class="sd">        Here&#39;s an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. </span>
<span class="sd">        Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have </span>
<span class="sd">        shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn&#39;t matter </span>
<span class="sd">        so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert new knots into a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newKnots : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the knots to be added to each independent variable&#39;s knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if no knots are to be added for the `ind` independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the new knots inserted. If no knots were inserted, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `clamp` : Clamp the left and/or right side of a spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements Boehm&#39;s standard knot insertion algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">dataPoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a curve to a string of data points using the method of least squares.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataPoints : `iterable` containing the data points to fit.</span>
<span class="sd">            Each of the data points is of length nDep.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline curve which approximates the data points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_fitting</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">dataPoints</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">splineType</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span>
        <span class="n">nInd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nInd</span><span class="p">):</span>
            <span class="n">knots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;knots</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;coefficients&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">splineType</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">splineType</span> <span class="o">=</span> <span class="n">Spline</span>
        <span class="n">spline</span> <span class="o">=</span> <span class="n">splineType</span><span class="p">(</span><span class="n">nInd</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">order</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">Path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">Name</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fileName</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">spline</span>

    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">productType</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply two splines (cross, dot, or scalar product).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to multiply by self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        productType : {&#39;C&#39;, &#39;D&#39;, &#39;S&#39;}, optional</span>
<span class="sd">            The type of product to perform on the dependent variables (default is &#39;S&#39;).</span>
<span class="sd">                &#39;C&#39; is for a cross product, self x other (nDep must be 3).</span>
<span class="sd">                &#39;D&#39; is for a dot product (nDep must match).</span>
<span class="sd">                &#39;S&#39; is for a scalar product (nDep must be 1 for one of the splines).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of multiplying other to self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `add` : Add two splines.</span>
<span class="sd">        `subtract` : Subtract two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Taken in part from Lee, E. T. Y. &quot;Computing a chain of blossoms, with application to products of splines.&quot; </span>
<span class="sd">        Computer Aided Geometric Design 11, no. 6 (1994): 597-620.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span><span class="p">,</span> <span class="n">productType</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">range_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the range of a spline as upper and lower bounds on each of the</span>
<span class="sd">        dependent variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">range_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldKnots</span><span class="o">=</span><span class="p">((),),</span> <span class="n">maxRemovalsPerKnot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove interior knots from a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oldKnots : `iterable` of length `nInd`, optional</span>
<span class="sd">            An iterable that specifies the knots that can be removed from each independent variable&#39;s interior knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if all interior knots can be removed for the `ind` independent variable (the default). </span>
<span class="sd">            Knots that don&#39;t appear in the independent variable&#39;s interior knots are ignored.</span>
<span class="sd">        </span>
<span class="sd">        maxRemovalsPerKnot : `int`, optional</span>
<span class="sd">            A non-zero count of the largest number of times a knot can be removed. For example, one means that </span>
<span class="sd">            only one instance of each knot can be removed. (Zero means each knot can be removed completely, </span>
<span class="sd">            which is the default.)</span>
<span class="sd">        </span>
<span class="sd">        tolerance : `float` or `None`, optional</span>
<span class="sd">            The maximum residual error permitted after removing a knot. Knots will not be removed if the </span>
<span class="sd">            resulting residual error is above this threshold. Default is `None`, meaning all specified knots </span>
<span class="sd">            will be removed up to `maxRemovalsPerKnot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the knots removed.</span>
<span class="sd">        </span>
<span class="sd">        totalRemoved : `int`</span>
<span class="sd">            The total number of knots removed.</span>
<span class="sd">        </span>
<span class="sd">        residualError : `float`</span>
<span class="sd">            The residual error relative to the old spline. (The returned spline&#39;s accuracy is also adjusted accordingly.)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements a variation of the algorithms from Tiller, Wayne. &quot;Knot-removal algorithms for NURBS curves and surfaces.&quot; Computer-Aided Design 24, no. 8 (1992): 445-453.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">remove_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldKnots</span><span class="p">,</span> <span class="n">maxRemovalsPerKnot</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reparametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reparametrize a spline to match new domain bounds. The spline&#39;s number of knots and its coefficients remain unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables. </span>
<span class="sd">            Same form as returned from `domain`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Reparametrized spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">reparametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">)):</span>
            <span class="n">kw</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;knots</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale a spline by the given scalar or scale vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiplier : scalar, array-like, or `Spline`</span>
<span class="sd">            A scalar, an array of length `nDep`, or spline that specifies the multiplier.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The scaled spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        `transform` : Transform a spline by the given matrix.</span>
<span class="sd">        `translate` : Translate a spline by the given translation vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract two splines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to subtract from self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of subtracting other from self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `add` : Add two splines.</span>
<span class="sd">        `multiply` : Multiply two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `common_basis` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">indMap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">maxSingularValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a spline by the given matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : array-like</span>
<span class="sd">            An array of size `newNDep`x`nDep` that specifies the transform matrix.</span>

<span class="sd">        maxSingularValue : `float`, optional</span>
<span class="sd">            The largest singular value of `matrix`, used to update the accuracy of the spline. </span>
<span class="sd">            If no value is provided (default), the largest singular value is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The transformed spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `scale` : Scale a spline by the given scalar or scale vector.</span>
<span class="sd">        `translate` : Translate a spline by the given translation vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">maxSingularValue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translationVector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate a spline by the given translation vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        translationVector : array-like</span>
<span class="sd">            An array of length `nDep` that specifies the translation vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The translated spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `scale` : Scale a spline by the given scalar or scale vector.</span>
<span class="sd">        `transform` : Transform a spline by the given matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translationVector</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim the domain of a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as </span>
<span class="sd">            returned from `domain`). If a bound is None or nan then the original bound (and knots) are left unchanged.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Trimmed spline. If all the knots are unchanged, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        `extrapolate` : Extrapolate a spline out to an extended domain maintaining a given order of continuity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">,</span> <span class="n">coefficientlessSpline</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unfold the coefficients of an original spline&#39;s indicated independent variables back into the spline, using the </span>
<span class="sd">        indicated independent variables&#39; knots and orders from a second spline with no coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        foldedInd : `iterable`</span>
<span class="sd">            An iterable that specifies the independent variables whose coefficients should be unfolded.</span>

<span class="sd">        coefficientlessSpline : `Spline`</span>
<span class="sd">            The coefficientless spline that retains the indicated independent variables&#39; knots and orders.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unfoldedSpline : `Spline`, `Spline`</span>
<span class="sd">            The unfolded spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `fold` : Fold the coefficients of a spline&#39;s indicated independent variables into the coefficients of the remaining independent variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.</span>
<span class="sd">        The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, </span>
<span class="sd">        all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline </span>
<span class="sd">        with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, </span>
<span class="sd">        returning the original spline.</span>

<span class="sd">        Here&#39;s an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. </span>
<span class="sd">        Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have </span>
<span class="sd">        shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn&#39;t matter </span>
<span class="sd">        so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">,</span> <span class="n">coefficientlessSpline</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the roots of a spline (nInd must match nDep).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epsilon : `float`, optional</span>
<span class="sd">            Tolerance for root precision. The root will be within epsilon of the actual root. </span>
<span class="sd">            The default is the max of spline accuracy and machine epsilon.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : `iterable`</span>
<span class="sd">            An ordered iterable containing the roots of the spline. If the spline is </span>
<span class="sd">            zero over an interval, that root will appear as a tuple of the interval.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently, the algorithm only works for nInd == 1. </span>
<span class="sd">        Implements the algorithm from Grandine, Thomas A. &quot;Computing zeroes of spline functions.&quot; Computer Aided Geometric Design 6, no. 2 (1989): 129-136.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_intersection</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
</pre></div>

        </details>

            </section>
                <section id="Spline">
                                <div class="attr class">
        <a class="headerlink" href="#Spline">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Spline</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Spline</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to model, represent, and process piecewise polynomial tensor product</span>
<span class="sd">    functions (spline functions) as linear combinations of B-splines. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nInd : `int`</span>
<span class="sd">        The number of independent variables of the spline</span>

<span class="sd">    nDep : `int`</span>
<span class="sd">        The number of dependent variables of the spline</span>
<span class="sd">    </span>
<span class="sd">    order : `tuple`</span>
<span class="sd">        A tuple of length nInd where each integer entry represents the</span>
<span class="sd">        polynomial order of the function in that variable</span>

<span class="sd">    nCoef : `tuple`</span>
<span class="sd">        A tuple of length nInd where each integer entry represents the</span>
<span class="sd">        dimension (i.e. number of B-spline coefficients) of the function</span>
<span class="sd">        space in that variable</span>

<span class="sd">    knots : `list`</span>
<span class="sd">        A list of the lists of the knots of the spline in each independent variable</span>

<span class="sd">    coefs : array-like</span>
<span class="sd">        A list of the B-spline coefficients of the spline.</span>
<span class="sd">    </span>
<span class="sd">    accuracy : `float`, optional</span>
<span class="sd">        Each spline function is presumed to be an approximation of something else. </span>
<span class="sd">        The `accuracy` stores the infinity norm error of the difference between </span>
<span class="sd">        the given spline function and that something else. Default is zero.</span>

<span class="sd">    metadata : `dict`, optional</span>
<span class="sd">        A dictionary of ancillary data to store with the spline. Default is {}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nInd</span><span class="p">,</span> <span class="n">nDep</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">nCoef</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="k">assert</span> <span class="n">nInd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nInd &lt; 0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nInd</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nDep</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nDep &lt; 0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nDep</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(order) != nInd&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nCoef</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(nCoef) != nInd&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nCoef</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">)</span> <span class="o">==</span> <span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(knots) != nInd&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">)):</span>
            <span class="n">nKnots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">nKnots</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;Knots array for variable </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> should have length </span><span class="si">{</span><span class="n">nKnots</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">knots</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">knots</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">nCoef</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCoef</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">order</span><span class="p">],</span>\
                       <span class="s2">&quot;Improperly ordered knot sequence&quot;</span>
        <span class="n">totalCoefs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">nCoef</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">:</span>
            <span class="n">totalCoefs</span> <span class="o">*=</span> <span class="n">nCoef</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="n">totalCoefs</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Length of coefs should be </span><span class="si">{</span><span class="n">totalCoefs</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="n">totalCoefs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">uvw</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Spline(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span> \
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span> \
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rmatmul__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">nDep</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Spline</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_isIterable</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">spline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">spline</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two splines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to add to self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of adding other to self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `subtract` : Subtract two splines.</span>
<span class="sd">        `multiply` : Multiply two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `common_basis` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">blossom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the blossom of the spline at a given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvwValues : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the degree-sized vectors of blossom parameters for each independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the spline&#39;s blossom at the given blossom parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at a given parameter value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Evaluates the blossom based on blossoming algorithm 1 found in Goldman, Ronald N. &quot;Blossoming and knot insertion algorithms for B-spline curves.&quot; </span>
<span class="sd">        Computer Aided Geometric Design 7, no. 1-4 (1990): 69-81.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">blossom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bsplineValues</span><span class="p">(</span><span class="n">knot</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">splineOrder</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivativeOrder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">taylorCoefs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute bspline values or their derivatives for a 1D bspline segment given the rightmost knot of the segment and a parameter value within that segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        knot : `int`</span>
<span class="sd">            The rightmost knot in the bspline segment.</span>

<span class="sd">        knots : array-like</span>
<span class="sd">            The array of knots for the bspline.</span>
<span class="sd">        </span>
<span class="sd">        splineOrder : `int`</span>
<span class="sd">            The order of the bspline.</span>

<span class="sd">        u : `float`</span>
<span class="sd">            The parameter value within the segment at which to evaluate it.</span>
<span class="sd">        </span>
<span class="sd">        derivativeOrder : `int`, optional</span>
<span class="sd">            The order of the derivative. A zero-order derivative (default) just evaluates the bspline normally.</span>
<span class="sd">        </span>
<span class="sd">        taylorCoefs : `boolean`, optional</span>
<span class="sd">            A boolean flag that if true returns the derivatives divided by their degree factorial, that is </span>
<span class="sd">            the taylor coefficients at the given parameter values. Default is false.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the bspline or its derivative at the given parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at given parameter values.</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method does not check parameter values. It is used by other evaluation methods. It uses the de Boor recurrence relations for a B-spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">bsplineValues</span><span class="p">(</span><span class="n">knot</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">splineOrder</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivativeOrder</span><span class="p">,</span> <span class="n">taylorCoefs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure the leftmost/rightmost knot has a full order multiplicity, clamping the spline&#39;s </span>
<span class="sd">        value at the first/last knot to its first/last coefficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : `iterable`</span>
<span class="sd">            An iterable of independent variables to clamp on the left side.</span>

<span class="sd">        right : `iterable`</span>
<span class="sd">            An iterable of independent variables to clamp on the right side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The clamped spline. If the spline was already clamped, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">common_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">indMap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        splines : `iterable`</span>
<span class="sd">            The collection of N - 1 splines to align (N total splines, including self).</span>

<span class="sd">        indMap : `iterable`</span>
<span class="sd">            The collection of independent variables to align. Since each spline can have multiple </span>
<span class="sd">            independent variables, `indMap` is an `iterable` of `iterables` (like a list of lists). </span>
<span class="sd">            Each collection of indices (i0, i1, .. iN) maps the i&#39;th independent variable to each other. </span>
<span class="sd">            The domains of mapped independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            If all the splines are curves (1 independent variable), then `indMap` is ((0, 0, .. 0),).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        splines : `tuple`</span>
<span class="sd">            The aligned collection of N splines.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `elevate_and_insert_knots` : Elevate a spline and insert new knots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `elevate_and_insert_knots` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">common_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">indMap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cross product a spline with `nDep` of 3 by the given vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like or `Spline`</span>
<span class="sd">            An array of length 3 or spline with `nDep` of 3 that specifies the vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The crossed spline, self x vector.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_respect_to : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the integer order of derivative for each independent variable.</span>
<span class="sd">            A zero-order derivative just evaluates the spline normally.</span>
<span class="sd">        </span>
<span class="sd">        uvw : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the values of each independent variable (the parameter values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the derivative of the spline at the given parameter values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at a given parameter value.</span>
<span class="sd">        `differentiate` : Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The derivative method uses the de Boor recurrence relations for a B-spline</span>
<span class="sd">        series to evaluate a spline function.  The non-zero B-splines are</span>
<span class="sd">        evaluated, then the dot product of those B-splines with the vector of</span>
<span class="sd">        B-spline coefficients is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_respect_to : integer, optional</span>
<span class="sd">            The number of the independent variable to differentiate. Default is zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The spline that results from differentiating the original spline with respect to the given independent variable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at a given parameter value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the domain of a spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bounds : `numpy.array`</span>
<span class="sd">            nInd x 2 array of the upper and lower bounds on each of the independent variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `reparametrize` : Reparametrize a spline to match new domain bounds</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dot product a spline by the given vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like or `Spline`</span>
<span class="sd">            An array of length `nDep` or spline with matching `nDep` that specifies the vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The dotted spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">elevate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elevate a spline, increasing its order by `m`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the non-negative integer amount to increase the order </span>
<span class="sd">            for each independent variable of the spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the order of the current spline plus `m`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `elevate_and_insert_knots` : Elevate a spline and insert new knots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. </span>
<span class="sd">        &quot;Fast degree elevation and knot insertion for B-spline curves.&quot; Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elevate_and_insert_knots</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span> <span class="o">*</span> <span class="p">[[]])</span>

    <span class="k">def</span> <span class="nf">elevate_and_insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elevate a spline and insert new knots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the non-negative integer amount to increase the order </span>
<span class="sd">            for each independent variable of the spline.</span>

<span class="sd">        newKnots : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the knots to be added to each independent variable&#39;s knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if no knots are to be added for the `ind` independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the order of the current spline plus `m` that includes the new knots.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `clamp` : Clamp the left and/or right side of a spline.</span>
<span class="sd">        `elevate` : Elevate a spline, increasing its order by `m`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. </span>
<span class="sd">        &quot;Fast degree elevation and knot insertion for B-spline curves.&quot; Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">elevate_and_insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the value of the spline at given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvw : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the values of each independent variable (the parameter values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the spline at the given parameter values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The evaluate method uses the de Boor recurrence relations for a B-spline</span>
<span class="sd">        series to evaluate a spline function.  The non-zero B-splines are</span>
<span class="sd">        evaluated, then the dot product of those B-splines with the vector of</span>
<span class="sd">        B-spline coefficients is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">,</span> <span class="n">continuityOrder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extrapolate a spline out to an extended domain maintaining a given order of continuity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as </span>
<span class="sd">            returned from `domain`). If a bound is None or nan then the original bound (and knots) are left unchanged.</span>

<span class="sd">        continuityOrder : `int`</span>
<span class="sd">            The order of continuity of the extrapolation (the number of derivatives that match at the endpoints). </span>
<span class="sd">            A continuity order of zero means the extrapolation just matches the spline value at the endpoints. </span>
<span class="sd">            The continuity order is automatically limited to one less than the degree of the spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Extrapolated spline. If all the knots are unchanged, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">,</span> <span class="n">continuityOrder</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fold the coefficients of a spline&#39;s indicated independent variables into the coefficients of the remaining independent variables, retaining the </span>
<span class="sd">        indicated independent variables&#39; knots and orders in a second spline with no coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        foldedInd : `iterable`</span>
<span class="sd">            An iterable that specifies the independent variables whose coefficients should be folded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        foldedSpline, coefficientlessSpline : `Spline`, `Spline`</span>
<span class="sd">            The folded spline and the coefficientless spline that retains the indicated independent variables&#39; knots and orders.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `unfold` : Unfold the coefficients of an original spline&#39;s indicated independent variables back into the spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.</span>
<span class="sd">        The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, </span>
<span class="sd">        all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline </span>
<span class="sd">        with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, </span>
<span class="sd">        returning the original spline.</span>

<span class="sd">        Here&#39;s an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. </span>
<span class="sd">        Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have </span>
<span class="sd">        shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn&#39;t matter </span>
<span class="sd">        so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert new knots into a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newKnots : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the knots to be added to each independent variable&#39;s knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if no knots are to be added for the `ind` independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the new knots inserted. If no knots were inserted, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `clamp` : Clamp the left and/or right side of a spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements Boehm&#39;s standard knot insertion algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">dataPoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a curve to a string of data points using the method of least squares.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataPoints : `iterable` containing the data points to fit.</span>
<span class="sd">            Each of the data points is of length nDep.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline curve which approximates the data points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_fitting</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">dataPoints</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">splineType</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span>
        <span class="n">nInd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nInd</span><span class="p">):</span>
            <span class="n">knots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;knots</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;coefficients&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">splineType</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">splineType</span> <span class="o">=</span> <span class="n">Spline</span>
        <span class="n">spline</span> <span class="o">=</span> <span class="n">splineType</span><span class="p">(</span><span class="n">nInd</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">order</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">Path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">Name</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fileName</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">spline</span>

    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">productType</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply two splines (cross, dot, or scalar product).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to multiply by self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        productType : {&#39;C&#39;, &#39;D&#39;, &#39;S&#39;}, optional</span>
<span class="sd">            The type of product to perform on the dependent variables (default is &#39;S&#39;).</span>
<span class="sd">                &#39;C&#39; is for a cross product, self x other (nDep must be 3).</span>
<span class="sd">                &#39;D&#39; is for a dot product (nDep must match).</span>
<span class="sd">                &#39;S&#39; is for a scalar product (nDep must be 1 for one of the splines).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of multiplying other to self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `add` : Add two splines.</span>
<span class="sd">        `subtract` : Subtract two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Taken in part from Lee, E. T. Y. &quot;Computing a chain of blossoms, with application to products of splines.&quot; </span>
<span class="sd">        Computer Aided Geometric Design 11, no. 6 (1994): 597-620.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span><span class="p">,</span> <span class="n">productType</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">range_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the range of a spline as upper and lower bounds on each of the</span>
<span class="sd">        dependent variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">range_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldKnots</span><span class="o">=</span><span class="p">((),),</span> <span class="n">maxRemovalsPerKnot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove interior knots from a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oldKnots : `iterable` of length `nInd`, optional</span>
<span class="sd">            An iterable that specifies the knots that can be removed from each independent variable&#39;s interior knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if all interior knots can be removed for the `ind` independent variable (the default). </span>
<span class="sd">            Knots that don&#39;t appear in the independent variable&#39;s interior knots are ignored.</span>
<span class="sd">        </span>
<span class="sd">        maxRemovalsPerKnot : `int`, optional</span>
<span class="sd">            A non-zero count of the largest number of times a knot can be removed. For example, one means that </span>
<span class="sd">            only one instance of each knot can be removed. (Zero means each knot can be removed completely, </span>
<span class="sd">            which is the default.)</span>
<span class="sd">        </span>
<span class="sd">        tolerance : `float` or `None`, optional</span>
<span class="sd">            The maximum residual error permitted after removing a knot. Knots will not be removed if the </span>
<span class="sd">            resulting residual error is above this threshold. Default is `None`, meaning all specified knots </span>
<span class="sd">            will be removed up to `maxRemovalsPerKnot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the knots removed.</span>
<span class="sd">        </span>
<span class="sd">        totalRemoved : `int`</span>
<span class="sd">            The total number of knots removed.</span>
<span class="sd">        </span>
<span class="sd">        residualError : `float`</span>
<span class="sd">            The residual error relative to the old spline. (The returned spline&#39;s accuracy is also adjusted accordingly.)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements a variation of the algorithms from Tiller, Wayne. &quot;Knot-removal algorithms for NURBS curves and surfaces.&quot; Computer-Aided Design 24, no. 8 (1992): 445-453.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">remove_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldKnots</span><span class="p">,</span> <span class="n">maxRemovalsPerKnot</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reparametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reparametrize a spline to match new domain bounds. The spline&#39;s number of knots and its coefficients remain unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables. </span>
<span class="sd">            Same form as returned from `domain`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Reparametrized spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">reparametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">)):</span>
            <span class="n">kw</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;knots</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale a spline by the given scalar or scale vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiplier : scalar, array-like, or `Spline`</span>
<span class="sd">            A scalar, an array of length `nDep`, or spline that specifies the multiplier.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The scaled spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        `transform` : Transform a spline by the given matrix.</span>
<span class="sd">        `translate` : Translate a spline by the given translation vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract two splines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to subtract from self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of subtracting other from self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `add` : Add two splines.</span>
<span class="sd">        `multiply` : Multiply two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `common_basis` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">indMap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">maxSingularValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a spline by the given matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : array-like</span>
<span class="sd">            An array of size `newNDep`x`nDep` that specifies the transform matrix.</span>

<span class="sd">        maxSingularValue : `float`, optional</span>
<span class="sd">            The largest singular value of `matrix`, used to update the accuracy of the spline. </span>
<span class="sd">            If no value is provided (default), the largest singular value is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The transformed spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `scale` : Scale a spline by the given scalar or scale vector.</span>
<span class="sd">        `translate` : Translate a spline by the given translation vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">maxSingularValue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translationVector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate a spline by the given translation vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        translationVector : array-like</span>
<span class="sd">            An array of length `nDep` that specifies the translation vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The translated spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `scale` : Scale a spline by the given scalar or scale vector.</span>
<span class="sd">        `transform` : Transform a spline by the given matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translationVector</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim the domain of a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as </span>
<span class="sd">            returned from `domain`). If a bound is None or nan then the original bound (and knots) are left unchanged.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Trimmed spline. If all the knots are unchanged, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        `extrapolate` : Extrapolate a spline out to an extended domain maintaining a given order of continuity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">,</span> <span class="n">coefficientlessSpline</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unfold the coefficients of an original spline&#39;s indicated independent variables back into the spline, using the </span>
<span class="sd">        indicated independent variables&#39; knots and orders from a second spline with no coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        foldedInd : `iterable`</span>
<span class="sd">            An iterable that specifies the independent variables whose coefficients should be unfolded.</span>

<span class="sd">        coefficientlessSpline : `Spline`</span>
<span class="sd">            The coefficientless spline that retains the indicated independent variables&#39; knots and orders.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unfoldedSpline : `Spline`, `Spline`</span>
<span class="sd">            The unfolded spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `fold` : Fold the coefficients of a spline&#39;s indicated independent variables into the coefficients of the remaining independent variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.</span>
<span class="sd">        The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, </span>
<span class="sd">        all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline </span>
<span class="sd">        with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, </span>
<span class="sd">        returning the original spline.</span>

<span class="sd">        Here&#39;s an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. </span>
<span class="sd">        Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have </span>
<span class="sd">        shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn&#39;t matter </span>
<span class="sd">        so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">,</span> <span class="n">coefficientlessSpline</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the roots of a spline (nInd must match nDep).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epsilon : `float`, optional</span>
<span class="sd">            Tolerance for root precision. The root will be within epsilon of the actual root. </span>
<span class="sd">            The default is the max of spline accuracy and machine epsilon.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : `iterable`</span>
<span class="sd">            An ordered iterable containing the roots of the spline. If the spline is </span>
<span class="sd">            zero over an interval, that root will appear as a tuple of the interval.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently, the algorithm only works for nInd == 1. </span>
<span class="sd">        Implements the algorithm from Grandine, Thomas A. &quot;Computing zeroes of spline functions.&quot; Computer Aided Geometric Design 6, no. 2 (1989): 129-136.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_intersection</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A class to model, represent, and process piecewise polynomial tensor product
functions (spline functions) as linear combinations of B-splines. </p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>nInd</strong> (<code>int</code>):
The number of independent variables of the spline</li>
<li><strong>nDep</strong> (<code>int</code>):
The number of dependent variables of the spline</li>
<li><strong>order</strong> (<code>tuple</code>):
A tuple of length nInd where each integer entry represents the
polynomial order of the function in that variable</li>
<li><strong>nCoef</strong> (<code>tuple</code>):
A tuple of length nInd where each integer entry represents the
dimension (i.e. number of B-spline coefficients) of the function
space in that variable</li>
<li><strong>knots</strong> (<code>list</code>):
A list of the lists of the knots of the spline in each independent variable</li>
<li><strong>coefs</strong> (array-like):
A list of the B-spline coefficients of the spline.</li>
<li><strong>accuracy</strong> (<code>float</code>, optional):
Each spline function is presumed to be an approximation of something else. 
The <code>accuracy</code> stores the infinity norm error of the difference between 
the given spline function and that something else. Default is zero.</li>
<li><strong>metadata</strong> (<code>dict</code>, optional):
A dictionary of ancillary data to store with the spline. Default is {}.</li>
</ul>
</div>


                            <div id="Spline.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Spline</span><span class="signature">(nInd, nDep, order, nCoef, knots, coefs, accuracy=0.0, metadata={})</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nInd</span><span class="p">,</span> <span class="n">nDep</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">nCoef</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="k">assert</span> <span class="n">nInd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nInd &lt; 0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nInd</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nDep</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nDep &lt; 0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nDep</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(order) != nInd&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nCoef</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(nCoef) != nInd&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nCoef</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">)</span> <span class="o">==</span> <span class="n">nInd</span><span class="p">,</span> <span class="s2">&quot;len(knots) != nInd&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">)):</span>
            <span class="n">nKnots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">nKnots</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;Knots array for variable </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> should have length </span><span class="si">{</span><span class="n">nKnots</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">knots</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">knots</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">nCoef</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nCoef</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">knots</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">order</span><span class="p">],</span>\
                       <span class="s2">&quot;Improperly ordered knot sequence&quot;</span>
        <span class="n">totalCoefs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">nCoef</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">:</span>
            <span class="n">totalCoefs</span> <span class="o">*=</span> <span class="n">nCoef</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="n">totalCoefs</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Length of coefs should be </span><span class="si">{</span><span class="n">totalCoefs</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">)</span> <span class="o">==</span> <span class="n">totalCoefs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nDep</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nCoef</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Spline.add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add</span><span class="signature">(self, other, indMap=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two splines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to add to self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of adding other to self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `subtract` : Subtract two splines.</span>
<span class="sd">        `multiply` : Multiply two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `common_basis` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Add two splines.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (<code><a href="#Spline">Spline</a></code>):
The spline to add to self. The number of dependent variables must match self.</li>
<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):
An iterable of pairs of indices. 
Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. 
The domains of the nth and mth independent variables must match. 
An independent variable can map to no more than one other independent variable.
Unmapped independent variables remain independent (the default).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The result of adding other to self.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.subtract">subtract</a></code>:  Subtract two splines. <br />
<code><a href="#Spline.multiply">multiply</a></code>:  Multiply two splines. <br />
`<code><a href="#Spline.common_basis">common_basis</a></code>:  Align a collection of splines to a common basis, elevating the order and adding knots as needed.  </p>

<h6 id="notes">Notes</h6>

<p>Uses <code><a href="#Spline.common_basis">common_basis</a></code> to ensure mapped variables share the same order and knots.</p>
</div>


                            </div>
                            <div id="Spline.blossom" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.blossom">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">blossom</span><span class="signature">(self, uvw)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">blossom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the blossom of the spline at a given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvwValues : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the degree-sized vectors of blossom parameters for each independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the spline&#39;s blossom at the given blossom parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at a given parameter value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Evaluates the blossom based on blossoming algorithm 1 found in Goldman, Ronald N. &quot;Blossoming and knot insertion algorithms for B-spline curves.&quot; </span>
<span class="sd">        Computer Aided Geometric Design 7, no. 1-4 (1990): 69-81.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">blossom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the blossom of the spline at a given parameter values.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>uvwValues</strong> (<code>iterable</code>):
An iterable of length <code>nInd</code> that specifies the degree-sized vectors of blossom parameters for each independent variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>value</strong> (<code>numpy.array</code>):
The value of the spline's blossom at the given blossom parameters.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.evaluate">evaluate</a></code>:  Compute the value of the spline at a given parameter value.  </p>

<h6 id="notes">Notes</h6>

<p>Evaluates the blossom based on blossoming algorithm 1 found in Goldman, Ronald N. "Blossoming and knot insertion algorithms for B-spline curves." 
Computer Aided Geometric Design 7, no. 1-4 (1990): 69-81.</p>
</div>


                            </div>
                            <div id="Spline.bsplineValues" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.bsplineValues">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">bsplineValues</span><span class="signature">(knot, knots, splineOrder, u, derivativeOrder=0, taylorCoefs=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bsplineValues</span><span class="p">(</span><span class="n">knot</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">splineOrder</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivativeOrder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">taylorCoefs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute bspline values or their derivatives for a 1D bspline segment given the rightmost knot of the segment and a parameter value within that segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        knot : `int`</span>
<span class="sd">            The rightmost knot in the bspline segment.</span>

<span class="sd">        knots : array-like</span>
<span class="sd">            The array of knots for the bspline.</span>
<span class="sd">        </span>
<span class="sd">        splineOrder : `int`</span>
<span class="sd">            The order of the bspline.</span>

<span class="sd">        u : `float`</span>
<span class="sd">            The parameter value within the segment at which to evaluate it.</span>
<span class="sd">        </span>
<span class="sd">        derivativeOrder : `int`, optional</span>
<span class="sd">            The order of the derivative. A zero-order derivative (default) just evaluates the bspline normally.</span>
<span class="sd">        </span>
<span class="sd">        taylorCoefs : `boolean`, optional</span>
<span class="sd">            A boolean flag that if true returns the derivatives divided by their degree factorial, that is </span>
<span class="sd">            the taylor coefficients at the given parameter values. Default is false.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the bspline or its derivative at the given parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at given parameter values.</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method does not check parameter values. It is used by other evaluation methods. It uses the de Boor recurrence relations for a B-spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">bsplineValues</span><span class="p">(</span><span class="n">knot</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">splineOrder</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivativeOrder</span><span class="p">,</span> <span class="n">taylorCoefs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute bspline values or their derivatives for a 1D bspline segment given the rightmost knot of the segment and a parameter value within that segment.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>knot</strong> (<code>int</code>):
The rightmost knot in the bspline segment.</li>
<li><strong>knots</strong> (array-like):
The array of knots for the bspline.</li>
<li><strong>splineOrder</strong> (<code>int</code>):
The order of the bspline.</li>
<li><strong>u</strong> (<code>float</code>):
The parameter value within the segment at which to evaluate it.</li>
<li><strong>derivativeOrder</strong> (<code>int</code>, optional):
The order of the derivative. A zero-order derivative (default) just evaluates the bspline normally.</li>
<li><strong>taylorCoefs</strong> (<code>boolean</code>, optional):
A boolean flag that if true returns the derivatives divided by their degree factorial, that is 
the taylor coefficients at the given parameter values. Default is false.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>value</strong> (<code>numpy.array</code>):
The value of the bspline or its derivative at the given parameter.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.evaluate">evaluate</a></code>:  Compute the value of the spline at given parameter values. <br />
<code><a href="#Spline.derivative">derivative</a></code>:  Compute the derivative of the spline at given parameter values.  </p>

<h6 id="notes">Notes</h6>

<p>This method does not check parameter values. It is used by other evaluation methods. It uses the de Boor recurrence relations for a B-spline.</p>
</div>


                            </div>
                            <div id="Spline.clamp" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.clamp">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">clamp</span><span class="signature">(self, left, right)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure the leftmost/rightmost knot has a full order multiplicity, clamping the spline&#39;s </span>
<span class="sd">        value at the first/last knot to its first/last coefficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : `iterable`</span>
<span class="sd">            An iterable of independent variables to clamp on the left side.</span>

<span class="sd">        right : `iterable`</span>
<span class="sd">            An iterable of independent variables to clamp on the right side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The clamped spline. If the spline was already clamped, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Ensure the leftmost/rightmost knot has a full order multiplicity, clamping the spline's 
value at the first/last knot to its first/last coefficient.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>left</strong> (<code>iterable</code>):
An iterable of independent variables to clamp on the left side.</li>
<li><strong>right</strong> (<code>iterable</code>):
An iterable of independent variables to clamp on the right side.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The clamped spline. If the spline was already clamped, the original spline is returned.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.insert_knots">insert_knots</a></code>:  Insert new knots into a spline. <br />
<code><a href="#Spline.trim">trim</a></code>:  Trim the domain of a spline.  </p>
</div>


                            </div>
                            <div id="Spline.common_basis" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.common_basis">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">common_basis</span><span class="signature">(self, splines, indMap)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">common_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">indMap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        splines : `iterable`</span>
<span class="sd">            The collection of N - 1 splines to align (N total splines, including self).</span>

<span class="sd">        indMap : `iterable`</span>
<span class="sd">            The collection of independent variables to align. Since each spline can have multiple </span>
<span class="sd">            independent variables, `indMap` is an `iterable` of `iterables` (like a list of lists). </span>
<span class="sd">            Each collection of indices (i0, i1, .. iN) maps the i&#39;th independent variable to each other. </span>
<span class="sd">            The domains of mapped independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            If all the splines are curves (1 independent variable), then `indMap` is ((0, 0, .. 0),).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        splines : `tuple`</span>
<span class="sd">            The aligned collection of N splines.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `elevate_and_insert_knots` : Elevate a spline and insert new knots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `elevate_and_insert_knots` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">common_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">indMap</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Align a collection of splines to a common basis, elevating the order and adding knots as needed.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>splines</strong> (<code>iterable</code>):
The collection of N - 1 splines to align (N total splines, including self).</li>
<li><strong>indMap</strong> (<code>iterable</code>):
The collection of independent variables to align. Since each spline can have multiple 
independent variables, <code>indMap</code> is an <code>iterable</code> of <code>iterables</code> (like a list of lists). 
Each collection of indices (i0, i1, .. iN) maps the i'th independent variable to each other. 
The domains of mapped independent variables must match. 
An independent variable can map to no more than one other independent variable.
If all the splines are curves (1 independent variable), then <code>indMap</code> is ((0, 0, .. 0),).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>splines</strong> (<code>tuple</code>):
The aligned collection of N splines.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.elevate_and_insert_knots">elevate_and_insert_knots</a></code>:  Elevate a spline and insert new knots.  </p>

<h6 id="notes">Notes</h6>

<p>Uses <code><a href="#Spline.elevate_and_insert_knots">elevate_and_insert_knots</a></code> to ensure mapped variables share the same order and knots.</p>
</div>


                            </div>
                            <div id="Spline.cross" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.cross">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">cross</span><span class="signature">(self, vector)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cross product a spline with `nDep` of 3 by the given vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like or `Spline`</span>
<span class="sd">            An array of length 3 or spline with `nDep` of 3 that specifies the vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The crossed spline, self x vector.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Cross product a spline with <code>nDep</code> of 3 by the given vector.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vector</strong> (array-like or <code><a href="#Spline">Spline</a></code>):
An array of length 3 or spline with <code>nDep</code> of 3 that specifies the vector.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The crossed spline, self x vector.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.multiply">multiply</a></code>:  Multiply two splines (cross, dot, or scalar product).  </p>
</div>


                            </div>
                            <div id="Spline.derivative" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.derivative">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">derivative</span><span class="signature">(self, with_respect_to, uvw)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_respect_to : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the integer order of derivative for each independent variable.</span>
<span class="sd">            A zero-order derivative just evaluates the spline normally.</span>
<span class="sd">        </span>
<span class="sd">        uvw : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the values of each independent variable (the parameter values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the derivative of the spline at the given parameter values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `evaluate` : Compute the value of the spline at a given parameter value.</span>
<span class="sd">        `differentiate` : Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The derivative method uses the de Boor recurrence relations for a B-spline</span>
<span class="sd">        series to evaluate a spline function.  The non-zero B-splines are</span>
<span class="sd">        evaluated, then the dot product of those B-splines with the vector of</span>
<span class="sd">        B-spline coefficients is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the derivative of the spline at given parameter values.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>with_respect_to</strong> (<code>iterable</code>):
An iterable of length <code>nInd</code> that specifies the integer order of derivative for each independent variable.
A zero-order derivative just evaluates the spline normally.</li>
<li><strong>uvw</strong> (<code>iterable</code>):
An iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>value</strong> (<code>numpy.array</code>):
The value of the derivative of the spline at the given parameter values.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.evaluate">evaluate</a></code>:  Compute the value of the spline at a given parameter value. <br />
<code><a href="#Spline.differentiate">differentiate</a></code>:  Differentiate a spline with respect to one of its independent variables, returning the resulting spline.  </p>

<h6 id="notes">Notes</h6>

<p>The derivative method uses the de Boor recurrence relations for a B-spline
series to evaluate a spline function.  The non-zero B-splines are
evaluated, then the dot product of those B-splines with the vector of
B-spline coefficients is computed.</p>
</div>


                            </div>
                            <div id="Spline.differentiate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.differentiate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">differentiate</span><span class="signature">(self, with_respect_to=0)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        with_respect_to : integer, optional</span>
<span class="sd">            The number of the independent variable to differentiate. Default is zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The spline that results from differentiating the original spline with respect to the given independent variable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at a given parameter value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_respect_to</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Differentiate a spline with respect to one of its independent variables, returning the resulting spline.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>with_respect_to</strong> (integer, optional):
The number of the independent variable to differentiate. Default is zero.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The spline that results from differentiating the original spline with respect to the given independent variable.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.derivative">derivative</a></code>:  Compute the derivative of the spline at a given parameter value.  </p>
</div>


                            </div>
                            <div id="Spline.domain" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.domain">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">domain</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the domain of a spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bounds : `numpy.array`</span>
<span class="sd">            nInd x 2 array of the upper and lower bounds on each of the independent variables.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `reparametrize` : Reparametrize a spline to match new domain bounds</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the domain of a spline.</p>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>bounds</strong> (<code>numpy.array</code>):
nInd x 2 array of the upper and lower bounds on each of the independent variables.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.reparametrize">reparametrize</a></code>:  Reparametrize a spline to match new domain bounds <br />
<code><a href="#Spline.trim">trim</a></code>:  Trim the domain of a spline.  </p>
</div>


                            </div>
                            <div id="Spline.dot" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.dot">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">dot</span><span class="signature">(self, vector)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dot product a spline by the given vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : array-like or `Spline`</span>
<span class="sd">            An array of length `nDep` or spline with matching `nDep` that specifies the vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The dotted spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Dot product a spline by the given vector.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vector</strong> (array-like or <code><a href="#Spline">Spline</a></code>):
An array of length <code>nDep</code> or spline with matching <code>nDep</code> that specifies the vector.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The dotted spline.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.multiply">multiply</a></code>:  Multiply two splines (cross, dot, or scalar product).  </p>
</div>


                            </div>
                            <div id="Spline.elevate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.elevate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">elevate</span><span class="signature">(self, m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">elevate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elevate a spline, increasing its order by `m`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the non-negative integer amount to increase the order </span>
<span class="sd">            for each independent variable of the spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the order of the current spline plus `m`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `elevate_and_insert_knots` : Elevate a spline and insert new knots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. </span>
<span class="sd">        &quot;Fast degree elevation and knot insertion for B-spline curves.&quot; Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elevate_and_insert_knots</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nInd</span> <span class="o">*</span> <span class="p">[[]])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Elevate a spline, increasing its order by <code>m</code>.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>m</strong> (<code>iterable</code> of length <code>nInd</code>):
An iterable that specifies the non-negative integer amount to increase the order 
for each independent variable of the spline.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
A spline with the order of the current spline plus <code>m</code>.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.insert_knots">insert_knots</a></code>:  Insert new knots into a spline. <br />
<code><a href="#Spline.elevate_and_insert_knots">elevate_and_insert_knots</a></code>:  Elevate a spline and insert new knots.  </p>

<h6 id="notes">Notes</h6>

<p>Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. 
"Fast degree elevation and knot insertion for B-spline curves." Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</p>
</div>


                            </div>
                            <div id="Spline.elevate_and_insert_knots" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.elevate_and_insert_knots">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">elevate_and_insert_knots</span><span class="signature">(self, m, newKnots)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">elevate_and_insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elevate a spline and insert new knots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the non-negative integer amount to increase the order </span>
<span class="sd">            for each independent variable of the spline.</span>

<span class="sd">        newKnots : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the knots to be added to each independent variable&#39;s knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if no knots are to be added for the `ind` independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the order of the current spline plus `m` that includes the new knots.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `clamp` : Clamp the left and/or right side of a spline.</span>
<span class="sd">        `elevate` : Elevate a spline, increasing its order by `m`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. </span>
<span class="sd">        &quot;Fast degree elevation and knot insertion for B-spline curves.&quot; Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">elevate_and_insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Elevate a spline and insert new knots.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>m</strong> (<code>iterable</code> of length <code>nInd</code>):
An iterable that specifies the non-negative integer amount to increase the order 
for each independent variable of the spline.</li>
<li><strong>newKnots</strong> (<code>iterable</code> of length <code>nInd</code>):
An iterable that specifies the knots to be added to each independent variable's knots. 
len(newKnots[ind]) == 0 if no knots are to be added for the <code>ind</code> independent variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
A spline with the order of the current spline plus <code>m</code> that includes the new knots.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.insert_knots">insert_knots</a></code>:  Insert new knots into a spline. <br />
<code><a href="#Spline.clamp">clamp</a></code>:  Clamp the left and/or right side of a spline. <br />
<code><a href="#Spline.elevate">elevate</a></code>:  Elevate a spline, increasing its order by <code>m</code>.  </p>

<h6 id="notes">Notes</h6>

<p>Implements the algorithm from Huang, Qi-Xing, Shi-Min Hu, and Ralph R. Martin. 
"Fast degree elevation and knot insertion for B-spline curves." Computer Aided Geometric Design 22, no. 2 (2005): 183-197.</p>
</div>


                            </div>
                            <div id="Spline.evaluate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.evaluate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">evaluate</span><span class="signature">(self, uvw)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the value of the spline at given parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uvw : `iterable`</span>
<span class="sd">            An iterable of length `nInd` that specifies the values of each independent variable (the parameter values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `numpy.array`</span>
<span class="sd">            The value of the spline at the given parameter values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `derivative` : Compute the derivative of the spline at given parameter values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The evaluate method uses the de Boor recurrence relations for a B-spline</span>
<span class="sd">        series to evaluate a spline function.  The non-zero B-splines are</span>
<span class="sd">        evaluated, then the dot product of those B-splines with the vector of</span>
<span class="sd">        B-spline coefficients is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the value of the spline at given parameter values.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>uvw</strong> (<code>iterable</code>):
An iterable of length <code>nInd</code> that specifies the values of each independent variable (the parameter values).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>value</strong> (<code>numpy.array</code>):
The value of the spline at the given parameter values.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.derivative">derivative</a></code>:  Compute the derivative of the spline at given parameter values.  </p>

<h6 id="notes">Notes</h6>

<p>The evaluate method uses the de Boor recurrence relations for a B-spline
series to evaluate a spline function.  The non-zero B-splines are
evaluated, then the dot product of those B-splines with the vector of
B-spline coefficients is computed.</p>
</div>


                            </div>
                            <div id="Spline.extrapolate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.extrapolate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">extrapolate</span><span class="signature">(self, newDomain, continuityOrder)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">,</span> <span class="n">continuityOrder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extrapolate a spline out to an extended domain maintaining a given order of continuity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as </span>
<span class="sd">            returned from `domain`). If a bound is None or nan then the original bound (and knots) are left unchanged.</span>

<span class="sd">        continuityOrder : `int`</span>
<span class="sd">            The order of continuity of the extrapolation (the number of derivatives that match at the endpoints). </span>
<span class="sd">            A continuity order of zero means the extrapolation just matches the spline value at the endpoints. </span>
<span class="sd">            The continuity order is automatically limited to one less than the degree of the spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Extrapolated spline. If all the knots are unchanged, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">,</span> <span class="n">continuityOrder</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Extrapolate a spline out to an extended domain maintaining a given order of continuity.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>newDomain</strong> (array-like):
nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as 
returned from <code><a href="#Spline.domain">domain</a></code>). If a bound is None or nan then the original bound (and knots) are left unchanged.</li>
<li><strong>continuityOrder</strong> (<code>int</code>):
The order of continuity of the extrapolation (the number of derivatives that match at the endpoints). 
A continuity order of zero means the extrapolation just matches the spline value at the endpoints. 
The continuity order is automatically limited to one less than the degree of the spline.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
Extrapolated spline. If all the knots are unchanged, the original spline is returned.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.domain">domain</a></code>:  Return the domain of a spline. <br />
<code><a href="#Spline.trim">trim</a></code>:  Trim the domain of a spline.  </p>
</div>


                            </div>
                            <div id="Spline.fold" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.fold">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fold</span><span class="signature">(self, foldedInd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fold the coefficients of a spline&#39;s indicated independent variables into the coefficients of the remaining independent variables, retaining the </span>
<span class="sd">        indicated independent variables&#39; knots and orders in a second spline with no coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        foldedInd : `iterable`</span>
<span class="sd">            An iterable that specifies the independent variables whose coefficients should be folded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        foldedSpline, coefficientlessSpline : `Spline`, `Spline`</span>
<span class="sd">            The folded spline and the coefficientless spline that retains the indicated independent variables&#39; knots and orders.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `unfold` : Unfold the coefficients of an original spline&#39;s indicated independent variables back into the spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.</span>
<span class="sd">        The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, </span>
<span class="sd">        all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline </span>
<span class="sd">        with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, </span>
<span class="sd">        returning the original spline.</span>

<span class="sd">        Here&#39;s an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. </span>
<span class="sd">        Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have </span>
<span class="sd">        shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn&#39;t matter </span>
<span class="sd">        so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fold the coefficients of a spline's indicated independent variables into the coefficients of the remaining independent variables, retaining the 
indicated independent variables' knots and orders in a second spline with no coefficients.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>foldedInd</strong> (<code>iterable</code>):
An iterable that specifies the independent variables whose coefficients should be folded.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>foldedSpline, coefficientlessSpline</strong> (<code><a href="#Spline">Spline</a></code>, <code><a href="#Spline">Spline</a></code>):
The folded spline and the coefficientless spline that retains the indicated independent variables' knots and orders.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.unfold">unfold</a></code>:  Unfold the coefficients of an original spline's indicated independent variables back into the spline.  </p>

<h6 id="notes">Notes</h6>

<p>Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.
The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, 
all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline 
with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, 
returning the original spline.</p>

<p>Here's an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. 
Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have 
shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn't matter 
so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</p>
</div>


                            </div>
                            <div id="Spline.insert_knots" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.insert_knots">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">insert_knots</span><span class="signature">(self, newKnots)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert new knots into a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newKnots : `iterable` of length `nInd`</span>
<span class="sd">            An iterable that specifies the knots to be added to each independent variable&#39;s knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if no knots are to be added for the `ind` independent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the new knots inserted. If no knots were inserted, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `clamp` : Clamp the left and/or right side of a spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements Boehm&#39;s standard knot insertion algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">insert_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newKnots</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Insert new knots into a spline.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>newKnots</strong> (<code>iterable</code> of length <code>nInd</code>):
An iterable that specifies the knots to be added to each independent variable's knots. 
len(newKnots[ind]) == 0 if no knots are to be added for the <code>ind</code> independent variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
A spline with the new knots inserted. If no knots were inserted, the original spline is returned.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.clamp">clamp</a></code>:  Clamp the left and/or right side of a spline.  </p>

<h6 id="notes">Notes</h6>

<p>Implements Boehm's standard knot insertion algorithm.</p>
</div>


                            </div>
                            <div id="Spline.least_squares" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.least_squares">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">least_squares</span><span class="signature">(dataPoints)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">dataPoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a curve to a string of data points using the method of least squares.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataPoints : `iterable` containing the data points to fit.</span>
<span class="sd">            Each of the data points is of length nDep.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline curve which approximates the data points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_fitting</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">dataPoints</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fit a curve to a string of data points using the method of least squares.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>dataPoints</strong> (<code>iterable</code> containing the data points to fit.):
Each of the data points is of length nDep.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
A spline curve which approximates the data points.</li>
</ul>
</div>


                            </div>
                            <div id="Spline.load" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.load">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">load</span><span class="signature">(fileName, splineType=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">splineType</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span>
        <span class="n">nInd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nInd</span><span class="p">):</span>
            <span class="n">knots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;knots</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;coefficients&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">splineType</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">splineType</span> <span class="o">=</span> <span class="n">Spline</span>
        <span class="n">spline</span> <span class="o">=</span> <span class="n">splineType</span><span class="p">(</span><span class="n">nInd</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">order</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">Path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">Name</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fileName</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">spline</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Spline.multiply" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.multiply">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">multiply</span><span class="signature">(self, other, indMap=None, productType=&#39;S&#39;)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">productType</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply two splines (cross, dot, or scalar product).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to multiply by self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        productType : {&#39;C&#39;, &#39;D&#39;, &#39;S&#39;}, optional</span>
<span class="sd">            The type of product to perform on the dependent variables (default is &#39;S&#39;).</span>
<span class="sd">                &#39;C&#39; is for a cross product, self x other (nDep must be 3).</span>
<span class="sd">                &#39;D&#39; is for a dot product (nDep must match).</span>
<span class="sd">                &#39;S&#39; is for a scalar product (nDep must be 1 for one of the splines).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of multiplying other to self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `add` : Add two splines.</span>
<span class="sd">        `subtract` : Subtract two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Taken in part from Lee, E. T. Y. &quot;Computing a chain of blossoms, with application to products of splines.&quot; </span>
<span class="sd">        Computer Aided Geometric Design 11, no. 6 (1994): 597-620.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span><span class="p">,</span> <span class="n">productType</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Multiply two splines (cross, dot, or scalar product).</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (<code><a href="#Spline">Spline</a></code>):
The spline to multiply by self. The number of dependent variables must match self.</li>
<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):
An iterable of pairs of indices. 
Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. 
The domains of the nth and mth independent variables must match. 
An independent variable can map to no more than one other independent variable.
Unmapped independent variables remain independent (the default).</li>
<li><strong>productType</strong> ({'C', 'D', 'S'}, optional):
The type of product to perform on the dependent variables (default is 'S').
   'C' is for a cross product, self x other (nDep must be 3).
   'D' is for a dot product (nDep must match).
   'S' is for a scalar product (nDep must be 1 for one of the splines).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The result of multiplying other to self.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.add">add</a></code>:  Add two splines. <br />
<code><a href="#Spline.subtract">subtract</a></code>:  Subtract two splines. <br />
`<code><a href="#Spline.common_basis">common_basis</a></code>:  Align a collection of splines to a common basis, elevating the order and adding knots as needed.  </p>

<h6 id="notes">Notes</h6>

<p>Taken in part from Lee, E. T. Y. "Computing a chain of blossoms, with application to products of splines." 
Computer Aided Geometric Design 11, no. 6 (1994): 597-620.</p>
</div>


                            </div>
                            <div id="Spline.range_bounds" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.range_bounds">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">range_bounds</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">range_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the range of a spline as upper and lower bounds on each of the</span>
<span class="sd">        dependent variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_evaluation</span><span class="o">.</span><span class="n">range_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the range of a spline as upper and lower bounds on each of the
dependent variables</p>
</div>


                            </div>
                            <div id="Spline.remove_knots" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.remove_knots">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_knots</span><span class="signature">(self, oldKnots=((),), maxRemovalsPerKnot=0, tolerance=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldKnots</span><span class="o">=</span><span class="p">((),),</span> <span class="n">maxRemovalsPerKnot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove interior knots from a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oldKnots : `iterable` of length `nInd`, optional</span>
<span class="sd">            An iterable that specifies the knots that can be removed from each independent variable&#39;s interior knots. </span>
<span class="sd">            len(newKnots[ind]) == 0 if all interior knots can be removed for the `ind` independent variable (the default). </span>
<span class="sd">            Knots that don&#39;t appear in the independent variable&#39;s interior knots are ignored.</span>
<span class="sd">        </span>
<span class="sd">        maxRemovalsPerKnot : `int`, optional</span>
<span class="sd">            A non-zero count of the largest number of times a knot can be removed. For example, one means that </span>
<span class="sd">            only one instance of each knot can be removed. (Zero means each knot can be removed completely, </span>
<span class="sd">            which is the default.)</span>
<span class="sd">        </span>
<span class="sd">        tolerance : `float` or `None`, optional</span>
<span class="sd">            The maximum residual error permitted after removing a knot. Knots will not be removed if the </span>
<span class="sd">            resulting residual error is above this threshold. Default is `None`, meaning all specified knots </span>
<span class="sd">            will be removed up to `maxRemovalsPerKnot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            A spline with the knots removed.</span>
<span class="sd">        </span>
<span class="sd">        totalRemoved : `int`</span>
<span class="sd">            The total number of knots removed.</span>
<span class="sd">        </span>
<span class="sd">        residualError : `float`</span>
<span class="sd">            The residual error relative to the old spline. (The returned spline&#39;s accuracy is also adjusted accordingly.)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `insert_knots` : Insert new knots into a spline.</span>
<span class="sd">        `trim` : Trim the domain of a spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements a variation of the algorithms from Tiller, Wayne. &quot;Knot-removal algorithms for NURBS curves and surfaces.&quot; Computer-Aided Design 24, no. 8 (1992): 445-453.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">remove_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldKnots</span><span class="p">,</span> <span class="n">maxRemovalsPerKnot</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove interior knots from a spline.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>oldKnots</strong> (<code>iterable</code> of length <code>nInd</code>, optional):
An iterable that specifies the knots that can be removed from each independent variable's interior knots. 
len(newKnots[ind]) == 0 if all interior knots can be removed for the <code>ind</code> independent variable (the default). 
Knots that don't appear in the independent variable's interior knots are ignored.</li>
<li><strong>maxRemovalsPerKnot</strong> (<code>int</code>, optional):
A non-zero count of the largest number of times a knot can be removed. For example, one means that 
only one instance of each knot can be removed. (Zero means each knot can be removed completely, 
which is the default.)</li>
<li><strong>tolerance</strong> (<code>float</code> or <code>None</code>, optional):
The maximum residual error permitted after removing a knot. Knots will not be removed if the 
resulting residual error is above this threshold. Default is <code>None</code>, meaning all specified knots 
will be removed up to <code>maxRemovalsPerKnot</code>.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
A spline with the knots removed.</li>
<li><strong>totalRemoved</strong> (<code>int</code>):
The total number of knots removed.</li>
<li><strong>residualError</strong> (<code>float</code>):
The residual error relative to the old spline. (The returned spline's accuracy is also adjusted accordingly.)</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.insert_knots">insert_knots</a></code>:  Insert new knots into a spline. <br />
<code><a href="#Spline.trim">trim</a></code>:  Trim the domain of a spline.  </p>

<h6 id="notes">Notes</h6>

<p>Implements a variation of the algorithms from Tiller, Wayne. "Knot-removal algorithms for NURBS curves and surfaces." Computer-Aided Design 24, no. 8 (1992): 445-453.</p>
</div>


                            </div>
                            <div id="Spline.reparametrize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.reparametrize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">reparametrize</span><span class="signature">(self, newDomain)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">reparametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reparametrize a spline to match new domain bounds. The spline&#39;s number of knots and its coefficients remain unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables. </span>
<span class="sd">            Same form as returned from `domain`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Reparametrized spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">reparametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reparametrize a spline to match new domain bounds. The spline's number of knots and its coefficients remain unchanged.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>newDomain</strong> (array-like):
nInd x 2 array of the new upper and lower bounds on each of the independent variables. 
Same form as returned from <code><a href="#Spline.domain">domain</a></code>.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
Reparametrized spline.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.domain">domain</a></code>:  Return the domain of a spline.  </p>
</div>


                            </div>
                            <div id="Spline.save" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.save">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">save</span><span class="signature">(self, fileName)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">)):</span>
            <span class="n">kw</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;knots</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span> <span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Spline.scale" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.scale">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">scale</span><span class="signature">(self, multiplier)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale a spline by the given scalar or scale vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiplier : scalar, array-like, or `Spline`</span>
<span class="sd">            A scalar, an array of length `nDep`, or spline that specifies the multiplier.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The scaled spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `multiply` : Multiply two splines (cross, dot, or scalar product).</span>
<span class="sd">        `transform` : Transform a spline by the given matrix.</span>
<span class="sd">        `translate` : Translate a spline by the given translation vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Scale a spline by the given scalar or scale vector.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>multiplier</strong> (scalar, array-like, or <code><a href="#Spline">Spline</a></code>):
A scalar, an array of length <code>nDep</code>, or spline that specifies the multiplier.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The scaled spline.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.multiply">multiply</a></code>:  Multiply two splines (cross, dot, or scalar product). <br />
<code><a href="#Spline.transform">transform</a></code>:  Transform a spline by the given matrix. <br />
<code><a href="#Spline.translate">translate</a></code>:  Translate a spline by the given translation vector.  </p>
</div>


                            </div>
                            <div id="Spline.subtract" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.subtract">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">subtract</span><span class="signature">(self, other, indMap=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">indMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract two splines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Spline`</span>
<span class="sd">            The spline to subtract from self. The number of dependent variables must match self.</span>

<span class="sd">        indMap : `iterable` or `None`, optional</span>
<span class="sd">            An iterable of pairs of indices. </span>
<span class="sd">            Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. </span>
<span class="sd">            The domains of the nth and mth independent variables must match. </span>
<span class="sd">            An independent variable can map to no more than one other independent variable.</span>
<span class="sd">            Unmapped independent variables remain independent (the default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The result of subtracting other from self.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `add` : Add two splines.</span>
<span class="sd">        `multiply` : Multiply two splines.</span>
<span class="sd">        `common_basis : Align a collection of splines to a common basis, elevating the order and adding knots as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses `common_basis` to ensure mapped variables share the same order and knots. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">indMap</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Subtract two splines.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (<code><a href="#Spline">Spline</a></code>):
The spline to subtract from self. The number of dependent variables must match self.</li>
<li><strong>indMap</strong> (<code>iterable</code> or <code>None</code>, optional):
An iterable of pairs of indices. 
Each pair (n, m) maps the mth independent variable of other to the nth independent variable of self. 
The domains of the nth and mth independent variables must match. 
An independent variable can map to no more than one other independent variable.
Unmapped independent variables remain independent (the default).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The result of subtracting other from self.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.add">add</a></code>:  Add two splines. <br />
<code><a href="#Spline.multiply">multiply</a></code>:  Multiply two splines. <br />
`<code><a href="#Spline.common_basis">common_basis</a></code>:  Align a collection of splines to a common basis, elevating the order and adding knots as needed.  </p>

<h6 id="notes">Notes</h6>

<p>Uses <code><a href="#Spline.common_basis">common_basis</a></code> to ensure mapped variables share the same order and knots.</p>
</div>


                            </div>
                            <div id="Spline.transform" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.transform">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">transform</span><span class="signature">(self, matrix, maxSingularValue=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">maxSingularValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a spline by the given matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : array-like</span>
<span class="sd">            An array of size `newNDep`x`nDep` that specifies the transform matrix.</span>

<span class="sd">        maxSingularValue : `float`, optional</span>
<span class="sd">            The largest singular value of `matrix`, used to update the accuracy of the spline. </span>
<span class="sd">            If no value is provided (default), the largest singular value is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The transformed spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `scale` : Scale a spline by the given scalar or scale vector.</span>
<span class="sd">        `translate` : Translate a spline by the given translation vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">maxSingularValue</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Transform a spline by the given matrix.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>matrix</strong> (array-like):
An array of size <code>newNDep</code>x<code>nDep</code> that specifies the transform matrix.</li>
<li><strong>maxSingularValue</strong> (<code>float</code>, optional):
The largest singular value of <code>matrix</code>, used to update the accuracy of the spline. 
If no value is provided (default), the largest singular value is computed.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The transformed spline.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.scale">scale</a></code>:  Scale a spline by the given scalar or scale vector. <br />
<code><a href="#Spline.translate">translate</a></code>:  Translate a spline by the given translation vector.  </p>
</div>


                            </div>
                            <div id="Spline.translate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.translate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">translate</span><span class="signature">(self, translationVector)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translationVector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate a spline by the given translation vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        translationVector : array-like</span>
<span class="sd">            An array of length `nDep` that specifies the translation vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            The translated spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `scale` : Scale a spline by the given scalar or scale vector.</span>
<span class="sd">        `transform` : Transform a spline by the given matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_operations</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translationVector</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Translate a spline by the given translation vector.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>translationVector</strong> (array-like):
An array of length <code>nDep</code> that specifies the translation vector.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
The translated spline.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.scale">scale</a></code>:  Scale a spline by the given scalar or scale vector. <br />
<code><a href="#Spline.transform">transform</a></code>:  Transform a spline by the given matrix.  </p>
</div>


                            </div>
                            <div id="Spline.trim" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.trim">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">trim</span><span class="signature">(self, newDomain)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim the domain of a spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newDomain : array-like</span>
<span class="sd">            nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as </span>
<span class="sd">            returned from `domain`). If a bound is None or nan then the original bound (and knots) are left unchanged.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : `Spline`</span>
<span class="sd">            Trimmed spline. If all the knots are unchanged, the original spline is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `domain` : Return the domain of a spline.</span>
<span class="sd">        `extrapolate` : Extrapolate a spline out to an extended domain maintaining a given order of continuity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDomain</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Trim the domain of a spline.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>newDomain</strong> (array-like):
nInd x 2 array of the new upper and lower bounds on each of the independent variables (same form as 
returned from <code><a href="#Spline.domain">domain</a></code>). If a bound is None or nan then the original bound (and knots) are left unchanged.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>spline</strong> (<code><a href="#Spline">Spline</a></code>):
Trimmed spline. If all the knots are unchanged, the original spline is returned.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.domain">domain</a></code>:  Return the domain of a spline. <br />
<code><a href="#Spline.extrapolate">extrapolate</a></code>:  Extrapolate a spline out to an extended domain maintaining a given order of continuity.  </p>
</div>


                            </div>
                            <div id="Spline.unfold" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.unfold">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">unfold</span><span class="signature">(self, foldedInd, coefficientlessSpline)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">,</span> <span class="n">coefficientlessSpline</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unfold the coefficients of an original spline&#39;s indicated independent variables back into the spline, using the </span>
<span class="sd">        indicated independent variables&#39; knots and orders from a second spline with no coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        foldedInd : `iterable`</span>
<span class="sd">            An iterable that specifies the independent variables whose coefficients should be unfolded.</span>

<span class="sd">        coefficientlessSpline : `Spline`</span>
<span class="sd">            The coefficientless spline that retains the indicated independent variables&#39; knots and orders.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unfoldedSpline : `Spline`, `Spline`</span>
<span class="sd">            The unfolded spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `fold` : Fold the coefficients of a spline&#39;s indicated independent variables into the coefficients of the remaining independent variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.</span>
<span class="sd">        The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, </span>
<span class="sd">        all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline </span>
<span class="sd">        with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, </span>
<span class="sd">        returning the original spline.</span>

<span class="sd">        Here&#39;s an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. </span>
<span class="sd">        Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have </span>
<span class="sd">        shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn&#39;t matter </span>
<span class="sd">        so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_domain</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldedInd</span><span class="p">,</span> <span class="n">coefficientlessSpline</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Unfold the coefficients of an original spline's indicated independent variables back into the spline, using the 
indicated independent variables' knots and orders from a second spline with no coefficients.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>foldedInd</strong> (<code>iterable</code>):
An iterable that specifies the independent variables whose coefficients should be unfolded.</li>
<li><strong>coefficientlessSpline</strong> (<code><a href="#Spline">Spline</a></code>):
The coefficientless spline that retains the indicated independent variables' knots and orders.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>unfoldedSpline</strong> (<code><a href="#Spline">Spline</a></code>, <code><a href="#Spline">Spline</a></code>):
The unfolded spline.</li>
</ul>

<h6 id="see-also">See Also</h6>

<p><code><a href="#Spline.fold">fold</a></code>:  Fold the coefficients of a spline's indicated independent variables into the coefficients of the remaining independent variables.  </p>

<h6 id="notes">Notes</h6>

<p>Given a spline whose coefficients are an nDep x n0 x ... x nk array and a list of (ordered) indices which form a proper subset of {n0, ... , nk}, it should return 2 splines.
The first one is a spline with k + 1 - length(index subset) independent variables where the knot sets of all the dimensions which have been removed have been removed.  However, 
all of the coefficient data is still intact, so that the resulting coefficient array has shape (nDep nj0 nj1 ... njj) x nk0 x ... x nkk.  The second spline should be a spline 
with 0 dependent variables which contains all the knot sequences that were removed from the spline.  The unfold method takes the two splines as input and reverses the process, 
returning the original spline.</p>

<p>Here's an example. Suppose spl is a spline with 3 independent variables and 3 dependent variables which has nCoef = [4, 5, 6] and knots = [knots0, knots1, knots2]. 
Then spl.fold([0, 2]) should return a spline with 1 independent variable and 72 dependent variables.  It should have nCoef = [5], knots = [knots1], and its coefs array should have 
shape (72, 5).  The other spline should have 0 dependent variables, 2 independent variables, and knots = [knots0, knots2].  How things get ordered in coefs probably doesn't matter 
so long as unfold unscrambles things in the corresponding way.  The second spline is needed to hold the basis information that was dropped so that it can be undone.</p>
</div>


                            </div>
                            <div id="Spline.zeros" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spline.zeros">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">zeros</span><span class="signature">(self, epsilon=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the roots of a spline (nInd must match nDep).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epsilon : `float`, optional</span>
<span class="sd">            Tolerance for root precision. The root will be within epsilon of the actual root. </span>
<span class="sd">            The default is the max of spline accuracy and machine epsilon.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : `iterable`</span>
<span class="sd">            An ordered iterable containing the roots of the spline. If the spline is </span>
<span class="sd">            zero over an interval, that root will appear as a tuple of the interval.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently, the algorithm only works for nInd == 1. </span>
<span class="sd">        Implements the algorithm from Grandine, Thomas A. &quot;Computing zeroes of spline functions.&quot; Computer Aided Geometric Design 6, no. 2 (1989): 129-136.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bspy</span><span class="o">.</span><span class="n">_spline_intersection</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Find the roots of a spline (nInd must match nDep).</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>epsilon</strong> (<code>float</code>, optional):
Tolerance for root precision. The root will be within epsilon of the actual root. 
The default is the max of spline accuracy and machine epsilon.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>roots</strong> (<code>iterable</code>):
An ordered iterable containing the roots of the spline. If the spline is 
zero over an interval, that root will appear as a tuple of the interval.</li>
</ul>

<h6 id="notes">Notes</h6>

<p>Currently, the algorithm only works for nInd == 1. 
Implements the algorithm from Grandine, Thomas A. "Computing zeroes of spline functions." Computer Aided Geometric Design 6, no. 2 (1989): 129-136.</p>
</div>


                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>